### 1.硬件的输入输出模式

硬件在输入输出上大体分为串行和并行 相应的接口也就是串行接口和并行接口。 串行硬件通过串行 接口与 CPU通信, 反过来也是， CPU通过串行接口与串行设备数据传输。 并行设备的访问类似, 只不过 是通过并行接口迸行的。

### 2.访问硬件的俩种方式：

- **内存映射**：将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中, 这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。

- **IO接口**：外设是通过 IO 接口与 CPU 通信的, CPU访问外设， 就是i方问 IO 接口， 由 IO接口将信息传递 给另一端的外设。访问IO接口是通过端口进行的，端口是指IO接口上的一部分寄存器。

### 3.用户态与内核态是对 CPU来讲的,

是指 CPU 运行在用户态 (特权3级) 还是内核态 (特权0级）

### 4.内存分段

使用绝地物理地址的话，如果编译出俩个相同地址的用户程序，那么只能运行一个，所以采用内存分段，即通过段基址+段内偏移地址来访问内存，首先这样可以实现程序的重定位，重定位是指将程序中的指令的地址改写为另外一个地址，但是该地址指向的内容和原地址的而内容相同，其次这样可以通过改变段基址所指向的位置来实现访问内存的任意部分。

### 5.平坦模型和多段模型

平坦模型是相对于多端模型来说的，多个小段再加上不断换段基址的方式访问内存过于迂回繁琐，比如在实模式下, 访问超过 64KB 的内存 需要重新指定不同的段基址'通过这种迂回变通的方式才能达到目的 在保护模式下， 由于其是 32 位的， 寻址范围便能够达到4GB， 段内偏移地址也是地址， 所以也是 32 位。 可见， 在32 位环境下用一个段就能够访问到硬件所支持的所有内存。 也就是说， 段的大小可以是地址总线能够到达 的范围 

### 6.段寄存器(sreg)

- **CS**：代码段
- **DS**：数据段
- **ES FS GS**：附加段
- **SS**：堆栈段

由于CPU有俩种工作模式，即**实模式**和**保护模式**，在实模式下， CS、 DS、 ES、 SS 中〈的值为段基址， 是具体的物理地址， 内存单元的逻辑地址仍为 “段基值:段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址,而是“段选择子″(Sdector)， 当然， 选择子也是数值， 其依然为16位宽度。`

### 7.Section和Segement

-  section称为节， 是指在汇编源码中经由关键字 section或segment修饰、 逻辑划分的指令或数据区域, 汇编器会将这两个关键字修饰的区域在目标文邗牛中编译成节， 也就是说 “节” 最初诞生于目标文件中。

-  segment 称为段， 是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合, 这个集合 称为 segment, 也就是段， 链接器把目标文件链接成可执行文件， 因此段最终诞生于可执行文件中。 我们 平时所说的可执行程序内存空间中的代码段和数据段就是指的 segment。

### 8.魔数

操作系统通过魔数实现按区分文件系统。

### 9.控制CPU的下一条指令

对于x86来说，程序计数器PC(PC只是一个概念，它的有多种实现方式)，是由CS:IP共同控制的，所以我们不能通过mov来修改其值。

对于ARM来说，是可以直接通过mov修改其PC的值的。

### 10.指令集和微架构

指令集(CISC RISC)是具体的一套指令编码, 微架构是指令集的物理实现方式。

### 11.物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

- 物理地址：物理上在内存中的位置，实际的地址。
- 逻辑地址/有效地址：无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。
- 线性地址：在保护模式下，“段基址+段内偏移地址”称为线性地址，不过此时的段基址不在是真正的地址，而是选择字。
- 虚拟地址：线性地址在开启地址分页功能下为被称为虚拟地址。

### 12.段重叠

![段重叠](/home/zhj/.config/Typora/typora-user-images/image-20240725194616289.png)

CPU 的内存寻址方式是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存。 它并不要求一个内存地址只隶属于某一个段，所以段重叠是科学的。

### 13.大小端序

- 小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址。因为低位在低字节，强制转换数据型时不需要再调整字节了。

- 大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字 节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。

### 14.BIOS 中断、DOS 中断、Linux 中断的区别

BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt  Vector Table，IVT）中的。它们都是通过软中断指令 int 中断号来调用的。

中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理例程（程序）的段基址和 段内偏移地址。因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序。

- BIOS中断：提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。
- DOS中断：只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程。通过先往 ah 寄存器中写好子功能号，再执行 int 0x21。 这时在中断向量表中第 0x21 个表项，即物理地址 0x21*4 处中的中断处理程序开始根据寄存器 ah 中的值来调用相应的子功能
- Linux中断： Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。如果在实模式下执行 int 指令，会自动去访问 中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。

### 15.库函数是用户进程与内核的桥梁

- 操作系统有自己支持、加载用户进程的规则，而 C 运行时库是针对此操作系统的规则，为了让用户程序开发更加容易，用来支持用户进程的代码库。、
- 用户进程要与 C 运行时库的诸多目标文件链接后合并成一个可执行文件，也就是说我们的用户进程被加进了大量的运行库中的代码。
- C 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工 作，所以即使不包含标准库文件，链接阶段也要用到 C 运行时库。
- 用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整，后面章节会有详解。 
- 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效。

### 16.MBR、EBR、DBR 和 OBR 各是什么

- MBR 是主引导记录：0盘0道1扇区(CHS方式) 0盘0道0扇区(LBA方式)

  - 446 字节的引导程序及参数；

  - 64 字节的分区表；

  - 2 字节结束标记 0x55 和 0xaa。
