### 硬件的输入输出模式

硬件在输入输出上大体分为串行和并行 相应的接口也就是串行接口和并行接口。 串行硬件通过串行 接口与 CPU通信, 反过来也是， CPU通过串行接口与串行设备数据传输。 并行设备的访问类似, 只不过 是通过并行接口迸行的。

### 访问硬件的俩种方式

- **内存映射**：将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中, 这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。

- **IO接口**：外设是通过 IO 接口与 CPU 通信的, CPU访问外设， 就是i方问 IO 接口， 由 IO接口将信息传递 给另一端的外设。访问IO接口是通过端口进行的，端口是指IO接口上的一部分寄存器。

### 用户态与内核态是对 CPU来讲的,

是指 CPU 运行在用户态 (特权3级) 还是内核态 (特权0级）

### 内存分段

使用绝地物理地址的话，如果编译出俩个相同地址的用户程序，那么只能运行一个，所以采用内存分段，即通过段基址+段内偏移地址来访问内存，首先这样可以实现程序的重定位，重定位是指将程序中的指令的地址改写为另外一个地址，但是该地址指向的内容和原地址的而内容相同，其次这样可以通过改变段基址所指向的位置来实现访问内存的任意部分。

### 平坦模型和多段模型

平坦模型是相对于多端模型来说的，多个小段再加上不断换段基址的方式访问内存过于迂回繁琐，比如在实模式下, 访问超过 64KB 的内存 需要重新指定不同的段基址'通过这种迂回变通的方式才能达到目的 在保护模式下， 由于其是 32 位的， 寻址范围便能够达到4GB， 段内偏移地址也是地址， 所以也是 32 位。 可见， 在32 位环境下用一个段就能够访问到硬件所支持的所有内存。 也就是说， 段的大小可以是地址总线能够到达 的范围 

### 段寄存器(sreg)

- **CS**：代码段
- **DS**：数据段
- **ES FS GS**：附加段
- **SS**：堆栈段

由于CPU有俩种工作模式，即**实模式**和**保护模式**，在实模式下， CS、 DS、 ES、 SS 中〈的值为段基址， 是具体的物理地址， 内存单元的逻辑地址仍为 “段基值:段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址,而是“段选择子″(Sdector)， 当然， 选择子也是数值， 其依然为16位宽度。`

### Section和Segement

-  section称为节， 是指在汇编源码中经由关键字 section或segment修饰、 逻辑划分的指令或数据区域, 汇编器会将这两个关键字修饰的区域在目标文邗牛中编译成节， 也就是说 “节” 最初诞生于目标文件中。

-  segment 称为段， 是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合, 这个集合 称为 segment, 也就是段， 链接器把目标文件链接成可执行文件， 因此段最终诞生于可执行文件中。 我们 平时所说的可执行程序内存空间中的代码段和数据段就是指的 segment。

### 魔数

操作系统通过魔数实现按区分文件系统。

### 控制CPU的下一条指令

对于x86来说，程序计数器PC(PC只是一个概念，它的有多种实现方式)，是由CS:IP共同控制的，所以我们不能通过mov来修改其值。

对于ARM来说，是可以直接通过mov修改其PC的值的。

### 指令集和微架构

指令集(CISC RISC)是具体的一套指令编码, 微架构是指令集的物理实现方式。

### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

- 物理地址：物理上在内存中的位置，实际的地址。
- 逻辑地址/有效地址：无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。
- 线性地址：在保护模式下，“段基址+段内偏移地址”称为线性地址，不过此时的段基址不在是真正的地址，而是选择字。
- 虚拟地址：线性地址在开启地址分页功能下为被称为虚拟地址。

### 段重叠

![段重叠](/home/zhj/.config/Typora/typora-user-images/image-20240725194616289.png)

CPU 的内存寻址方式是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存。 它并不要求一个内存地址只隶属于某一个段，所以段重叠是科学的。

### 大小端序

- 小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址。因为低位在低字节，强制转换数据型时不需要再调整字节了。

- 大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字 节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。

### BIOS 中断、DOS 中断、Linux 中断的区别

BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt  Vector Table，IVT）中的。它们都是通过软中断指令 int 中断号来调用的。

中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理例程（程序）的段基址和 段内偏移地址。因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序。

- BIOS中断：提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。
- DOS中断：只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程。通过先往 ah 寄存器中写好子功能号，再执行 int 0x21。 这时在中断向量表中第 0x21 个表项，即物理地址 0x21*4 处中的中断处理程序开始根据寄存器 ah 中的值来调用相应的子功能
- Linux中断： Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。如果在实模式下执行 int 指令，会自动去访问 中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。

### 库函数是用户进程与内核的桥梁

- 操作系统有自己支持、加载用户进程的规则，而 C 运行时库是针对此操作系统的规则，为了让用户程序开发更加容易，用来支持用户进程的代码库。、
- 用户进程要与 C 运行时库的诸多目标文件链接后合并成一个可执行文件，也就是说我们的用户进程被加进了大量的运行库中的代码。
- C 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工 作，所以即使不包含标准库文件，链接阶段也要用到 C 运行时库。
- 用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整，后面章节会有详解。 
- 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效。

### MBR、EBR、DBR 和 OBR 各是什么

- MBR 是主引导记录：0盘0道1扇区(CHS方式) 0盘0道0扇区(LBA方式)
- 446 字节的引导程序及参数；
  - 64 字节的分区表；
- 2 字节结束标记 0x55 和 0xaa。

- EBR是为扩展分区存储分区表的扇区
- DBR是DOS 操作系统的引导记录(程序)：
  - 跳转指令，使 MBR 跳转到引导代码；
  - 厂商信息、DOS 版本信息； 
  - BIOS 参数块 BPB，即 BIOS Parameter Block；
  - 操作系统引导程序；
  - 结束标记 0x55 和 0xaa。
- OBR是操作系统引导记录：在 OBR 扇区的前 3 个字节存放了跳转指令，因此 MBR 找到活动分区后，就大胆主动跳到活动分区 OBR 引导扇区的起始处，该起始处的跳 转指令马上将处理器带入操作系统引导程序。

![MBR OBR EBR的位置关系图](/home/zhj/.config/Typora/typora-user-images/image-20240726102324443.png)

### 计算机的启动过程

理解从 BIOS 到 MBR 到 Boot Loader 到 OS Boot Record（OBR）的启动过程：

1. **BIOS/UEFI**：
   - 计算机加电后，首先由 BIOS（基本输入输出系统）或者现代计算机上的 UEFI（统一扩展固件接口）控制启动。BIOS/UEFI负责硬件初始化、执行加电自检（POST）以及检测和初始化关键硬件设备如内存、CPU等。

2. **MBR（主引导记录）**：
   - BIOS/UEFI完成初始化后，会读取启动设备（通常是硬盘）的第一个扇区，即主引导记录（MBR）。MBR是一个特定的引导扇区，其中包含了引导加载程序（Boot Loader）的信息和位置。

3. **Boot Loader**：
   - MBR中存储的引导加载程序会被加载到内存中执行。引导加载程序的主要作用是加载操作系统的核心部分到内存中，并将控制权传递给操作系统的启动文件（如Windows的NTLDR或GRUB引导加载程序）。

4. **OS Boot Record（操作系统启动记录）**：
   - 引导加载程序加载操作系统的核心文件后，会继续加载操作系统的启动记录（OBR）。这是操作系统在磁盘上的特定扇区或分区，包含了操作系统启动所需的信息和配置。OBR的内容会进一步指导操作系统完成初始化和加载。

5. **操作系统加载**：
   - 最终，引导加载程序会将控制权传递给操作系统内核，操作系统开始初始化各种系统服务和用户界面，完成整个启动过程并显示登录屏幕或桌面环境。

这些步骤构成了从计算机加电到操作系统启动的完整过程，每个步骤都是确保计算机能够正常运行和准备好用户操作的重要环节。

### 地址总线和物理内存的关系 

在计算机中，并不是只有咱们插在主板上的内存条需要通过地址总线访问， 还有一些外设同样是需要通过地址总线来访问的，这类设备还很多呢。若把全部的地址总线都指向物理内 存，那其他设备该如何访问呢？由于这个原因，只好在地址总线上提前预留出来一些地址空间给这些外设 用，这片连续的地址给显存，这片连续的地址给硬盘控制器等。留够了以后，地址总线上其余的可用地址 再指向 DRAM，也就是指插在主板上的内存条、我们眼中的物理内存。

![地址映射关系图](/home/zhj/.config/Typora/typora-user-images/image-20240726104001483.png)

### 深入理解BIOS

![实模式下的 1MB 内存布局图](/home/zhj/.config/Typora/typora-user-images/image-20240726104530376.png)

在8086计算机开机时，CPU的cs:ip寄存器被强制初试化为0xF000:0xFFF0，在实模式下由于CPU访问的内存是段地址+偏移地址的方式来实现的，所以0xF000:0xFFF0，访问的地址是0xF000*16+0xFFF0=0xFFFF0。

0xFFFF0这个地址存放着一条指令，该指令内容是跳转至BIOS程序的入口（该指令由跳转指令与BIOS程序的入口地址组成，共16B)。BIOS有四个主要功能：1、硬件自检；2、建立一些需要用到的数据结构与中断向量表；3、校验启动盘中位于0盘0道1扇区（其实就是0扇区，只不过CHS方法用1开头）的内容，校验这里是不是放着主引导记录MBR，校验方法是检测这个扇区最后两个字节是不是0x55与0xaa（所以我们编写的主引导记录MBR最后两个字节应该是这两个）；4、在3的基础上是，那么就将该扇区内容加载至0x7c00内存处，这个位置是由于历史遗留导致的兼容，由最初的操作系统本身所占内存大小与布局所决定（书p58）。加载完毕后，然后跳转过去执行。

MBR的任务就是加载Loader，由loader加载操作系统到指定位置，然后执行加载过来的操作系统。MBR大小必须是512字节，这是为了占满硬盘0盘0道1扇区，且最最后两个字节必须是0x55与0xaa。

编写MBR(主引导记录)(yourPath/chapter2/a/boot/mbr.S)。

```ASM
                                ;主引导程序 
                                ;------------------------------------------------------------
SECTION MBR vstart=0x7c00       ;编译起始地址为0x7c00
    mov ax,cs                   ;此时cs寄存器为0，自然可以用来将ax寄存器置0
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00

                                ; 清屏 利用0x06号功能，上卷全部行，则可清屏。
                                ; -----------------------------------------------------------
                                ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                ;------------------------------------------------------
                                ;输入：
                                ;AH 功能号= 0x06
                                ;AL = 上卷的行数(如果为0,表示全部)
                                ;BH = 上卷行属性
                                ;(CL,CH) = 窗口左上角的(X,Y)位置
                                ;(DL,DH) = 窗口右下角的(X,Y)位置
                                ;无返回值：
    mov ax, 0x600               ;ah中输入功能号
    mov bx, 0x700               ;设置上卷行属性，0x70表示用黑底白字的属性填充空白行
    mov cx, 0                   ;左上角: (0, 0)
    mov dx, 0x184f	            ;右下角: (80,25),
			                    ;VGA文本模式中,一行只能容纳80个字符,共25行。
			                    ;下标从0开始,所以0x18=24,0x4f=79
    int 0x10                    ;int 0x10

                                ;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;
    mov ah, 3		            ;输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0		            ;bh寄存器存储的是待获取光标的页号

    int 0x10		            ;输出: ch=光标开始行,cl=光标结束行
		    	                ;dh=光标所在行号,dl=光标所在列号

                                ;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

                                ;;;;;;;;;     打印字符串    ;;;;;;;;;;;
                                ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message 
    mov bp, ax		            ; es:bp 为串首地址, es此时同cs一致，
			                    ; 开头时已经为sreg初始化

                                ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
    mov cx, 5		            ; cx 为串长度,不包括结束符0的字符个数
    mov ax, 0x1301	            ; 子功能号13是显示字符及属性,要存入ah寄存器,
			                    ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动
    mov bx, 0x2		            ; bh存储要显示的页号,此处是第0页,
			                    ; bl中是字符属性, 属性黑底绿字(bl = 02h,07是黑底白字)
    int 0x10		            ; 执行BIOS 0x10 号中断
                                ;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;

    jmp $		                ; 使程序悬停在此

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55,0xaa
```

$和$$是编译器 NASM 预留的关键字，用来表示当前行和本 section 的地址，起到了标号的作用，它 是 NASM 提供的，并不是 CPU 原生支持的，相当于伪指令一样，对 CPU 来说是假的。

### IO接口

CPU是通过内存映射或者IO接口来访问硬件的，这里我们主要看IO接口。IO 接口是连接 CPU 与外部设备的逻辑控制部件，既然称为逻辑，就说明可分为硬件和软件两部分。 硬件部分所做的都是一些实质具体的工作，其功能是协调 CPU 和外设之间的种种不匹配，如双方由于速 度不匹配，那 IO 接口就实现数据缓冲以减少等待时间，数据格式不匹配，IO 接口就在这两种格式间互相 转换。IO 接口内部实际上也是由软件来控制运作的，这就是所谓的“逻辑”部分，所以软件是指用来控 制接口电路工作的驱动程序以及完成内部数据传输所需要的程序。IO接口有以下功能：

- 设置数据缓冲，解决 CPU 与外设的速度不匹配；
- 设置信号电平转换电路；
- 设置数据格式转换；
- 设置时序控制电路来同步 CPU 和外部设备；
- 提供地址译码。

### 显卡、显存和显示器

显存是由显卡提供的，它是位于显卡内部的一块内存，所以它称为显存。有的显卡制品上标注的DDR 512M或者DDR2 1G。这指的就是显存大小。显卡的工作就是不断地读取这块内存，随后将其内容发送到显示器。

![显存地址分布表](/home/zhj/.config/Typora/typora-user-images/image-20240726113248070.png)

![字符属性表](/home/zhj/.config/Typora/typora-user-images/image-20240726113534939.png)

![RGB的配位颜色表](/home/zhj/.config/Typora/typora-user-images/image-20240726113735193.png)

### 完善MBR

之前，我们是通过BIOS中断来实现打印字符串。现在，我们尝试绕过BIOS来直接来显示字符。这是为了应对进入保护模式后不能使用BIOS。

能这样的原理是因为显卡的内存已经编排到了CPU能够寻址的范围之内，当CPU操作这部分“内存”时，实际上是直接在和显卡打交道。显卡拿到了数据处理之后，显示器最终会按照要求显示这些数据。

完善MBR，使其可以直接操作显卡(yourPath/chapter3/a/boot/mbr.S)。

```ASM
                                        ;主引导程序 
                                        ;
                                        ;LOADER_BASE_ADDR equ 0xA000 
                                        ;LOADER_START_SECTOR equ 0x2
                                        ;------------------------------------------------------------
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

                                        ; 清屏
                                        ;利用0x06号功能，上卷全部行，则可清屏。
                                        ; -----------------------------------------------------------
                                        ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                        ;------------------------------------------------------
                                        ;输入：
                                        ;AH 功能号= 0x06
                                        ;AL = 上卷的行数(如果为0,表示全部)
                                        ;BH = 上卷行属性
                                        ;(CL,CH) = 窗口左上角的(X,Y)位置
                                        ;(DL,DH) = 窗口右下角的(X,Y)位置
                                        ;无返回值：
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                           ; 左上角: (0, 0)
    mov dx, 184fh	                    ; 右下角: (80,25),
			                            ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
			                            ; 下标从0开始，所以0x18=24,0x4f=79
    int 10h                             ; int 10h

                                        ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
    mov byte [gs:0x00],'1'				; gs为数据段基址 低8位字符的ASII码或者字符本身 高8位为显示设置
    mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色 0xA4即0x10100100

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4   

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4

    jmp $		                        ; 通过死循环使程序悬停在此

    times 510-($-$$) db 0
    db 0x55,0xaa
```

### 硬盘

针对于硬盘的IO接口，被称为硬盘控制器，硬盘控制器同硬盘的关系，如同显卡和显示器一样，它们都是专门驱动外部设备的模块电路。

![硬盘控制器端口寄存器表](/home/zhj/.config/Typora/typora-user-images/image-20240726145423010.png)

端口可以被分为两组，Command Block registers 和 Control Block registers。Command Block registers 用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers 用于控制硬盘工作 状态。

逻辑块地址LBA(Logical Block Address)：不考虑扇区所在的物理结构，磁盘中扇区从 0 开 始依次递增编号，这是一 种逻辑上为扇区编址的方法。LBA分为俩种：

- LBA28：用 28 位比特来描述一个扇区的地址。最大寻址范围是 2 的 28 次方等 于 268435456 个扇区，每个扇区是 512 字节，最大支持 128GB，这里我们采用LBA28。
- LBA48：用 48 位比特来描述一个扇区的地址，最大可寻址范围是 2 的 48 次方， 等于 281474976710656 个扇区，乘以 512 字节后，最大支持 131072TB，即 128PB。

| 端口号(寄存器名)             | 功能                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 0x1F0 / 0x170 Data寄存器     | 管理数据                                                     |
| 0x1F1 / 0x171                | 读硬盘失败时，记录失败的信息，为Error寄存器<br />写硬盘时，为Features寄存器 |
| 0x1F2 / 0x172 Sector寄存器   | 指定待读取或待写入的扇区数                                   |
| 0x1F3 / 0x173 LBA low寄存器  | LBA28的0-7位                                                 |
| 0x1F4 / 0x174 LBA mid寄存器  | LBA28的8-15位                                                |
| 0x1F5 / 0x175 LBA high寄存器 | LBA28的16-23位                                               |
| 0x1F6 / 0x176 Device寄存器   | 低四位存放LBA28的24-27位<br />第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代 表从盘<br />第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式<br />第 5 位和第 7 位是固定为 1 的，称为 MBS 位 |
| 0x1F7 / 0x177                | 读硬盘时，为Status寄存器，给出硬盘的 状态信息<br />写硬盘时，为Command寄存器， |

![Device寄存器和Status寄存器详细位图](/home/zhj/.config/Typora/typora-user-images/image-20240726151836453.png)

### 一般的数据传送方式 

- 无条件传送方式
- 查询传送方式
- 中断传送方式
- 直接存储器存取方式（DMA）
- I/O 处理机传送方式。

硬盘不符合第 1 种方法，因为它需要在某种条件下才能传输。第 4 种和第 5 种需要单独的硬件支持，在Bochs中，我们用了第 2、3 这两种软件传输方式。

### 更完善MBR

我们的 MBR 受限于 512 字节大小的，在那么小的空间中，没法为内核准备好环境，更没法将内核成功加载到内存并运行。所以我们要在另一个程序中完成初始化环境及加载内核的任务，这个程序我们称之为 Loader，即加载器。问题来了，Loader 在哪里？如何跳过去执行？这就是新 款 MBR 的使命，简而言之就是负责从硬盘上把 Loader 加载到内存，

操作磁盘的步骤

![磁盘操作的步骤图](/home/zhj/.config/Typora/typora-user-images/image-20240726152925238.png)

操作端口的方法

![端口操作的方法指令图](/home/zhj/.config/Typora/typora-user-images/image-20240726153247554.png)

完善MBR，使其可以加载Loader(yourPath/chapter3/b/boot/mbr.S)。

```ASM
                                    ;主引导程序 
                                    ;------------------------------------------------------------
%include "boot.inc"
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

                                    ; 清屏
                                    ;利用0x06号功能，上卷全部行，则可清屏。
                                    ; -----------------------------------------------------------
                                    ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                    ;------------------------------------------------------
                                    ;输入：
                                    ;AH 功能号= 0x06
                                    ;AL = 上卷的行数(如果为0,表示全部)
                                    ;BH = 上卷行属性
                                    ;(CL,CH) = 窗口左上角的(X,Y)位置
                                    ;(DL,DH) = 窗口右下角的(X,Y)位置
                                    ;无返回值：
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                       ; 左上角: (0, 0)
    mov dx, 184fh		            ; 右下角: (80,25),
				                    ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
				                    ; 下标从0开始，所以0x18=24,0x4f=79
    int 10h                         ; int 10h

                                    ; 输出字符串:MBR
    mov byte [gs:0x00],'1'
    mov byte [gs:0x01],0xA4

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4	        ;A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4
	 
    mov eax,LOADER_START_SECTOR	    ; 起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 写入的地址
    mov cx,1			            ; 待读入的扇区数
    call rd_disk_m_16		        ; 以下读取程序的起始部分（一个扇区）
  
    jmp LOADER_BASE_ADDR
       
                                    ;-------------------------------------------------------------------------------
                                    ;功能:读取硬盘n个扇区
rd_disk_m_16:	   
                                    ;-------------------------------------------------------------------------------
				                    ; eax=LBA扇区号
				                    ; ebx=将数据写入的内存地址
				                    ; ecx=读入的扇区数
    mov esi,eax	                    ;备份eax
    mov di,cx		                ;备份cx
                                    ;读写硬盘:
                                    ;第1步：选择特定通道的寄存器，设置要读取的扇区数
    mov dx,0x1f2
    mov al,cl
    out dx,al                       ;读取的扇区数

    mov eax,esi	                    ;恢复ax

                                    ;第2步：在特定通道寄存器中放入要读取扇区的地址，将LBA地址存入0x1f3 ~ 0x1f6
                                    ;LBA地址7~0位写入端口0x1f3
    mov dx,0x1f3                       
    out dx,al                          

                                    ;LBA地址15~8位写入端口0x1f4
    mov cl,8
    shr eax,cl
    mov dx,0x1f4
    out dx,al

                                    ;LBA地址23~16位写入端口0x1f5
    shr eax,cl
    mov dx,0x1f5
    out dx,al

    shr eax,cl
    and al,0x0f	                    ;lba第24~27位
    or al,0xe0	                    ; 设置7～4位为1110,表示lba模式
    mov dx,0x1f6
    out dx,al

                                    ;第3步：向0x1f7端口写入读命令，0x20 
    mov dx,0x1f7
    mov al,0x20                        
    out dx,al

                                    ;第4步：检测硬盘状态
.not_ready:
                                    ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
    nop
    in al,dx
    and al,0x88	                    ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
    cmp al,0x08
    jnz .not_ready	                ;若未准备好，继续等。

                                    ;第5步：从0x1f0端口读数据
    mov ax, di                      ;di当中存储的是要读取的扇区数
    mov dx, 256                     ;每个扇区512字节，一次读取两个字节，所以一个扇区就要读取256次，与扇区数相乘，就等得到总读取次数
    mul dx                          ;8位乘法与16位乘法知识查看书p133,注意：16位乘法会改变dx的值！！！！
    mov cx, ax	                    ; 得到了要读取的总次数，然后将这个数字放入cx中
    mov dx, 0x1f0
.go_on_read:
    in ax,dx
    mov [bx],ax
    add bx,2		  
    loop .go_on_read
    ret

    times 510-($-$$) db 0
    db 0x55,0xaa
```

编写Loader，Loader 是要经过实模式到保护模 式的过渡，并最终在保护模式下加载内核，这只是一个简单而Loader程序(yourPath/chapter3/b/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR

                                    ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		                        ; 通过死循环使程序悬停在此
```

编写配置文件boot.inc，之后的配置信息都将写在这(yourPath/chapter3/b/boot/include/boot.inc)。

```ASM
                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900          ;定义了 loader 在内存中的位置
LOADER_START_SECTOR equ 0x2         ;定义了 loader 在硬盘上的逻辑扇区地址，即 LBA 地址
```

### 初识保护模式

CPU实模式有诸多不足：

- 实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。 
- 用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地指哪打哪。 
- 用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。 
- 访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎。 
- 一次只能运行一个程序，无法充分利用计算机资源。 
- 共 20 条地址线，最大可用内存为 1MB。

其中最致命的有两条：1、仅能寻址1MB内存空间；2、用户程序可以通过自由修改段基址来访问所有内存空间而引出的安全问题。所以后来的CPU自然就要解决以上的两个问题，CPU厂商为了凸显出自己新的CPU的安全性，将新开发出的CPU命名为工作在保护模式下——也就是提供了一种保护机制让程序不能随意访问所有内存空间，同时CPU的寻址范围也达到了4GB。而8086的那种工作模式由于保护模式的出现而被命名为实模式。

但由于8086CPU在当时取得了非凡的市场成功，所以后来的IA32体系架构CPU必须兼容8086的那种工作模式，所以IA32体系架构CPU也必须可以运行在实模式下。8086只能运行实模式，它使用[段基址：偏移]这种寻址方式，所以IA32体系架构CPU为了兼容8086上开发的程序，也得用[段基址：偏移]这种模式，但是又同时为了能够寻址更大的地址空间以及获得安全性检查，所以就采用了将段寄存器提供的值(16位)不再作为段基址，而是作为一个选择子去GDT表中找到对应的表项，然后从这个表项中得到段基址（32位）与进行安全性检查。所以说 32 位 CPU 具有保护模式和实模式两种运行模式，可以兼容实模式下的程序。兼容实模式，是指能够正确处理好实模式下的程序，并不是说在实模式下运行时就完全变成了纯 16 位的 CPU。

### 保护模式之寄存器扩展

实模式对应的是16位CPU，保护模式对应的是32位CPU，地址线的扩展，也就意味着寄存器的位扩展。

![保护模式下的寄存器扩展图](/home/zhj/.config/Typora/typora-user-images/image-20240726162945553.png)

除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器都由原来的 16 位扩展到了 32 位。寄存器中低 16 位的部分是为了兼容实模式，可以单独使用。高 16 位没办法单独使用，只能在用 32 位寄存器时才有机会用到它们。

### 保护模式之寻址扩展

![保护模式与实模式的寻址方式对比图](/home/zhj/.config/Typora/typora-user-images/image-20240726164333072.png)

保护模式相比与实模式拥有更为灵活，更大寻址范围的寻址方式。

### 保护模式之运行模式反转

在实模式下，运行的指令都是 16 位的，所以编译器 要将代码编译成 16 位的指令。在实模式下准备好了保护模式所需要的环境后，进入保护模式后的代码就应该 是 32 位指令。也就是，同一段程序要经历两种模式，所以同一段程序中有两种模式的机器码。 

bits 的指令格式是[bits 16]或[bits 32]：

- [bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。

- [bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码

由于运行模式的不同，操作数和寻址方式都各不相同，所以在改变运行模式时，需要在机器码中加入操作数反转前缀 0x66 和寻址方式反转前缀 0x67

### 保护模式之指令扩展

在 16 位的实模式下，CPU 的操作数是 16 位。在 32 位的保护模式下，操作数扩展到了 32 位，于是 涉及到操作数变化的指令也要跟着扩展，既要兼容 16 的操作数，也要支持 32 位的操作数。

在实模式下： 

- 当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2；

- 当压入 16 位立即数时，CPU 会将其直接入栈，sp-2；

- 当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

在保护模式下：

- 当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp-4；
-  当压入 16 位立即数时，CPU 直接压入 2 字节，esp-2；
-  当压入 32 位立即数时，CPU 直接压入 4 字节，esp-4。

### 段描述符（Segment Descriptor）

大小为 8 字节，用来描述各个内存段的起始地址、大小、 权限等信息。

![段描述符格式图](/home/zhj/.config/Typora/typora-user-images/image-20240726172135423.png)

-  段界限：表示段边界的扩展最值，扩展方向只有上下两种。对于数据段和代码段，段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。对于栈段，段的扩展方向是向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。段界限只是个单位量，它的单位要么是字节，要么是 4KB，这是由描述符中的 G 位来指定的，G=0，粒度大小为 1 ，G=1，粒度大小为4KB，最终段的边界是此段界限值单位，故段的大小要么是 2 的 20 次方等于 1MB，要么是 2 的 32 次方 (4KB 等于 2 的 12 次方，12+20=32)等于 4GB。 上面所说的 1MB 和 4GB 只是个范围，并不是具体的边界值。由于段界限只是个偏移量，是从 0 算起的，所以实际的段界限边界值=(描述符中段界限+1)(段界限的粒度大小：4KB 或者 1)-1。

- S段：要么描述系统段，要么描述的是数据段，S=0，是系统段，S=1,是数据段。

- TYPE段：本描述符的类型，表示内存段或门的子类型，与S段共同作用确定描述符类型。

  ![S=1，TYPE段的配位说明图](/home/zhj/.config/Typora/typora-user-images/image-20240726173447753.png)
  
  - A 位表示 Accessed 位，这是由 CPU 来设置的，每当该段被 CPU 访问过后，CPU 就将此位置 1。 所以，创建一个新段描述符时，应该将此位置 0。
  - C 位表示一致性代码段，也称为依从代码段，Conforming。一致性代码段是指如果自己是转移的目标段， 并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主， 而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码 段，C 为 0 时则表示该段为非一致性代码段。
  - E 位是用来标识段的扩展方向，Extend。E 为 0 表示向上扩展，即地址越来越高，通常用于代码段和数 据段。E 为 1 表示向下扩展，地址越来越低，通常用于栈段。
  - W 位指段是否可写，Writable。W 为 1 表示可写，通常用于数据段。W 为 0  表示不可写入，通常用于代码段。对于 W 为 0 的段有写入行为，同样会引发 CPU 抛出异常。
  - X 位表示该段是否可执行，EXecutable。指令和数据代码段是可执行的， 即 X 为 1。而数据段是不可执行的，即 X 为 0。
  - R 位表示可读，R 为 1 表示可读，R 为 0 表示不可读。

- DPL 段：即描述符特权级，这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级。
- P段：即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。
- AVL段：随意位。
- L段：是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32 位代码段。
- D/B 段：用来指示有效地址（段内偏移地址）及操作数的大小。D/B 为 0 表示指令中的有效地址和操作数是 16 位，D/B 为 1 表示指令中的有效地址和操作数是 32 位。
- G 段：Granularity，粒度，用来指定段界限的单位大小，G=0，粒度大小为 1 ，G=1，粒度大小为4KB。

### 全局描述符表 (Global Descriptor Table, GDT)

是一个存储段描述符的表格，每个段描述符描述了一个内存段的位置和属性，GDT可以被加载到GDTR寄存器中。

-  GDT的第0个段是不可用的，若选择字的索引值是0，会发生异常，但是LDT的第0个段是可用的。

### GDTR寄存器 (GDTR Register)
GDTR寄存器是x86架构中的一个控制寄存器，存储着全局描述符表（GDT）的起始地址和大小。

 - ![GDTR寄存器配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726192657785.png)
 - 前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于 GDT 的字节大小减 1。后 32 位是 GDT 的起始地址。由于 GDT 的大小是 16 位二进制，其表示的范围是 2 的16次方等于65536字节。每个描述符大小是8字节，故GDT中最多可容纳的描述符数量是65536/8=8192 个，即 GDT 中可容纳 8192 个段或门。

### 选择子 (Selector)
选择子是x86架构中用于选择GDT或LDT中段描述符的一种方式，它包含了一个索引和权限等信息，它是一个数字，用于索引访问全局描述符表或本地描述符表中的段描述符。
 -  ![选择字配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726193109018.png)
 - 其低 2 位即第 0～1 位， 用来存储 RPL，即请求特权级，可以表示 0、1、2、3 四种特权级。在选择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。TI 为 0 表示在 GDT 中索引描述符，TI 为 1 表示在 LDT 中索引描述符。选择子的高 13 位，即第 3～15 位是 描述符的索引值，用此值在 GDT 中索引描述符。13位最有索引8192个段 ，与GDT 中最多定义 8192 个描述符相吻合。
### 段描述符缓冲寄存器 (Segment Descriptor Cache Register)
用于缓存最近使用的段描述符，以提高内存访问效率。

### 打开A20地址线

以24位机器内存举例：

- 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存；

- 如果 A20Gate 被禁止，当访问 0x100000～0x10FFEF 之间的地址时，CPU 将采用 8086/8088 的地址回绕。

打开A20地址线的方式：端口 0x92 的第 1 位置 1。

```ASM
in al，0x92 
or al，0000_0010B 
out 0x92，al 
```

### 保护模式的开关，CR0 寄存器的 PE 位

![CRO配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726194054701.png)

打开位于CRO中的PE位，PE 为 0 表示在实模式下运行，PE 为 1 表示在保护模式下运行。

```ASM
mov eax, cr0 
or eax, 0x00000001 
mov cr0, eax 
```

### 打开保护模式的三步骤

![打开保护模式的三步骤](/home/zhj/.config/Typora/typora-user-images/image-20240726194352633.png)

编写配置文件(yourPath/chapter4/a/boot/include/boot.inc)。

```ASM
                                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2

                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的粒度为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中

```

编写Loader(yourPath/chapter4/a/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
    jmp loader_start					                ;loader一进来是一大堆GDT段描述符数据，无法执行，所以要跳过
   
                                                        
GDT_BASE:                                               ;构建gdt及其内部的描述符 8字节
    dd 0x00000000 
	dd 0x00000000

CODE_DESC:  
    dd 0x0000FFFF 
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	                                    ;limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE
    GDT_LIMIT equ GDT_SIZE - 1 
    times 60 dq 0					                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 
gdt_ptr dw GDT_LIMIT                                    ;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	    dd  GDT_BASE
loadermsg db '2 loader in real.'

loader_start:

                                                        ;------------------------------------------------------------
                                                        ;INT 0x10    功能号:0x13    功能描述:打印字符串
                                                        ;------------------------------------------------------------
                                                        ;输入:
                                                        ;AH 子功能号=13H
                                                        ;BH = 页码
                                                        ;BL = 属性(若AL=00H或01H)
                                                        ;CX＝字符串长度
                                                        ;(DH、DL)＝坐标(行、列)
                                                        ;ES:BP＝字符串地址 
                                                        ;AL＝显示输出方式
                                                        ;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变
                                                        ;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变
                                                        ;   2——字符串中含显示字符和显示属性。显示后，光标位置不变
                                                        ;   3——字符串中含显示字符和显示属性。显示后，光标位置改变
                                                        ;无返回值
    mov sp,LOADER_BASE_ADDR
    mov	bp,loadermsg                                    ; ES:BP = 字符串地址
    mov	cx,17			                                ; CX = 字符串长度
    mov	ax,0x1301		                                ; AH = 13,  AL = 01h
    mov	bx,0x001f		                                ; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)
    mov	dx,0x1800		                                ;
    int	0x10                                            ; 10h 号中断

                                                        ;-----------------   准备进入保护模式   ------------------------------------------
                                                        ;1 打开A20
                                                        ;2 加载gdt
                                                        ;3 将cr0的pe位置1


                                                        ;-----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ;----------------  cr0第0位即pe位置1  ---------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ;jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte gs:160], 'P'

    jmp $
```

修改MBR，即将加载 loader.bin 的读入扇区数增大(yourPath/chapter4/a/boot/mbr.S)。

```ASM
....... 
    mov eax,LOADER_START_SECTOR	    ; 起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 写入的地址
    mov cx,4			            ; 修改读入的扇区数为4
    call rd_disk_m_16		        ; 以下读取程序的起始部分（一个扇区）
........
```

### 处理器微架构

- 流水线技术：取指，译码，执行，三级流水线技术，提高CPU效率。
- 乱序执行：CPU 中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执 行，也许后面的指令先执行，当然，得保证指令之间不具备相关性。
- 缓存：是用一些存取速度较快的存储设备作为数据缓冲区，避免频繁访问速度 较慢的低速存储设备，这是以程序而时空局限性为根据的。
- 分支预测： 2 位预测法，分支目标缓冲器 BTB。

### 远跳转指令jmp

- 清空流水线：流水线中指令译码错误，需要清空流水线。
- 更新段描述符缓冲寄存器：段描述符缓冲寄存器在 CPU 的实模式和保护模式中都同时使用，在不重新引用一个段时，段描述符 缓冲寄存器中的内容是不会更新的，无论是在实模式，还是保护模式下，CPU 都以段描述符缓冲寄存器 中的内容为主。实模式进入保护模式时，由于段描述符缓冲寄存器中的内容仅仅是实模式下的 20 位的段 基址，很多属性位都是错误的值，这对保护模式来说必然会造成错误，所以需要马上更新段描述符缓冲寄 存器，也就是要想办法往相应段寄存器中加载选择子。

### 保护模式之内存段的保护

- 向段寄存器加载选择子时的保护

  - 根据选择子的值验证段描述符是否超越界限，且不是0。当选择字索引值为0时会索引到GDT的第0段，而GDT第0段不可用，会抛出异常。

    ![保护选择字示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726203216518.png)

  - 检查段寄存器的用途和段类型是否匹配

    ![段类型匹配规则表](/home/zhj/.config/Typora/typora-user-images/image-20240726203634579.png)

  - 检查段是否存在：如果 P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选 择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0， 则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。 这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。
  
- 代码段和数据段的保护 

  - CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围。

    ![非法访问示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726204034729.png)

- 栈段的保护

  -  对于向上扩展的段，实际的段界限是段内可以访问的最后一字节。

  - 对于向下扩展的段，实际的段界限是段内不可以访问的第一个字节。

    ![栈的段界限示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726204201433.png)
    
  - 32 位保护模式下栈的栈顶指针是 esp 寄存器，栈的操作数大小是由 B 位决定的，我们这里假设 B 为 1，即操作数是 32 位。栈段也是位于内存中，所以它也要受控于段描述符中的 G 位。 
  
    - 如果 G 为 0，实际的段界限大小=描述符中的段界限。 
    - 如果 G 为 1，实际的段界限大小=描述符中段界限*0x1000+0xFFF。