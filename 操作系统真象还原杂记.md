# 操作系统真象还原杂记

## 杂记

### 硬件的输入输出模式

硬件在输入输出上大体分为串行和并行 相应的接口也就是串行接口和并行接口。 串行硬件通过串行 接口与 CPU通信, 反过来也是， CPU通过串行接口与串行设备数据传输。 并行设备的访问类似, 只不过 是通过并行接口迸行的。

### 访问硬件的俩种方式

- **内存映射**：将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中, 这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。

- **IO接口**：外设是通过 IO 接口与 CPU 通信的, CPU访问外设， 就是i方问 IO 接口， 由 IO接口将信息传递 给另一端的外设。访问IO接口是通过端口进行的，端口是指IO接口上的一部分寄存器。

### 用户态与内核态是对 CPU来讲的,

是指 CPU 运行在用户态 (特权3级) 还是内核态 (特权0级）

### 内存分段

使用绝地物理地址的话，如果编译出俩个相同地址的用户程序，那么只能运行一个，所以采用内存分段，即通过段基址+段内偏移地址来访问内存，首先这样可以实现程序的重定位，重定位是指将程序中的指令的地址改写为另外一个地址，但是该地址指向的内容和原地址的而内容相同，其次这样可以通过改变段基址所指向的位置来实现访问内存的任意部分。

### 平坦模型和多段模型

平坦模型是相对于多端模型来说的，多个小段再加上不断换段基址的方式访问内存过于迂回繁琐，比如在实模式下, 访问超过 64KB 的内存 需要重新指定不同的段基址'通过这种迂回变通的方式才能达到目的 在保护模式下， 由于其是 32 位的， 寻址范围便能够达到4GB， 段内偏移地址也是地址， 所以也是 32 位。 可见， 在32 位环境下用一个段就能够访问到硬件所支持的所有内存。 也就是说， 段的大小可以是地址总线能够到达 的范围 

### 段寄存器(sreg)

- **CS**：代码段
- **DS**：数据段
- **ES FS GS**：附加段
- **SS**：堆栈段

由于CPU有俩种工作模式，即**实模式**和**保护模式**，在实模式下， CS、 DS、 ES、 SS 中〈的值为段基址， 是具体的物理地址， 内存单元的逻辑地址仍为 “段基值:段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址,而是“段选择子″(Sdector)， 当然， 选择子也是数值， 其依然为16位宽度。`

### Section和Segement

-  section称为节， 是指在汇编源码中经由关键字 section或segment修饰、 逻辑划分的指令或数据区域, 汇编器会将这两个关键字修饰的区域在目标文邗牛中编译成节， 也就是说 “节” 最初诞生于目标文件中。

-  segment 称为段， 是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合, 这个集合 称为 segment, 也就是段， 链接器把目标文件链接成可执行文件， 因此段最终诞生于可执行文件中。 我们 平时所说的可执行程序内存空间中的代码段和数据段就是指的 segment。

### 魔数

操作系统通过魔数实现按区分文件系统。

### 控制CPU的下一条指令

对于x86来说，程序计数器PC(PC只是一个概念，它的有多种实现方式)，是由CS:IP共同控制的，所以我们不能通过mov来修改其值。

对于ARM来说，是可以直接通过mov修改其PC的值的。

### 指令集和微架构

指令集(CISC RISC)是具体的一套指令编码, 微架构是指令集的物理实现方式。

### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

- 物理地址：物理上在内存中的位置，实际的地址。
- 逻辑地址/有效地址：无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。
- 线性地址：在保护模式下，“段基址+段内偏移地址”称为线性地址，不过此时的段基址不在是真正的地址，而是选择字。
- 虚拟地址：线性地址在开启地址分页功能下为被称为虚拟地址。

### 段重叠

![段重叠](/home/zhj/.config/Typora/typora-user-images/image-20240725194616289.png)

CPU 的内存寻址方式是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存。 它并不要求一个内存地址只隶属于某一个段，所以段重叠是科学的。

### 大小端序

- 小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址。因为低位在低字节，强制转换数据型时不需要再调整字节了。

- 大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字 节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。

### BIOS 中断、DOS 中断、Linux 中断的区别

BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt  Vector Table，IVT）中的。它们都是通过软中断指令 int 中断号来调用的。

中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理例程（程序）的段基址和 段内偏移地址。因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序。

- BIOS中断：提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。
- DOS中断：只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程。通过先往 ah 寄存器中写好子功能号，再执行 int 0x21。 这时在中断向量表中第 0x21 个表项，即物理地址 0x21*4 处中的中断处理程序开始根据寄存器 ah 中的值来调用相应的子功能
- Linux中断： Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。如果在实模式下执行 int 指令，会自动去访问 中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。

### 库函数是用户进程与内核的桥梁

- 操作系统有自己支持、加载用户进程的规则，而 C 运行时库是针对此操作系统的规则，为了让用户程序开发更加容易，用来支持用户进程的代码库。、
- 用户进程要与 C 运行时库的诸多目标文件链接后合并成一个可执行文件，也就是说我们的用户进程被加进了大量的运行库中的代码。
- C 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工 作，所以即使不包含标准库文件，链接阶段也要用到 C 运行时库。
- 用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整，后面章节会有详解。 
- 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效。

## 主引导记录 MBR

### MBR、EBR、DBR 和 OBR 各是什么

- MBR 是主引导记录：0盘0道1扇区(CHS方式) 0盘0道0扇区(LBA方式)
- 446 字节的引导程序及参数；
  - 64 字节的分区表；
- 2 字节结束标记 0x55 和 0xaa。

- EBR是为扩展分区存储分区表的扇区
- DBR是DOS 操作系统的引导记录(程序)：
  - 跳转指令，使 MBR 跳转到引导代码；
  - 厂商信息、DOS 版本信息； 
  - BIOS 参数块 BPB，即 BIOS Parameter Block；
  - 操作系统引导程序；
  - 结束标记 0x55 和 0xaa。
- OBR是操作系统引导记录：在 OBR 扇区的前 3 个字节存放了跳转指令，因此 MBR 找到活动分区后，就大胆主动跳到活动分区 OBR 引导扇区的起始处，该起始处的跳 转指令马上将处理器带入操作系统引导程序。

![MBR OBR EBR的位置关系图](/home/zhj/.config/Typora/typora-user-images/image-20240726102324443.png)

### 计算机的启动过程

理解从 BIOS 到 MBR 到 Boot Loader 到 OS Boot Record（OBR）的启动过程：

1. **BIOS/UEFI**：
   - 计算机加电后，首先由 BIOS（基本输入输出系统）或者现代计算机上的 UEFI（统一扩展固件接口）控制启动。BIOS/UEFI负责硬件初始化、执行加电自检（POST）以及检测和初始化关键硬件设备如内存、CPU等。

2. **MBR（主引导记录）**：
   - BIOS/UEFI完成初始化后，会读取启动设备（通常是硬盘）的第一个扇区，即主引导记录（MBR）。MBR是一个特定的引导扇区，其中包含了引导加载程序（Boot Loader）的信息和位置。

3. **Boot Loader**：
   - MBR中存储的引导加载程序会被加载到内存中执行。引导加载程序的主要作用是加载操作系统的核心部分到内存中，并将控制权传递给操作系统的启动文件（如Windows的NTLDR或GRUB引导加载程序）。

4. **OS Boot Record（操作系统启动记录）**：
   - 引导加载程序加载操作系统的核心文件后，会继续加载操作系统的启动记录（OBR）。这是操作系统在磁盘上的特定扇区或分区，包含了操作系统启动所需的信息和配置。OBR的内容会进一步指导操作系统完成初始化和加载。

5. **操作系统加载**：
   - 最终，引导加载程序会将控制权传递给操作系统内核，操作系统开始初始化各种系统服务和用户界面，完成整个启动过程并显示登录屏幕或桌面环境。

这些步骤构成了从计算机加电到操作系统启动的完整过程，每个步骤都是确保计算机能够正常运行和准备好用户操作的重要环节。

### 地址总线和物理内存的关系 

在计算机中，并不是只有咱们插在主板上的内存条需要通过地址总线访问， 还有一些外设同样是需要通过地址总线来访问的，这类设备还很多呢。若把全部的地址总线都指向物理内 存，那其他设备该如何访问呢？由于这个原因，只好在地址总线上提前预留出来一些地址空间给这些外设 用，这片连续的地址给显存，这片连续的地址给硬盘控制器等。留够了以后，地址总线上其余的可用地址 再指向 DRAM，也就是指插在主板上的内存条、我们眼中的物理内存。

![地址映射关系图](/home/zhj/.config/Typora/typora-user-images/image-20240726104001483.png)

### 深入理解BIOS

![实模式下的 1MB 内存布局图](/home/zhj/.config/Typora/typora-user-images/image-20240726104530376.png)

在8086计算机开机时，CPU的cs:ip寄存器被强制初试化为0xF000:0xFFF0，在实模式下由于CPU访问的内存是段地址+偏移地址的方式来实现的，所以0xF000:0xFFF0，访问的地址是0xF000*16+0xFFF0=0xFFFF0。

0xFFFF0这个地址存放着一条指令，该指令内容是跳转至BIOS程序的入口（该指令由跳转指令与BIOS程序的入口地址组成，共16B)。BIOS有四个主要功能：1、硬件自检；2、建立一些需要用到的数据结构与中断向量表；3、校验启动盘中位于0盘0道1扇区（其实就是0扇区，只不过CHS方法用1开头）的内容，校验这里是不是放着主引导记录MBR，校验方法是检测这个扇区最后两个字节是不是0x55与0xaa（所以我们编写的主引导记录MBR最后两个字节应该是这两个）；4、在3的基础上是，那么就将该扇区内容加载至0x7c00内存处，这个位置是由于历史遗留导致的兼容，由最初的操作系统本身所占内存大小与布局所决定（书p58）。加载完毕后，然后跳转过去执行。

MBR的任务就是加载Loader，由loader加载操作系统到指定位置，然后执行加载过来的操作系统。MBR大小必须是512字节，这是为了占满硬盘0盘0道1扇区，且最最后两个字节必须是0x55与0xaa。

编写MBR(主引导记录)(yourPath/chapter2/a/boot/mbr.S)。

```ASM
                                ;主引导程序 
                                ;------------------------------------------------------------
SECTION MBR vstart=0x7c00       ;编译起始地址为0x7c00
    mov ax,cs                   ;此时cs寄存器为0，自然可以用来将ax寄存器置0
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00

                                ; 清屏 利用0x06号功能，上卷全部行，则可清屏。
                                ; -----------------------------------------------------------
                                ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                ;------------------------------------------------------
                                ;输入：
                                ;AH 功能号= 0x06
                                ;AL = 上卷的行数(如果为0,表示全部)
                                ;BH = 上卷行属性
                                ;(CL,CH) = 窗口左上角的(X,Y)位置
                                ;(DL,DH) = 窗口右下角的(X,Y)位置
                                ;无返回值：
    mov ax, 0x600               ;ah中输入功能号
    mov bx, 0x700               ;设置上卷行属性，0x70表示用黑底白字的属性填充空白行
    mov cx, 0                   ;左上角: (0, 0)
    mov dx, 0x184f	            ;右下角: (80,25),
			                    ;VGA文本模式中,一行只能容纳80个字符,共25行。
			                    ;下标从0开始,所以0x18=24,0x4f=79
    int 0x10                    ;int 0x10

                                ;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;
    mov ah, 3		            ;输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0		            ;bh寄存器存储的是待获取光标的页号

    int 0x10		            ;输出: ch=光标开始行,cl=光标结束行
		    	                ;dh=光标所在行号,dl=光标所在列号

                                ;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

                                ;;;;;;;;;     打印字符串    ;;;;;;;;;;;
                                ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message 
    mov bp, ax		            ; es:bp 为串首地址, es此时同cs一致，
			                    ; 开头时已经为sreg初始化

                                ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
    mov cx, 5		            ; cx 为串长度,不包括结束符0的字符个数
    mov ax, 0x1301	            ; 子功能号13是显示字符及属性,要存入ah寄存器,
			                    ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动
    mov bx, 0x2		            ; bh存储要显示的页号,此处是第0页,
			                    ; bl中是字符属性, 属性黑底绿字(bl = 02h,07是黑底白字)
    int 0x10		            ; 执行BIOS 0x10 号中断
                                ;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;

    jmp $		                ; 使程序悬停在此

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55,0xaa
```

$和$$是编译器 NASM 预留的关键字，用来表示当前行和本 section 的地址，起到了标号的作用，它 是 NASM 提供的，并不是 CPU 原生支持的，相当于伪指令一样，对 CPU 来说是假的。

### IO接口

CPU是通过内存映射或者IO接口来访问硬件的，这里我们主要看IO接口。IO 接口是连接 CPU 与外部设备的逻辑控制部件，既然称为逻辑，就说明可分为硬件和软件两部分。 硬件部分所做的都是一些实质具体的工作，其功能是协调 CPU 和外设之间的种种不匹配，如双方由于速 度不匹配，那 IO 接口就实现数据缓冲以减少等待时间，数据格式不匹配，IO 接口就在这两种格式间互相 转换。IO 接口内部实际上也是由软件来控制运作的，这就是所谓的“逻辑”部分，所以软件是指用来控 制接口电路工作的驱动程序以及完成内部数据传输所需要的程序。IO接口有以下功能：

- 设置数据缓冲，解决 CPU 与外设的速度不匹配；
- 设置信号电平转换电路；
- 设置数据格式转换；
- 设置时序控制电路来同步 CPU 和外部设备；
- 提供地址译码。

### 显卡、显存和显示器

显存是由显卡提供的，它是位于显卡内部的一块内存，所以它称为显存。有的显卡制品上标注的DDR 512M或者DDR2 1G。这指的就是显存大小。显卡的工作就是不断地读取这块内存，随后将其内容发送到显示器。

![显存地址分布表](/home/zhj/.config/Typora/typora-user-images/image-20240726113248070.png)

![字符属性表](/home/zhj/.config/Typora/typora-user-images/image-20240726113534939.png)

![RGB的配位颜色表](/home/zhj/.config/Typora/typora-user-images/image-20240726113735193.png)

### 完善MBR

之前，我们是通过BIOS中断来实现打印字符串。现在，我们尝试绕过BIOS来直接来显示字符。这是为了应对进入保护模式后不能使用BIOS。

能这样的原理是因为显卡的内存已经编排到了CPU能够寻址的范围之内，当CPU操作这部分“内存”时，实际上是直接在和显卡打交道。显卡拿到了数据处理之后，显示器最终会按照要求显示这些数据。

完善MBR，使其可以直接操作显卡(yourPath/chapter3/a/boot/mbr.S)。

```ASM
                                        ;主引导程序 
                                        ;
                                        ;LOADER_BASE_ADDR equ 0xA000 
                                        ;LOADER_START_SECTOR equ 0x2
                                        ;------------------------------------------------------------
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

                                        ; 清屏
                                        ;利用0x06号功能，上卷全部行，则可清屏。
                                        ; -----------------------------------------------------------
                                        ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                        ;------------------------------------------------------
                                        ;输入：
                                        ;AH 功能号= 0x06
                                        ;AL = 上卷的行数(如果为0,表示全部)
                                        ;BH = 上卷行属性
                                        ;(CL,CH) = 窗口左上角的(X,Y)位置
                                        ;(DL,DH) = 窗口右下角的(X,Y)位置
                                        ;无返回值：
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                           ; 左上角: (0, 0)
    mov dx, 184fh	                    ; 右下角: (80,25),
			                            ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
			                            ; 下标从0开始，所以0x18=24,0x4f=79
    int 10h                             ; int 10h

                                        ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
    mov byte [gs:0x00],'1'				; gs为数据段基址 低8位字符的ASII码或者字符本身 高8位为显示设置
    mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色 0xA4即0x10100100

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4   

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4

    jmp $		                        ; 通过死循环使程序悬停在此

    times 510-($-$$) db 0
    db 0x55,0xaa
```

### 硬盘

针对于硬盘的IO接口，被称为硬盘控制器，硬盘控制器同硬盘的关系，如同显卡和显示器一样，它们都是专门驱动外部设备的模块电路。

![硬盘控制器端口寄存器表](/home/zhj/.config/Typora/typora-user-images/image-20240726145423010.png)

端口可以被分为两组，Command Block registers 和 Control Block registers。Command Block registers 用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers 用于控制硬盘工作 状态。

逻辑块地址LBA(Logical Block Address)：不考虑扇区所在的物理结构，磁盘中扇区从 0 开 始依次递增编号，这是一 种逻辑上为扇区编址的方法。LBA分为俩种：

- LBA28：用 28 位比特来描述一个扇区的地址。最大寻址范围是 2 的 28 次方等 于 268435456 个扇区，每个扇区是 512 字节，最大支持 128GB，这里我们采用LBA28。
- LBA48：用 48 位比特来描述一个扇区的地址，最大可寻址范围是 2 的 48 次方， 等于 281474976710656 个扇区，乘以 512 字节后，最大支持 131072TB，即 128PB。

| 端口号(寄存器名)             | 功能                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 0x1F0 / 0x170 Data寄存器     | 管理数据                                                     |
| 0x1F1 / 0x171                | 读硬盘失败时，记录失败的信息，为Error寄存器<br />写硬盘时，为Features寄存器 |
| 0x1F2 / 0x172 Sector寄存器   | 指定待读取或待写入的扇区数                                   |
| 0x1F3 / 0x173 LBA low寄存器  | LBA28的0-7位                                                 |
| 0x1F4 / 0x174 LBA mid寄存器  | LBA28的8-15位                                                |
| 0x1F5 / 0x175 LBA high寄存器 | LBA28的16-23位                                               |
| 0x1F6 / 0x176 Device寄存器   | 低四位存放LBA28的24-27位<br />第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代 表从盘<br />第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式<br />第 5 位和第 7 位是固定为 1 的，称为 MBS 位 |
| 0x1F7 / 0x177                | 读硬盘时，为Status寄存器，给出硬盘的 状态信息<br />写硬盘时，为Command寄存器， |

![Device寄存器和Status寄存器详细位图](/home/zhj/.config/Typora/typora-user-images/image-20240726151836453.png)

### 一般的数据传送方式 

- 无条件传送方式
- 查询传送方式
- 中断传送方式
- 直接存储器存取方式（DMA）
- I/O 处理机传送方式。

硬盘不符合第 1 种方法，因为它需要在某种条件下才能传输。第 4 种和第 5 种需要单独的硬件支持，在Bochs中，我们用了第 2、3 这两种软件传输方式。

### 更完善MBR

我们的 MBR 受限于 512 字节大小的，在那么小的空间中，没法为内核准备好环境，更没法将内核成功加载到内存并运行。所以我们要在另一个程序中完成初始化环境及加载内核的任务，这个程序我们称之为 Loader，即加载器。问题来了，Loader 在哪里？如何跳过去执行？这就是新 款 MBR 的使命，简而言之就是负责从硬盘上把 Loader 加载到内存，

操作磁盘的步骤

![磁盘操作的步骤图](/home/zhj/.config/Typora/typora-user-images/image-20240726152925238.png)

操作端口的方法

![端口操作的方法指令图](/home/zhj/.config/Typora/typora-user-images/image-20240726153247554.png)

完善MBR，使其可以加载Loader(yourPath/chapter3/b/boot/mbr.S)。

```ASM
                                    ;主引导程序 
                                    ;------------------------------------------------------------
%include "boot.inc"
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

                                    ; 清屏
                                    ;利用0x06号功能，上卷全部行，则可清屏。
                                    ; -----------------------------------------------------------
                                    ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                    ;------------------------------------------------------
                                    ;输入：
                                    ;AH 功能号= 0x06
                                    ;AL = 上卷的行数(如果为0,表示全部)
                                    ;BH = 上卷行属性
                                    ;(CL,CH) = 窗口左上角的(X,Y)位置
                                    ;(DL,DH) = 窗口右下角的(X,Y)位置
                                    ;无返回值：
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                       ; 左上角: (0, 0)
    mov dx, 184fh		            ; 右下角: (80,25),
				                    ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
				                    ; 下标从0开始，所以0x18=24,0x4f=79
    int 10h                         ; int 10h

                                    ; 输出字符串:MBR
    mov byte [gs:0x00],'1'
    mov byte [gs:0x01],0xA4

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4	        ;A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4
	 
    mov eax,LOADER_START_SECTOR	    ; 起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 写入的地址
    mov cx,1			            ; 待读入的扇区数
    call rd_disk_m_16		        ; 以下读取程序的起始部分（一个扇区）
  
    jmp LOADER_BASE_ADDR
       
                                    ;-------------------------------------------------------------------------------
                                    ;功能:读取硬盘n个扇区
rd_disk_m_16:	   
                                    ;-------------------------------------------------------------------------------
				                    ; eax=LBA扇区号
				                    ; ebx=将数据写入的内存地址
				                    ; ecx=读入的扇区数
    mov esi,eax	                    ;备份eax
    mov di,cx		                ;备份cx
                                    ;读写硬盘:
                                    ;第1步：选择特定通道的寄存器，设置要读取的扇区数
    mov dx,0x1f2
    mov al,cl
    out dx,al                       ;读取的扇区数

    mov eax,esi	                    ;恢复ax

                                    ;第2步：在特定通道寄存器中放入要读取扇区的地址，将LBA地址存入0x1f3 ~ 0x1f6
                                    ;LBA地址7~0位写入端口0x1f3
    mov dx,0x1f3                       
    out dx,al                          

                                    ;LBA地址15~8位写入端口0x1f4
    mov cl,8
    shr eax,cl
    mov dx,0x1f4
    out dx,al

                                    ;LBA地址23~16位写入端口0x1f5
    shr eax,cl
    mov dx,0x1f5
    out dx,al

    shr eax,cl
    and al,0x0f	                    ;lba第24~27位
    or al,0xe0	                    ; 设置7～4位为1110,表示lba模式
    mov dx,0x1f6
    out dx,al

                                    ;第3步：向0x1f7端口写入读命令，0x20 
    mov dx,0x1f7
    mov al,0x20                        
    out dx,al

                                    ;第4步：检测硬盘状态
.not_ready:
                                    ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
    nop
    in al,dx
    and al,0x88	                    ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
    cmp al,0x08
    jnz .not_ready	                ;若未准备好，继续等。

                                    ;第5步：从0x1f0端口读数据
    mov ax, di                      ;di当中存储的是要读取的扇区数
    mov dx, 256                     ;每个扇区512字节，一次读取两个字节，所以一个扇区就要读取256次，与扇区数相乘，就等得到总读取次数
    mul dx                          ;8位乘法与16位乘法知识查看书p133,注意：16位乘法会改变dx的值！！！！
    mov cx, ax	                    ; 得到了要读取的总次数，然后将这个数字放入cx中
    mov dx, 0x1f0
.go_on_read:
    in ax,dx
    mov [bx],ax
    add bx,2		  
    loop .go_on_read
    ret

    times 510-($-$$) db 0
    db 0x55,0xaa
```

编写Loader，Loader 是要经过实模式到保护模 式的过渡，并最终在保护模式下加载内核，这只是一个简单而Loader程序(yourPath/chapter3/b/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR

                                    ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		                        ; 通过死循环使程序悬停在此
```

编写配置文件boot.inc，之后的配置信息都将写在这(yourPath/chapter3/b/boot/include/boot.inc)。

```ASM
                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900          ;定义了 loader 在内存中的位置
LOADER_START_SECTOR equ 0x2         ;定义了 loader 在硬盘上的逻辑扇区地址，即 LBA 地址
```

## 保护模式

### 初识保护模式

CPU实模式有诸多不足：

- 实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。 
- 用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地指哪打哪。 
- 用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。 
- 访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎。 
- 一次只能运行一个程序，无法充分利用计算机资源。 
- 共 20 条地址线，最大可用内存为 1MB。

其中最致命的有两条：1、仅能寻址1MB内存空间；2、用户程序可以通过自由修改段基址来访问所有内存空间而引出的安全问题。所以后来的CPU自然就要解决以上的两个问题，CPU厂商为了凸显出自己新的CPU的安全性，将新开发出的CPU命名为工作在保护模式下——也就是提供了一种保护机制让程序不能随意访问所有内存空间，同时CPU的寻址范围也达到了4GB。而8086的那种工作模式由于保护模式的出现而被命名为实模式。

但由于8086CPU在当时取得了非凡的市场成功，所以后来的IA32体系架构CPU必须兼容8086的那种工作模式，所以IA32体系架构CPU也必须可以运行在实模式下。8086只能运行实模式，它使用[段基址：偏移]这种寻址方式，所以IA32体系架构CPU为了兼容8086上开发的程序，也得用[段基址：偏移]这种模式，但是又同时为了能够寻址更大的地址空间以及获得安全性检查，所以就采用了将段寄存器提供的值(16位)不再作为段基址，而是作为一个选择子去GDT表中找到对应的表项，然后从这个表项中得到段基址（32位）与进行安全性检查。所以说 32 位 CPU 具有保护模式和实模式两种运行模式，可以兼容实模式下的程序。兼容实模式，是指能够正确处理好实模式下的程序，并不是说在实模式下运行时就完全变成了纯 16 位的 CPU。

### 保护模式之寄存器扩展

实模式对应的是16位CPU，保护模式对应的是32位CPU，地址线的扩展，也就意味着寄存器的位扩展。

![保护模式下的寄存器扩展图](/home/zhj/.config/Typora/typora-user-images/image-20240726162945553.png)

除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器都由原来的 16 位扩展到了 32 位。寄存器中低 16 位的部分是为了兼容实模式，可以单独使用。高 16 位没办法单独使用，只能在用 32 位寄存器时才有机会用到它们。

### 保护模式之寻址扩展

![保护模式与实模式的寻址方式对比图](/home/zhj/.config/Typora/typora-user-images/image-20240726164333072.png)

保护模式相比与实模式拥有更为灵活，更大寻址范围的寻址方式。

### 保护模式之运行模式反转

在实模式下，运行的指令都是 16 位的，所以编译器 要将代码编译成 16 位的指令。在实模式下准备好了保护模式所需要的环境后，进入保护模式后的代码就应该 是 32 位指令。也就是，同一段程序要经历两种模式，所以同一段程序中有两种模式的机器码。 

bits 的指令格式是[bits 16]或[bits 32]：

- [bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。

- [bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码

由于运行模式的不同，操作数和寻址方式都各不相同，所以在改变运行模式时，需要在机器码中加入操作数反转前缀 0x66 和寻址方式反转前缀 0x67

### 保护模式之指令扩展

在 16 位的实模式下，CPU 的操作数是 16 位。在 32 位的保护模式下，操作数扩展到了 32 位，于是 涉及到操作数变化的指令也要跟着扩展，既要兼容 16 的操作数，也要支持 32 位的操作数。

在实模式下： 

- 当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2；

- 当压入 16 位立即数时，CPU 会将其直接入栈，sp-2；

- 当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

在保护模式下：

- 当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp-4；
-  当压入 16 位立即数时，CPU 直接压入 2 字节，esp-2；
-  当压入 32 位立即数时，CPU 直接压入 4 字节，esp-4。

### 段描述符（Segment Descriptor）

大小为 8 字节，用来描述各个内存段的起始地址、大小、 权限等信息。

![段描述符格式图](/home/zhj/.config/Typora/typora-user-images/image-20240726172135423.png)

-  段界限：表示段边界的扩展最值，扩展方向只有上下两种。对于数据段和代码段，段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。对于栈段，段的扩展方向是向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。段界限只是个单位量，它的单位要么是字节，要么是 4KB，这是由描述符中的 G 位来指定的，G=0，粒度大小为 1 ，G=1，粒度大小为4KB，最终段的边界是此段界限值单位，故段的大小要么是 2 的 20 次方等于 1MB，要么是 2 的 32 次方 (4KB 等于 2 的 12 次方，12+20=32)等于 4GB。 上面所说的 1MB 和 4GB 只是个范围，并不是具体的边界值。由于段界限只是个偏移量，是从 0 算起的，所以实际的段界限边界值=(描述符中段界限+1)(段界限的粒度大小：4KB 或者 1)-1。

- S段：要么描述系统段，要么描述的是数据段，S=0，是系统段，S=1,是数据段。

- TYPE段：本描述符的类型，表示内存段或门的子类型，与S段共同作用确定描述符类型。

  ![S=1，TYPE段的配位说明图](/home/zhj/.config/Typora/typora-user-images/image-20240726173447753.png)
  
  - A 位表示 Accessed 位，这是由 CPU 来设置的，每当该段被 CPU 访问过后，CPU 就将此位置 1。 所以，创建一个新段描述符时，应该将此位置 0。
  - C 位表示一致性代码段，也称为依从代码段，Conforming。一致性代码段是指如果自己是转移的目标段， 并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主， 而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码 段，C 为 0 时则表示该段为非一致性代码段。
  - E 位是用来标识段的扩展方向，Extend。E 为 0 表示向上扩展，即地址越来越高，通常用于代码段和数 据段。E 为 1 表示向下扩展，地址越来越低，通常用于栈段。
  - W 位指段是否可写，Writable。W 为 1 表示可写，通常用于数据段。W 为 0  表示不可写入，通常用于代码段。对于 W 为 0 的段有写入行为，同样会引发 CPU 抛出异常。
  - X 位表示该段是否可执行，EXecutable。指令和数据代码段是可执行的， 即 X 为 1。而数据段是不可执行的，即 X 为 0。
  - R 位表示可读，R 为 1 表示可读，R 为 0 表示不可读。

- DPL 段：即描述符特权级，这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级。
- P段：即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。
- AVL段：随意位。
- L段：是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32 位代码段。
- D/B 段：用来指示有效地址（段内偏移地址）及操作数的大小。D/B 为 0 表示指令中的有效地址和操作数是 16 位，D/B 为 1 表示指令中的有效地址和操作数是 32 位。
- G 段：Granularity，粒度，用来指定段界限的单位大小，G=0，粒度大小为 1 ，G=1，粒度大小为4KB。

### 全局描述符表 (Global Descriptor Table, GDT)

是一个存储段描述符的表格，每个段描述符描述了一个内存段的位置和属性，GDT可以被加载到GDTR寄存器中。

-  GDT的第0个段是不可用的，若选择字的索引值是0，会发生异常，但是LDT的第0个段是可用的。

### GDTR寄存器 (GDTR Register)
GDTR寄存器是x86架构中的一个控制寄存器，存储着全局描述符表（GDT）的起始地址和大小。

 - ![GDTR寄存器配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726192657785.png)
 - 前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于 GDT 的字节大小减 1。后 32 位是 GDT 的起始地址。由于 GDT 的大小是 16 位二进制，其表示的范围是 2 的16次方等于65536字节。每个描述符大小是8字节，故GDT中最多可容纳的描述符数量是65536/8=8192 个，即 GDT 中可容纳 8192 个段或门。

### 选择子 (Selector)
选择子是x86架构中用于选择GDT或LDT中段描述符的一种方式，它包含了一个索引和权限等信息，它是一个数字，用于索引访问全局描述符表或本地描述符表中的段描述符。
 -  ![选择字配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726193109018.png)
 - 其低 2 位即第 0～1 位， 用来存储 RPL，即请求特权级，可以表示 0、1、2、3 四种特权级。在选择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。TI 为 0 表示在 GDT 中索引描述符，TI 为 1 表示在 LDT 中索引描述符。选择子的高 13 位，即第 3～15 位是 描述符的索引值，用此值在 GDT 中索引描述符。13位最有索引8192个段 ，与GDT 中最多定义 8192 个描述符相吻合。
### 段描述符缓冲寄存器 (Segment Descriptor Cache Register)
用于缓存最近使用的段描述符，以提高内存访问效率。

### 打开A20地址线

以24位机器内存举例：

- 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存；

- 如果 A20Gate 被禁止，当访问 0x100000～0x10FFEF 之间的地址时，CPU 将采用 8086/8088 的地址回绕。

打开A20地址线的方式：端口 0x92 的第 1 位置 1。

```ASM
in al，0x92 
or al，0000_0010B 
out 0x92，al 
```

### 保护模式的开关，CR0 寄存器的 PE 位

![CRO配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726194054701.png)

打开位于CRO中的PE位，PE 为 0 表示在实模式下运行，PE 为 1 表示在保护模式下运行。

```ASM
mov eax, cr0 
or eax, 0x00000001 
mov cr0, eax 
```

### 打开保护模式的三步骤

![打开保护模式的三步骤](/home/zhj/.config/Typora/typora-user-images/image-20240726194352633.png)

编写配置文件(yourPath/chapter4/a/boot/include/boot.inc)。

```ASM
                                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2

                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的粒度为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中

```

编写Loader(yourPath/chapter4/a/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
    jmp loader_start					                ;loader一进来是一大堆GDT段描述符数据，无法执行，所以要跳过
   
                                                        
GDT_BASE:                                               ;构建gdt及其内部的描述符 8字节
    dd 0x00000000 
	dd 0x00000000

CODE_DESC:  
    dd 0x0000FFFF 
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	                                    ;limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE
    GDT_LIMIT equ GDT_SIZE - 1 
    times 60 dq 0					                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 
gdt_ptr dw GDT_LIMIT                                    ;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	    dd  GDT_BASE
loadermsg db '2 loader in real.'

loader_start:

                                                        ;------------------------------------------------------------
                                                        ;INT 0x10    功能号:0x13    功能描述:打印字符串
                                                        ;------------------------------------------------------------
                                                        ;输入:
                                                        ;AH 子功能号=13H
                                                        ;BH = 页码
                                                        ;BL = 属性(若AL=00H或01H)
                                                        ;CX＝字符串长度
                                                        ;(DH、DL)＝坐标(行、列)
                                                        ;ES:BP＝字符串地址 
                                                        ;AL＝显示输出方式
                                                        ;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变
                                                        ;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变
                                                        ;   2——字符串中含显示字符和显示属性。显示后，光标位置不变
                                                        ;   3——字符串中含显示字符和显示属性。显示后，光标位置改变
                                                        ;无返回值
    mov sp,LOADER_BASE_ADDR
    mov	bp,loadermsg                                    ; ES:BP = 字符串地址
    mov	cx,17			                                ; CX = 字符串长度
    mov	ax,0x1301		                                ; AH = 13,  AL = 01h
    mov	bx,0x001f		                                ; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)
    mov	dx,0x1800		                                ;
    int	0x10                                            ; 10h 号中断

                                                        ;-----------------   准备进入保护模式   ------------------------------------------
                                                        ;1 打开A20
                                                        ;2 加载gdt
                                                        ;3 将cr0的pe位置1


                                                        ;-----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ;----------------  cr0第0位即pe位置1  ---------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ;jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $
```

修改MBR，即将加载 loader.bin 的读入扇区数增大(yourPath/chapter4/a/boot/mbr.S)。

```ASM
....... 
    mov eax,LOADER_START_SECTOR	    ; 起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 写入的地址
    mov cx,4			            ; 修改读入的扇区数为4
    call rd_disk_m_16		        ; 以下读取程序的起始部分（一个扇区）
........
```

### 处理器微架构

- 流水线技术：取指，译码，执行，三级流水线技术，提高CPU效率。
- 乱序执行：CPU 中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执 行，也许后面的指令先执行，当然，得保证指令之间不具备相关性。
- 缓存：是用一些存取速度较快的存储设备作为数据缓冲区，避免频繁访问速度 较慢的低速存储设备，这是以程序而时空局限性为根据的。
- 分支预测： 2 位预测法，分支目标缓冲器 BTB。

### 远跳转指令jmp

- 清空流水线：流水线中指令译码错误，需要清空流水线。
- 更新段描述符缓冲寄存器：段描述符缓冲寄存器在 CPU 的实模式和保护模式中都同时使用，在不重新引用一个段时，段描述符 缓冲寄存器中的内容是不会更新的，无论是在实模式，还是保护模式下，CPU 都以段描述符缓冲寄存器 中的内容为主。实模式进入保护模式时，由于段描述符缓冲寄存器中的内容仅仅是实模式下的 20 位的段 基址，很多属性位都是错误的值，这对保护模式来说必然会造成错误，所以需要马上更新段描述符缓冲寄 存器，也就是要想办法往相应段寄存器中加载选择子。

### 保护模式之内存段的保护

- 向段寄存器加载选择子时的保护

  - 根据选择子的值验证段描述符是否超越界限，且不是0。当选择字索引值为0时会索引到GDT的第0段，而GDT第0段不可用，会抛出异常。

    ![保护选择字示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726203216518.png)

  - 检查段寄存器的用途和段类型是否匹配

    ![段类型匹配规则表](/home/zhj/.config/Typora/typora-user-images/image-20240726203634579.png)

  - 检查段是否存在：如果 P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选 择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0， 则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。 这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。
  
- 代码段和数据段的保护 

  - CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围。

    ![非法访问示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726204034729.png)

- 栈段的保护

  -  对于向上扩展的段，实际的段界限是段内可以访问的最后一字节。

  - 对于向下扩展的段，实际的段界限是段内不可以访问的第一个字节。

    ![栈的段界限示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726204201433.png)
    
  - 32 位保护模式下栈的栈顶指针是 esp 寄存器，栈的操作数大小是由 B 位决定的，我们这里假设 B 为 1，即操作数是 32 位。栈段也是位于内存中，所以它也要受控于段描述符中的 G 位。 
  
    - 如果 G 为 0，实际的段界限大小=描述符中的段界限。 
    - 如果 G 为 1，实际的段界限大小=描述符中段界限*0x1000+0xFFF。

### 获取物理内存的方式

- 利用 BIOS 中断 0x15 子功能 0xE820 获取内存 

  由于系统内存各部分的类型属性不同， BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。子功能 0xE820 的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符（Address Range Descriptor Structure，ARDS），格式如下：

  ![ARDS结构表](/home/zhj/.config/Typora/typora-user-images/image-20240802163758652.png)

  ![ARDS的Type字段表](/home/zhj/.config/Typora/typora-user-images/image-20240802163838967.png)

  由表可知，此结构中的字段大小都是 4 字节，共 5 个字段，所以此结构大小为 20 字节。每次 int 0x15 之后，BIOS 就返回这样一个结构的数据。注意，ARDS 结构中用 64 位宽度的属性来描述这段内存基地址（起始地址） 及其长度，所以表中的基地址和长度都分为低 32 位和高 32 位两部分。在所有返回的 ARDS 结构里，此值最大的内存块 一定是操作系统可使用的部分，即主板上配置的物理内存容量。BIOS 中断也是函数例程，所以调用它也需要传参，它也会有”返回值“。

  ![0xE820参数示意表1](/home/zhj/.config/Typora/typora-user-images/image-20240802164549543.png)

  ![0xE820中断参数示意表2](/home/zhj/.config/Typora/typora-user-images/image-20240802164641669.png)

  0xE820 调用步骤如下：

  -  填写好“调用前输入”中列出的寄存器。
  - 执行中断调用 int 0x15。
  -  CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

- 利用 BIOS 中断 0x15 子功能 0xE801 获取内存

  分为俩部分，0-15MB和16MB-4GB，低于 15MB 的内存以 1KB 为单位大小来记录， 单位数量在寄存器 AX 和 CX 中记录，其中 AX 和 CX 的值是一样的，所以在 15MB 空间以下的实际内存容量 =AX * 1024。AX、CX 最大值为 0x3c00，即 0x3c00 * 1024=15MB。16MB～4GB 是以 64KB 为单位大小来记录的， 单位数量在寄存器 BX 和 DX 中记录，其中 BX 和 DX 的值是一样的，所以 16MB 以上空间的内存实际大小 =BX * 64 * 1024。

  ![0xE801参数示意表](/home/zhj/.config/Typora/typora-user-images/image-20240802165848936.png)

  分为两部分的原因任然是历史遗留问题，为支持ISA设备，ISA设备会使用到地址15MB以上的1MB的内存作为缓冲区，这部分内存操作系统不可用，即内存空洞。所以实际的物理内存大小，是通过 0xE801 子功能检测到的内存大小 + 1MB 得来的。

  0xE801 调用步骤如下：

  - 将 AX 寄存器写入 0xE801。 
  - 执行中断调用 int 0x15。
  - 在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

- 利用 BIOS 中断 0x15 子功能 0x88 获取内存

  只能识别最大 64MB 的内存。即使内存容量大于 64MB，也只会显示 63MB。

  ![0x88参数示意表](/home/zhj/.config/Typora/typora-user-images/image-20240802171503102.png)
  
  0x88 调用步骤如下：
  
  - 将 AX 寄存器写入 0x88。 
  - 执行中断调用 int 0x15。
  - 在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

编写加载程序(yourPath/chapter5/a/boot/loader.S)。

```asm
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
                                                        
GDT_BASE:                                               ; 构建gdt及其内部的描述符
    dd 0x00000000 
	dd 0x00000000

CODE_DESC:  
    dd 0x0000FFFF 
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	                                    ; limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE
    GDT_LIMIT equ GDT_SIZE - 1 
    times 60 dq 0					                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 

    total_mem_bytes dd 0				                ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。
                                                        ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,
                                                        ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址	 
                                                        
    gdt_ptr dw GDT_LIMIT                                ; 定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	        dd  GDT_BASE

    ards_buf times 244 db 0                             ; 人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节
    ards_nr dw 0	

loader_start:
                                                        ; -------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------

    xor ebx, ebx		                                ; 第一次调用时，ebx值要为0
    mov edx, 0x534d4150	                                ; edx只赋值一次，循环体中不会改变
    mov di, ards_buf	                                ; ards结构缓冲区
.e820_mem_get_loop:	                                    ; 循环获取每个ARDS内存范围描述结构
    mov eax, 0x0000e820	                                ; 执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。
    mov ecx, 20		                                    ; ARDS地址范围描述符结构大小是20字节
    int 0x15
    add di, cx		                                    ; 使di增加20字节指向缓冲区中新的ARDS结构位置
    inc word [ards_nr]	                                ; 记录ARDS数量
    cmp ebx, 0		                                    ; 若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个
    jnz .e820_mem_get_loop

                                                        ; 在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。
    mov cx, [ards_nr]	                                ; 遍历每一个ARDS结构体,循环次数是ARDS的数量
    mov ebx, ards_buf 
    xor edx, edx		                                ; edx为最大的内存容量,在此先清0
.find_max_mem_area:	                                    ; 无须判断type是否为1,最大的内存块一定是可被使用
    mov eax, [ebx]	                                    ; base_add_low
    add eax, [ebx+8]	                                ; length_low
    add ebx, 20		                                    ; 指向缓冲区中下一个ARDS结构
    cmp edx, eax		                                ; 冒泡排序，找出最大,edx寄存器始终是最大的内存容量
    jge .next_ards 
    mov edx, eax                                        ; edx 为总内存大小
.next_ards:
    loop .find_max_mem_area 
    jmp .mem_get_ok 

                                                        ; ------ int 15h ax = E801h 获取内存大小，最大支持 4G ------ 
                                                        ;  返回后, ax cx 值一样,以 1KB 为单位，bx dx 值一样，以 64KB 为单位
                                                        ;  在 ax 和 cx 寄存器中为低 16MB，在 bx 和 dx 寄存器中为 16MB 到 4GB 
.e820_failed_so_try_e801:
    mov ax,0xe801 
    int 0x15 
    jc .e801_failed_so_try88                            ; 若当前 e801 方法失败，就尝试 0x88 方法

                                                        ; 1 先算出低 15MB 的内存
                                                        ; ax 和 cx 中是以 1KB 为单位的内存数量，将其转换为以 byte 为单位
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
    mul cx                                              ; 用 AX 寄存器中的值乘以 CX 的值，结果存入 DX:AX
    shl edx, 16                                         ; 将 EDX 中的值左移 16 位，结果存入 EDX
    and eax, 0x0000FFFF                                 ; 仅保留 EAX 的低 16 位，高 16 位清零
    or edx, eax                                         ; 将 EAX 的值合并到 EDX 的低 16 位
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
    mov esi, edx                                        ; 将 EDX 的值存入 ESI 寄存器
                                                        ; 先把低 15MB 的内存容量存入 esi 寄存器备份

                                                        ; 2 再将 16MB 以上的内存转换为 byte 为单位
                                                        ; 寄存器 bx 和 dx 中是以 64KB 为单位的内存数量
    xor eax,eax 
    mov ax,bx 
    mov ecx, 0x10000                                    ; 0x10000 十进制为 64KB 
    mul ecx                                             ; 32 位乘法，默认的被乘数是 eax，积为 64 位
                                                        ; 高 32 位存入 edx，低 32 位存入 eax 
    add esi,eax 
                                                        ; 由于此方法只能测出 4GB 以内的内存，故 32 位 eax 足够了
                                                        ; edx 肯定为 0，只加 eax 便可
    mov edx,esi                                         ; edx 为总内存大小
    jmp .mem_get_ok 

                                                        ; ----- int 15h     ah = 0x88 获取内存大小，只能获取 64MB 之内 ----- 
.e801_failed_so_try88: 
    mov ah, 0x88                                        ; 设置 AH 寄存器为 0x88，准备调用 BIOS 中断
    int 0x15                                            ; 调用 BIOS 中断 0x15，子功能 0x88，获取内存信息
    jc .error_hlt                                       ; 如果调用失败（进位标志被设置），跳转到 .error_hlt 标签

    and eax, 0x0000FFFF                                 ; 清除 EAX 的高 16 位，仅保留低 16 位
                                                        ; AX 存储的是以 1KB 为单位的内存容量
    
                                                        ; 16 位乘法，被乘数是 AX，积为 32 位。积的高 16 位在 DX 中，积的低 16 位在 AX 中
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
                                                        ; 用于将 AX 中的内存容量转换为字节
    
    mul cx                                              ; 进行乘法运算，AX * CX，结果为 32 位，高 16 位在 DX 中，低 16 位在 AX 中
    shl edx, 16                                         ; 将 DX 的值左移 16 位，结果存储在 EDX 中
    or edx, eax                                         ; 将 EAX 中的低 16 位值与 EDX 进行按位或操作，合并结果存储在 EDX 中
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
                                                        ; 因为 0x88 子功能只会返回 1MB 以上的内存，所以要加上 1MB


.mem_get_ok:
mov [total_mem_bytes], edx                              ; 将内存换为 byte 单位后存入 total_mem_bytes 处


                                                        ; -----------------   准备进入保护模式   ------------------------------------------
                                                        ; 1 打开A20
                                                        ; 2 加载gdt
                                                        ; 3 将cr0的pe位置1


                                                        ; -----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ; -----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ; -----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ; jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

                                                        
    .error_hlt:		                                    ; 出错则挂起
    hlt

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $
```

显然，作者是错误的，他得出32MB的这个数据是碰巧得到的。作者这样寻找最大地址的方法，最后得出来整个内存大小是32MB的确是巧合。因为最后一个ARDS结构体最大地址是4GB，溢出eax寄存器的值，所以最后得到的最大地址是倒数第二个类型ARDS结构体(type=1)的baseaddr low + length low。
现代操作系统（如Linux）在计算可用物理内存时通常只考虑类型为1的ARDS结构体。类型1表示可用的RAM，这是操作系统和应用程序可以使用的内存。如果作者计算的是整个内存大小（包含可用和不可用），那么与现代操作系统通常做法不符；如果作者计算的是可用内存大小，那么作者并没有考虑ARDS结构体的类型字段，并且方法错误。
所以作者是错的。正确做法应该是计算可用内存大小，这通过相加类型为1的ARDS结构体的lengthlow得到。并且还应该记录ARDS结构体类型字段为1所指示的可用内存区域的起始地址，这样后续内存分配机制才能算得上真正正确。

### 内存分页，虚拟内存

分段模型最大的缺点就是每个段大小不一，带来内存管理的困难。为了解决这一系列问题，必须先解除线性地址与物理地址一一对应的关系，通过实现某种映射关系，实现线性地址可以对应到所有的物理地址，这就引出了分页机制，即通过固定大小且比一般段更小的块管理来代替原有的段管理。而且正是由于分页机制的引入，原有CPU设计者所设想的那种分段机制就基本被弃用，如现代操作系统都用平坦模型，抛弃了原来的那种在内存中分段管理的思路。

分页机制的核心就是，将程序所要用的虚拟内存空间（也就是32位编程时给程序分配的空间）与实际用到的内存空间分离。将程序所要用到的虚拟内存空间，拆分成一个个固定大小的小块（虚拟的4K），与物理内存上的固定大小的小块建立映射关系。就是这样的一种分离，带来了内存管理的粒度更小（原有的段机制下段可能远比4K大得多）、粒度更标准（段大小不一，现在统一成了4K大小）、更灵活（将程序暂时用不到的小块不放入内存中，等用到了再从磁盘中调入）等优点。

### 分页机制

![分段机制和分页机制的区别图](/home/zhj/.config/Typora/typora-user-images/image-20240802195145498.png)

经过段部件处理后，保护模式的寻址空间是 4GB，这个寻址空间是指线性地址空间，它在逻辑上是连续的。分页机制的思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑 上连续的线性地址其对应的物理地址可以不连续。 

分页机制的作用有两方面：

- 将线性地址转换成物理地址。  
- 用大小相等的页代替大小不等的段。

![分页机制的作用示意图](/home/zhj/.config/Typora/typora-user-images/image-20240802195956143.png)

由于分页机制的基础是分段机制，所以为保证向前兼容，所以原有段机制得到的地址被重新命名为线性地址，需要经过页机制的处理得到物理地址，具体做法就是用段机制下得到的线性地址查询页表找到内存上的页。上图，表示得是进程的段，从线性地址空间到虚拟地址空间再到物理地址空间的过程，每个空间都是4GB，图上的 4GB 物理地址空间属于所有进程包括操作系统在内的共享资源，其中标注为已分配页的内存块被分配给了其他进程，当前进程只能使用未分配页。此转换过程对任意一个进程都是一样的，也就是说，每个进程都有自己的 4GB 虚拟空间，代码段和数据段在逻辑上被拆分成以页为单位的小内存块。这时的虚拟地址虚如其名，不能存放任何数据。接着操作系统开始为这些虚拟内存页分配真实的物理内存页，它查找物理内存中可用的页，然后在页表中登记这些物理页地址，这样就完成了虚拟页到物理页的映射，每个进程都以为自己独享 4GB 地址空间。

### 一级页表

如果采用线性地址和物理地址进行一一映射的关系，4GB的物理内存会有4G个页表项，32位的地址需要4字节来存储，那也就是需要4B * 4G = 16GB，直接得不偿失，分页机制本质上是将大小不同的大内存段拆分成大小相等的小内存块。所以我们需要在内存块数量和内存块大小之间取一个平衡值，即寻取一个合适的页尺寸。

![页尺寸的寻找和页表与物理内存关系示意图](/home/zhj/.config/Typora/typora-user-images/image-20240802202737226.png)

在一级页表中我们选择，高20位作为页表项的数目，低12位作为页尺寸的大小。即在一级页表中，有1M个页表项，页尺寸为 4KB。

### 二级页表

一级页表中最多可容纳 1M（1048576）个页表项，每个页表项是 4 字节，如果页表项全满的话， 便是 4MB 大小，一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB， 用户进程要占用低 3GB，每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。所以二级页表就此诞生。

![二级页表示意图](/home/zhj/.config/Typora/typora-user-images/image-20240802204014847.png)

二级页表地址转换原理是将 32 位虚拟地址拆分成高 10 位、中间 10 位、低 12 位三部分，它们 的作用是：高 10 位作为页表的索引，用于在页目录表中定位一个页目录项 PDE，页目录项中有页表物理地址， 也就是定位到了某个页表。中间 10 位作为物理页的索引，用于在页表内定位到某个页表项 PTE，页表项中有分 配的物理页地址，也就是定位到了某个物理页。低 12 位作为页内偏移量用于在已经定位到的物理页内寻址。

- 用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的 和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。 
- 用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址， 所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。 
- 虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PTE 的索引值，所以它们需要乘以 4。但低 12 位 就不是索引值啦，其表示的范围是 0～0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第 2 步 中得到的物理页地址，所得的和便是最终转换的物理地址

![二级页表虚拟地址到真实物理地址的转换示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803091834644.png)

![页目录项和页表项结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803092021345.png)

由于页目录项和页表项都存储的是物理页的真实地址，都是4KB的整数倍，所以只需要20位即可，剩下的12位作为属性位。

P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操 作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。 

RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。 

US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、 3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页， 该页只允许特权级别为 0、1、2 的程序可以访问。 

PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式， 表示该页不仅是普通内存，还是高速缓存。

PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。

Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。与段描述符中的 A 和 P 位相似。 

D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项仅针对页表项有效，并不会修改页目录项中的 D 位。

PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。

G,Global，意为全局位。为 0 表示不是全局页。若为全局页，该页将在高速 缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址，无需那三步骤转换。由于 TLB 容量比较小（一般 、速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。 

AVL，意为 Available 位，表示可用。

### 启动分页机制的三步骤

- 准备好页目录表及页表。

- 将页表地址写入控制寄存器 CR3。

  PDBR寄存器(控制寄存器CR3)

  ![PDBR寄存器结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803093839588.png)

  PCD 和 PWT 都与高速缓存有关，在这里置 0 即可。

- 寄存器 CR0 的 PG 位置 1。

  ![CRO配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726194054701.png)

  PG置1,即开启分页机制。

### 开启分页机制

![页目录表与页表的关系示意图和页目录表与页表内存布局示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803094710360.png)

这里我们选择 0x10000 作为第一个页目录项的起始地址。也就是留出低端 1MB 的大小为了存放 MBR Loader 以及操作系统内核。对于Linux系统来说，在用户进程 4GB 虚拟地址空间的 高 3GB 以上的部分划分给操作系统，0～3GB 是用户进程自己的虚拟空间。为了实现共享操作系统，让所有用户进程 3GB～4GB 的虚拟地址空间都指向同一个操作系统，只要保证所有用户进程虚拟地址空间 3GB～4GB 对应的页表项中所记录的物理页地址是相同就可以了。操作系统应该在虚拟地址 0xc0000000 以上， 高10 位是 0x300，即十进制的 768。这样虚拟地址 0xc0000000～0xc03fffff 之间的内存都指向的是低端 4MB 之内的物理地址，自然包括了操作系统所占的低 1MB 的物理内存，从而实现了操作系统高 3GB 以上的虚拟地址对应到了低端 1MB。

编写配置文件(yourPath/chapter5/b/boot/include/boot.inc)。

```asm
                                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2
PAGE_DIR_TABLE_POS equ 0x100000 
                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的单位为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中

                                                    ;---------------- 页表相关属性 -------------- 
PG_P equ 1b 
PG_RW_R equ 00b 
PG_RW_W equ 10b 
PG_US_S equ 000b 
PG_US_U equ 100b 
```

编写加载器(yourPath/chapther/b/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
                                                        
GDT_BASE:                                               ; 构建gdt及其内部的描述符
    dd 0x00000000 
	dd 0x00000000

CODE_DESC:  
    dd 0x0000FFFF 
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	                                    ; limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE
    GDT_LIMIT equ GDT_SIZE - 1 
    times 60 dq 0					                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 

    total_mem_bytes dd 0				                ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。
                                                        ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,
                                                        ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址	 
                                                        
    gdt_ptr dw GDT_LIMIT                                ; 定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	        dd  GDT_BASE

    ards_buf times 244 db 0                             ; 人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节
    ards_nr dw 0	

loader_start:
                                                        ; -------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------

    xor ebx, ebx		                                ; 第一次调用时，ebx值要为0
    mov edx, 0x534d4150	                                ; edx只赋值一次，循环体中不会改变
    mov di, ards_buf	                                ; ards结构缓冲区
.e820_mem_get_loop:	                                    ; 循环获取每个ARDS内存范围描述结构
    mov eax, 0x0000e820	                                ; 执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。
    mov ecx, 20		                                    ; ARDS地址范围描述符结构大小是20字节
    int 0x15
    add di, cx		                                    ; 使di增加20字节指向缓冲区中新的ARDS结构位置
    inc word [ards_nr]	                                ; 记录ARDS数量
    cmp ebx, 0		                                    ; 若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个
    jnz .e820_mem_get_loop

                                                        ; 在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。
    mov cx, [ards_nr]	                                ; 遍历每一个ARDS结构体,循环次数是ARDS的数量
    mov ebx, ards_buf 
    xor edx, edx		                                ; edx为最大的内存容量,在此先清0
.find_max_mem_area:	                                    ; 无须判断type是否为1,最大的内存块一定是可被使用
    mov eax, [ebx]	                                    ; base_add_low
    add eax, [ebx+8]	                                ; length_low
    add ebx, 20		                                    ; 指向缓冲区中下一个ARDS结构
    cmp edx, eax		                                ; 冒泡排序，找出最大,edx寄存器始终是最大的内存容量
    jge .next_ards 
    mov edx, eax                                        ; edx 为总内存大小
.next_ards:
    loop .find_max_mem_area 
    jmp .mem_get_ok 

                                                        ; ------ int 15h ax = E801h 获取内存大小，最大支持 4G ------ 
                                                        ; 返回后, ax cx 值一样,以 1KB 为单位，bx dx 值一样，以 64KB 为单位
                                                        ; 在 ax 和 cx 寄存器中为低 16MB，在 bx 和 dx 寄存器中为 16MB 到 4GB 
.e820_failed_so_try_e801:
    mov ax,0xe801 
    int 0x15 
    jc .e801_failed_so_try88                            ; 若当前 e801 方法失败，就尝试 0x88 方法

                                                        ; 1 先算出低 15MB 的内存
                                                        ; ax 和 cx 中是以 1KB 为单位的内存数量，将其转换为以 byte 为单位
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
    mul cx                                              ; 用 AX 寄存器中的值乘以 CX 的值，结果存入 DX:AX
    shl edx, 16                                         ; 将 EDX 中的值左移 16 位，结果存入 EDX
    and eax, 0x0000FFFF                                 ; 仅保留 EAX 的低 16 位，高 16 位清零
    or edx, eax                                         ; 将 EAX 的值合并到 EDX 的低 16 位
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
    mov esi, edx                                        ; 将 EDX 的值存入 ESI 寄存器
                                                        ; 先把低 15MB 的内存容量存入 esi 寄存器备份

                                                        ; 2 再将 16MB 以上的内存转换为 byte 为单位
                                                        ; 寄存器 bx 和 dx 中是以 64KB 为单位的内存数量
    xor eax,eax 
    mov ax,bx 
    mov ecx, 0x10000                                    ; 0x10000 十进制为 64KB 
    mul ecx                                             ; 32 位乘法，默认的被乘数是 eax，积为 64 位
                                                        ; 高 32 位存入 edx，低 32 位存入 eax 
    add esi,eax 
                                                        ; 由于此方法只能测出 4GB 以内的内存，故 32 位 eax 足够了
                                                        ; edx 肯定为 0，只加 eax 便可
    mov edx,esi                                         ; edx 为总内存大小
    jmp .mem_get_ok 

                                                        ; ----- int 15h     ah = 0x88 获取内存大小，只能获取 64MB 之内 ----- 
.e801_failed_so_try88: 
    mov ah, 0x88                                        ; 设置 AH 寄存器为 0x88，准备调用 BIOS 中断
    int 0x15                                            ; 调用 BIOS 中断 0x15，子功能 0x88，获取内存信息
    jc .error_hlt                                       ; 如果调用失败（进位标志被设置），跳转到 .error_hlt 标签

    and eax, 0x0000FFFF                                 ; 清除 EAX 的高 16 位，仅保留低 16 位
                                                        ; AX 存储的是以 1KB 为单位的内存容量
    
                                                        ; 16 位乘法，被乘数是 AX，积为 32 位。积的高 16 位在 DX 中，积的低 16 位在 AX 中
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
                                                        ; 用于将 AX 中的内存容量转换为字节
    
    mul cx                                              ; 进行乘法运算，AX * CX，结果为 32 位，高 16 位在 DX 中，低 16 位在 AX 中
    shl edx, 16                                         ; 将 DX 的值左移 16 位，结果存储在 EDX 中
    or edx, eax                                         ; 将 EAX 中的低 16 位值与 EDX 进行按位或操作，合并结果存储在 EDX 中
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
                                                        ; 因为 0x88 子功能只会返回 1MB 以上的内存，所以要加上 1MB


.mem_get_ok:
mov [total_mem_bytes], edx                              ; 将内存换为 byte 单位后存入 total_mem_bytes 处


                                                        ; -----------------   准备进入保护模式   ------------------------------------------
                                                        ; 1 打开A20
                                                        ; 2 加载gdt
                                                        ; 3 将cr0的pe位置1


                                                        ; -----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ; -----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ; -----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ; jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

                                                        
    .error_hlt:		                                    ; 出错则挂起
    hlt

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    call setup_page                                     ; 创建页目录表的函数,我们的页目录表必须放在1M开始的位置，所以必须在开启保护模式后运行
                                                        ; 要将描述符表地址及偏移量写入内存 gdt_ptr，一会儿用新地址重新加载
    sgdt [gdt_ptr]                                      ; 存储到原来 gdt 所有的位置
                                                        ; 以下两句是将gdt描述符中视频段描述符中的段基址+0xc0000000
    mov ebx, [gdt_ptr + 2]                              ; ebx中存着GDT_BASE
    or dword [ebx + 0x18 + 4], 0xc0000000               ; 视频段是第3个段描述符,每个描述符是8字节,故0x18 = 24，然后+4，是取出了视频段段描述符的高4字节。然后or操作，段基址最高位+c
                                            
    add dword [gdt_ptr + 2], 0xc0000000                 ; 将gdt的基址加上0xc0000000使其成为内核所在的高地址

    add esp, 0xc0000000                                 ; 将栈指针同样映射到内核地址

    mov eax, PAGE_DIR_TABLE_POS                         ; 把页目录地址赋给cr3
    mov cr3, eax
                                                        
    mov eax, cr0                                        ; 打开cr0的pg位(第31位)
    or eax, 0x80000000  
    mov cr0, eax
                                                        
    lgdt [gdt_ptr]                                      ; 在开启分页后,用gdt新的地址重新加载

    mov byte [gs:160], 'V'                              ; 视频段段基址已经被更新,用字符v表示virtual addr

    jmp $
    
                                                        
setup_page:                                             ; ------------------------------------------   创建页目录及页表  -------------------------------------
                                                        ; ----------------以下6行是将1M开始的4KB置为0，将页目录表初始化
    mov ecx, 4096                                       ; 创建4096个byte 0，循环4096次
    mov esi, 0                                          ; 用esi来作为偏移量寻址
.clear_page_dir:
    mov byte [PAGE_DIR_TABLE_POS + esi], 0				
    inc esi
    loop .clear_page_dir								; 执行一次 loop ， ecx 中的值 -1

                                                        ; ----------------初始化页目录表，让0号项与768号指向同一个页表，该页表管理从0开始4M的空间
.create_pde:				                            ; 一个页目录表项可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，这是为将地址映射为内核地址做准备
    mov eax, PAGE_DIR_TABLE_POS                         ; eax中存着页目录表的位置
    add eax, 0x1000 			                        ; 在页目录表位置的基础上+4K（页目录表的大小），现在eax中第一个页表的起始位置
    mov ebx, eax				                        ; 此处为ebx赋值，现在ebx存着第一个页表的起始位置
    or eax, PG_US_U | PG_RW_W | PG_P	                ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.
                                                        ; 现在eax中的值符合一个页目录项的要求了，高20位是一个指向第一个页表的4K整数倍地址，低12位是相关属性设置
    mov [PAGE_DIR_TABLE_POS + 0x0], eax                 ; 页目录表0号项写入第一个页表的位置(0x101000)及属性(7)
    mov [PAGE_DIR_TABLE_POS + 0xc00], eax               ; 页目录表768号项写入第一个页表的位置(0x101000)及属性(7)
					                                    
    sub eax, 0x1000                                     ; ----------------- 使最后一个目录项指向页目录表自己的地址，为的是将来动态操作页表做准备
    mov [PAGE_DIR_TABLE_POS + 4092], eax	            ; 属性包含PG_US_U是为了将来init进程（运行在用户空间）访问这个页目录表项
                                                        
    mov ecx, 256				                        ; -----------------初始化第一个页表，因为我们的操作系统不会超过1M，所以只用初始化256项
    mov esi, 0                                          ; esi来做寻址页表项的偏移量
    mov edx, PG_US_U | PG_RW_W | PG_P	                ; 属性为7,US=1,RW=1,P=1
.create_pte:				                            ; 创建Page Table Entry
    mov [ebx+esi*4],edx			                        ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 
    add edx,4096                                        ; edx指向下一个4kb空间，且已经设定好了属性，故edx中是一个完整指向下一个4kb物理空间的页表表项
    inc esi                                             ; 寻址页表项的偏移量+1
    loop .create_pte                                    ; 循环设定第一个页表的256项

                                                        ; -------------------初始化页目录表769号-1022号项，769号项指向第二个页表的地址（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推
    mov eax, PAGE_DIR_TABLE_POS                         ; eax存页目录表的起始位置
    add eax, 0x2000 		                            ; 此时eax为第二个页表的位置
    or eax, PG_US_U | PG_RW_W | PG_P                    ; 设置页目录表项相关属性，US,RW和P位都为1，现在eax中的值是一个完整的指向第二个页表的页目录表项
    mov ebx, PAGE_DIR_TABLE_POS                         ; ebx现在存着页目录表的起始位置
    mov ecx, 254			                            ; 要设置254个表项
    mov esi, 769                                        ; 要设置的页目录表项的偏移起始
.create_kernel_pde:
    mov [ebx+esi*4], eax                                ; 设置页目录表项
    inc esi                                             ; 增加要设置的页目录表项的偏移
    add eax, 0x1000                                     ; eax指向下一个页表的位置，由于之前设定了属性，所以eax是一个完整的指向下一个页表的页目录表项
    loop .create_kernel_pde                             ; 循环设定254个页目录表项
    ret
```

### 虚拟地址获取页表中各数据类型的方法

- 获取页目录表物理地址：让虚拟地址的高 20 位为 0xfffff，低 12 位为 0x000，即 0xfffff000，这也 是页目录表中第 0 个页目录项自身的物理地址。
- 访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为 0xfffffxxx，其中 xxx 是页目录 项的索引乘以 4 的积。
- 访问页表中的页表项：要使虚拟地址高 10 位为 0x3ff，目的是获取页目录表物理地址。中间 10 位为页表的索引，因为是 10 位的索引值，所以这里不用乘以 4。低 12 位为页表内的偏移地址，用来定位页表项，它必须是已经乘以 4 后的值。

### 快表 TLB

处理器准备了一个高速缓存，可以匹配高速的处理器速率和低速的内存访问速度，它专门用来存放虚拟地址页框与物理地址页框的映射关系，这个调整缓存就是 TLB。就是说可以直接用虚拟地址的低 12 位在该物理页框中寻址，大大提高了地址转换速度。

清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。 

![TLB简图](/home/zhj/.config/Typora/typora-user-images/image-20240803103637304.png)

## 加载内核

### ELF文件格式

程序中最重要的部分就是段和节。program header用于描述每个段的信息，section header用于描述每个节的信息。由于程序中段与节的大小和数量是不固定的，所以program header与section header的数量大小也是不固定的，因此需要为它们专门找个数据结构来描述它们，这个描述结构就是program header table与section header table。但是，多一个段，就多一个program header，program header table就会变大，所以program header table与section header table的大小也是不固定的，就又需要一个elf header来描述program header table与section header table。

下图是编译好的操作系统的elf文件头格式，我们要从elf header中取得program header table的信息，又从program header table中得到关于对每个段program header的信息，根据这个信息去确定每个段的大小，起始地址，在内存中的目的地址（都是虚拟地址）。

![ELF文件格式布局图](/home/zhj/.config/Typora/typora-user-images/image-20240803110916575.png)

本节中所说的目标文件即指各种类型符合 ELF 规范的文件。

![ELF眼中的目标文件示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803111114540.png)

ELF header结构如下：

![ELF header结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803111325885.png)

![ELF header数据类型表](/home/zhj/.config/Typora/typora-user-images/image-20240803111425597.png)

e_ident[16]是 16 字节大小的数组，用来表示 elf 字符等信息，开头的 4 个字节是固定不变的，是 elf 文件的魔数，它们分别是 0x7f，以及字符串 ELF 的 ASCII 码：0x45, 0x4c, 0x46。

![e_ident数组功能表](/home/zhj/.config/Typora/typora-user-images/image-20240803111558926.png)

e_type 占用 2 字节，是用来指定 elf 目标文件的类型。

![ELF目标文件类型表1](/home/zhj/.config/Typora/typora-user-images/image-20240803111823792.png)

![ELF目标文件类型表2](/home/zhj/.config/Typora/typora-user-images/image-20240803111916605.png)

e_machine 占用 2 字节，用来描述 elf 目标文件的体系结构类型，即文件要在哪种硬件平台上运行。

![e_machine示意表](/home/zhj/.config/Typora/typora-user-images/image-20240803112047924.png)

e_version 占用 4 字节，用来表示版本信息。 

e_entry 占用 4 字节，用来指明操作系统运行该程序时，将控制权转交到的虚拟地址。

e_phoff 占用 4 字节，用来指明程序头表（program header table）在文件内的字节偏移量。如果没有程序头表，该值为 0。

e_shoff 占用 4 字节，用来指明节头表（section header table）在文件内的字节偏移量。若没有节头表， 该值为 0。 

e_flags 占用 4 字节，用来指明与处理器相关的标志。

e_ehsize 占用 2 字节，用来指明 elf header 的字节大小。

e_phentsize 占用 2 字节，用来指明程序头表（program header table）中每个条目（entry）的字节大小， 即每个用来描述段信息的数据结构的字节大小，该结构是后面要介绍的 struct Elf32_Phdr。 

e_phnum 占用 2 字节，用来指明程序头表中条目的数量。实际上就是段的个数。 

e_shentsize 占用 2 字节，用来指明节头表（section header table）中每个条目（entry）的字节大小，即 每个用来描述节信息的数据结构的字节大小。

e_shnum 占用 2 字节，用来指明节头表中条目的数量。实际上就是节的个数。

e_shstrndx 占用 2 字节，用来指明 string name table 在节头表中的索引 index。

![描述段信息的数据结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803112420880.png)

Elf32_Phdr 和 Elf32_Ehdr 的关系就如同段描述符和GDT一样，段描述符用来描述物理内存中的一个内存段，而 struct Elf32_Phdr 是用来描述位于磁盘上的程序中的一个段，它被加载到内存后才属于 GDT 中段描述符所指向的内存段的子集。

p_type 占用 4 字节，用来指明程序中该段的类型。

![程序中的段类型示意表](/home/zhj/.config/Typora/typora-user-images/image-20240803113038908.png)

p_offset 占用 4 字节，用来指明本段在文件内的起始偏移字节。

p_vaddr 占用 4 字节，用来指明本段在内存中的起始虚拟地址。 

p_paddr 占用 4 字节，仅用于与物理地址相关的系统中，以此项暂且保留，未设定。

p_filesz 占用 4 字节，用来指明本段在文件中的大小。

p_memsz 占用 4 字节，用来指明本段在内存中的大小。

p_flags 占用 4 字节，用来指明与本段相关的标志。

![p_flags取值示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803113202926.png)

p_align 占用 4 字节，用来指明本段在文件和内存中的对齐方式。如果值为 0 或 1，则表示不对齐。否 则 p_align 应该是 2 的幂次数。

### 将内核载入内存

内核是由Loader加载至内存中的，Loader要获取物理内存，切换模式，打开分页机制以及加载并初始化内核。

- 获取物理内存：0x15 中断的三个子功能。
- 切换模式：从实模式切换至保护模式。
- 打开分页机制：虚拟内存的出现。

- 加载内核：需要把内核文件加载到内存缓冲区。 
- 初始化内核：需要在分页后，将加载进来的 elf 内核文件安置到相应的虚拟内存地址。

加载内核到内存中，得有个加载地址，也就是缓冲区。这个缓冲区便是前文提到的低端1MB的空间了。

![低端1MB空间分布图](/home/zhj/.config/Typora/typora-user-images/image-20240803114843243.png)

编写配置文件(yourPath/chapter5/c/boot/include/boot.inc)

```ASM
                                                    ; -------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2
PAGE_DIR_TABLE_POS equ 0x100000 
                                                    ; --------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ; 设置段界限的单位为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ; 设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ; 64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ; 此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ; 可以将这个位用于任何自定义的需求。
                                                    ; 比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ; 这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ; 定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ; 定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ; 定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ; 定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ; 定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ; 定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ; 定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ; 定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ; 无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ; 无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ; 将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ; x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ; x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ; 定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ; --------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ; 定义选择字的RPL为0
RPL1  equ   01b                                     ; 定义选择子的RPL为1
RPL2  equ   10b                                     ; 定义选择字的RPL为2
RPL3  equ   11b                                     ; 定义选择子的RPL为3
TI_GDT	 equ   000b                                 ; 定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ; 定义段选择子请求的段描述符是在LDT中

                                                    ; ---------------- 页表相关属性 -------------- 
PG_P equ 1b 
PG_RW_R equ 00b 
PG_RW_W equ 10b 
PG_US_S equ 000b 
PG_US_U equ 100b 

LOADER_STACK_TOP equ LOADER_BASE_ADDR               ; 这一条之前是在loader.S中定义，现在搬过来了

KERNEL_BIN_BASE_ADDR equ 0x70000                    ; 定义内核在内存中的缓冲区，也就是将编译好的内核文件暂时存储在内存中的位置
KERNEL_START_SECTOR equ 0x9                         ; 定义内核在磁盘的起始扇区
KERNEL_ENTER_ADDR equ 0xc0001500                    ; 定义内核可执行代码的入口地址

PT_NULL equ 0                                       ; -------------  程序段的 type 定义   --------------
                                                    ; 用于判断该段是否应该被加载
```

编写加载器(yourPath/chapter5/c/boot/loader.S)

```ASM
%include "boot.inc"
SECTION LOADER vstart=LOADER_BASE_ADDR    ; 同书上，设置为0x900
LOADER_STACK_TOP equ LOADER_BASE_ADDR     ; 初始化栈顶，0x900向下为栈空间
jmp loader_start

                                          ; 构建GDT及其内部的描述符
   GDT_BASE:   
   dd   0x00000000                        ; 没用的第0个段描述符
   dd   0x00000000

   CODE_DESC: 
   dd   0x0000FFFF
   dd   DESC_CODE_HIGH4

   DATA_STACK_DESE:   
   dd   0x0000FFFF
   dd   DESC_DATA_HIGH4
                                          
   VIDEO_DESC: 
   dd   0x80000007                        ; limit=(0xbffff-0xb8000)/4k=0x7
   dd   DESC_VIDEO_HIGH4                  ; 此时DPL为0
   
   GDT_SIZE    equ  $-GDT_BASE            ; 地址差作尺寸：当前行地址-GDT_BASE地址
   GDT_LIMIT   equ  GDT_SIZE-1

   times 59 dq 0                          ; dq 定义4字/8字节
   times 5 db 0

   total_mem_bytes dd 0                 
   SELECTOR_CODE   equ   (0x0001<<3)+TI_GDT+RPL0
                                          ; 相当于(CODE_DESC-GDT_BASE)/8+TI_GDT+RPL0
   SELECTOR_DATA   equ   (0x0002<<3)+TI_GDT+RPL0
   SELECTOR_VIDEO  equ   (0x0003<<3)+TI_GDT+RPL0

                                          ; 以下是GDT的指针GDTR,6B/48bit，前2字节是GDT界限，后4字节是GDT起始地址
   gdt_ptr     dw  GDT_LIMIT
               dd  GDT_BASE

   ards_buf times 244 db 0
   ards_nr dw 0

loader_start:
                                          ; int 15h eax=0000E820h, edx=534D4150h('SMAP'的ASCII码)获取内存布局
   xor ebx,ebx                            ; 第一次调用时，ebx要为0
   mov edx,0x534d4150                     ; edx只赋值一次，循环体中不会改变，用于签名校验
   mov di,ards_buf                        ; ards结构缓冲区

.e820_mem_get_loop:                       ; 循环获取每个ARDS内存范围描述结构
   mov eax,0x0000e820                     ; 执行int 0x15后，eax值变为0x534d4150，所以每次执行int前都要更新为子>功能号
   mov ecx,20                             ; ARDS地址范围描述符结构大小是20字节
   int 0x15                               ; 0x15为获取内存容量的中断号
   jc .e820_failed_so_try_e801            ; 若cf位为1则有错误发生，尝试0xe801子功能
   add di,cx                              ; 使di增加20字节指向缓冲区中新的ARDS结构位置
   inc word [ards_nr]                     ; 记录ARDS数量
   cmp ebx,0                              ; 若ebx为0且cf不为1，这说明ards全部返回，当前已是最后一个

   jnz .e820_mem_get_loop

                                          ; 在所有ards结构中找出(base_add_low+length_low)的最大值，即内存的容量
   mov cx,[ards_nr]                       ; 遍历每个ARDS结构体，循环次数是ARDS的数量
   mov ebx,ards_buf
   xor edx,edx                            ; 此后edx用于记录最大内存容量，在此先请0

.find_max_mem_area:                       ; 无需判断type是否为1，最大的内存块一定是可以被使用的
   mov eax,[ebx]                          ; base_add_low
   add eax,[ebx+8]                        ; length_low
   add ebx,20                             ; 指向缓冲区下一个ARDS结构
   cmp edx,eax                            ; 冒泡排序，找出最大，edx寄存器始终是最大的内存容量
   jge .next_ards
   mov edx,eax                            ; edx为总内存大小

.next_ards:
   loop .find_max_mem_area
   jmp .mem_get_ok

                                          ; ---------- int 15h ax=E801h 获取内存大小，最大支持4G ----------
                                          ; 返回后，ax cx值一样，以KB为单位，bx dx值一样，以64KB为单位
                                          ; 在ax和cx寄存器中为低16MB，在bx和dx寄存器中为16MB到4GB
.e820_failed_so_try_e801:
   mov ax,0xe801
   int 0x15
   jc .e801_failed_so_try88               ; 若当前e801方法也失败，则尝试0x88方法

                                          ; 1.先算出低15MB内存。ax cx是以KB为单位的内存数量，将其转换为以Byte为单位
   mov cx,0x400                           ; 0x400十进制为1K。cx和ax一样，cx用作乘数
   mul cx
   shl edx,16
   and eax,0x0000FFFF
   or edx,eax
   add edx,0x100000                       ; ax只是15MB，故要追加1MB
   mov esi,edx                            ; 先把低15MB内存容量存入esi寄存器备份

                                          ; 2.再将16MB以上的内存转换为Byte为单位。bx dx是以64KB为单位的内存数量
   xor eax,eax
   mov ax,bx
   mov ecx,0x10000                        ; 0x10000十进制为64KB
   mul ecx                                ; 32位乘法，默认的被乘数是eax，积为64位。高32位存入edx，低32位存入eax
   add esi,eax                            ; 4GB内存，edx为0，低32位足矣
   mov edx,esi                            ; edx为总内存大小
   jmp .mem_get_ok

                                          ; ------- int 15h ah=0x88获取内存大小，只能获取64MB之内 ---------
.e801_failed_so_try88:
                                          ; int 15h后，ax存入的是以KB为单位的内存容量
   mov ah,0x88
   int 0x15
   jc .error_hlt
   and eax,0x0000FFFF

                                          ; 16位乘法，被乘数是ax，积为32位。积的高16位在dx中，低16位在ax中
   mov cx,0x400
   mul cx
   shl edx,16                             ; 把edx移动高16位
   or edx,eax                             ; 把低16位组合到edx，即为32为积
   add edx,0x100000                       ; 0x88只会返回1MB以上的内存，故实际内存还要加上1MB

.error_hlt:
   jmp $

.mem_get_ok:
   mov [total_mem_bytes],edx              ; 将内存换位Byte单位后存入total_mem_bytes处

                                          ; --------------------- 准备进入保护模式 ------------------------
                                          ; 1 打开A20
                                          ; 2 加载GDT
                                          ; 3 将cr0的PE位置1

                                          ; --------------------------- 打开A20 ---------------------------
   in al,0x92
   or al,0000_0010B                       ; 简单说，将端口0x92的第1位置1即可
   out 0x92,al

                                          ; --------------------------- 加载GDT ---------------------------
   lgdt [gdt_ptr]                         ; load GDT [addr]

                                          ; -------------------------- cr0第0位置1 ------------------------
   mov eax,cr0
   or eax,0x00000001
   mov cr0,eax

   jmp dword SELECTOR_CODE:p_mode_start   ; 刷新流水线。因为要远转移，cs更新，所>以流水线上的其它指令都没用了，就会刷新

[bits 32]                                 ; 开启32位指令
p_mode_start:
   mov ax,SELECTOR_DATA
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov esp,LOADER_STACK_TOP

                                          ; -------------------------- 加载kernel ------------------------
   mov eax,KERNEL_START_SECTOR            ; kernel.bin所在扇区号
   mov ebx,KERNEL_BIN_BASE_ADDR           ; 从磁盘读出后，写入到ebx指定的地址
   mov ecx,200                            ; 读入的扇区数

   call rd_disk_m_32					  ; 用于从硬盘上读取文件 与 mbr.S 中的 rd_disk_m_16 相似，将16位寄存器修改为32位寄存即可

                                          ; -------------------------- 建立页表 --------------------------
                                          ; 创建页目录及页表并初始化页内存位图
   call setup_page

   sgdt [gdt_ptr]

   mov ebx,[gdt_ptr+2]

   or dword [ebx+0x18+4],0xc0000000
   add dword [gdt_ptr+2],0xc0000000

   add esp,0xc0000000

   mov eax,PAGE_DIR_TABLE_POS
   mov cr3,eax

   mov eax,cr0
   or eax,0x80000000
   mov cr0,eax

   lgdt [gdt_ptr]

   mov eax,SELECTOR_VIDEO
   mov gs,eax

   jmp SELECTOR_CODE:enter_kernel

                                          ; ---------------------- 跳转到kernel -----------------------
enter_kernel:
   call kernel_init
   mov esp,0xc009f000
   jmp KERNEL_ENTER_ADDR

                                          ; ------------------------ 创建页表 ------------------------
setup_page:
   mov ecx,4096
   mov esi,0
.clear_page_dir:
   mov byte [PAGE_DIR_TABLE_POS+esi],0
   inc esi
   loop .clear_page_dir

                                          ; 创建页目录项(PDE)
.create_pde:
   mov eax,PAGE_DIR_TABLE_POS
   add eax,0x1000                         ; 此时的eax为第一个页表的物理地址
   mov ebx,eax                            ; ebx=eax，为后续的.create_pte做准备，ebx为基址

                                          ; 下面将偏移地址0x0（第1个）和0xc00（第768个页目录项）存为第1个页表的地址，每个页表表示4MB内存
   or eax,PG_US_U|PG_RW_W|PG_P            ; 最低特权级|可读写|存在
   mov [PAGE_DIR_TABLE_POS+0x0],eax       ; 第1个页目录项
   mov [PAGE_DIR_TABLE_POS+0xc00],eax     ; 第768个页目录项
   sub eax,0x1000
   mov [PAGE_DIR_TABLE_POS+4092],eax      ; 最后一个页目录项指向页目录自己

                                          ; 创建页表项(PTE)
   mov ecx,256                            ; 对低端内存1MB建页表：1MB/4KB=256（256个页表项，1个页表足矣）
   mov esi,0
   mov edx,PG_US_U|PG_RW_W|PG_P           ; 最低特权第|可读写|存在
.create_pte:
   mov [ebx+esi*4],edx                    ; 逐个页表项设置
   add edx,4096                           ; 因为1个页表4KB，所以edx的基址+4KB
   inc esi
   loop .create_pte

                                          ; 创建内核其它页表的PDE
   mov eax,PAGE_DIR_TABLE_POS
   add eax,0x2000                         ; 此时的eax为第二个页表的物理地址
   or eax,PG_US_U|PG_RW_W|PG_P            ; 最低特权级|可读写|存在
   mov ebx,PAGE_DIR_TABLE_POS
   mov ecx,254
   mov esi,769
.create_kernel_pde:
   mov [ebx+esi*4],eax                   ; 将第2个~第256个页表的地址逐个存入页表项
   inc esi
   add eax,0x1000                        ; 下一个页表的地址
   loop .create_kernel_pde

   ret

                                          ; ------ 初始化内核 把缓冲区的内核代码放到0x1500区域 ------
kernel_init:
   xor eax,eax
   xor ebx,ebx                            ; ebx记录程序头表地址
   xor ecx,ecx                            ; cx记录程序头表中的program header数量
   xor edx,edx                            ; dx记录program header尺寸，即e_phentsize

   mov dx,[KERNEL_BIN_BASE_ADDR+42]       ; 偏移文件42字节处的属性是e_phentsize，表示program header大小
   mov ebx,[KERNEL_BIN_BASE_ADDR+28]      ; 偏移文件28字节处是e_phoff，表示第一个program>在文件中的偏移量
   add ebx,KERNEL_BIN_BASE_ADDR
   mov cx,[KERNEL_BIN_BASE_ADDR+44]       ; 偏移文件44字节处是e_phnum，表示有几个program header
.each_segment:
   cmp byte [ebx+0],PT_NULL               ; 若p_type等于PT_NULL，说明此program header未使用
   je .PTNULL

   mov eax,[ebx+8]
   mov esi,0xc0001500
   cmp eax,esi
   jb .PTNULL

                                          ; 为函数memcpy压入参数，参数是从右往左依次压入，函数原型类似于memcpy(dst,src,size)
   push dword [ebx+16]                    ; 偏移16字节的地方是p_filesz，压入函数memcpy的第三个参数：size
   mov eax,[ebx+4]                        ; 偏移4字节的位置是p_offset
   add eax,KERNEL_BIN_BASE_ADDR           ; 加上kernel.bin被加载到的物理地址，eax为该段的物理地址
   push eax                               ; 压入函数memcpy的第二个参数：src
   push dword [ebx+8]                     ; 压入函数memcpy的第三个参数：dst，偏移量为8字节的位置是p_vaddr
   call mem_cpy                           ; 调用memcpy完成段复制
   add esp,12                             ; 清理栈中压入的三个参数
.PTNULL:
   add ebx,edx                            ; edx为program header大小，即e_phentsize，ebx指向下一个program_header
   loop .each_segment
   ret

mem_cpy:
   cld
   push ebp
   mov ebp,esp
   push ecx                               ; rep指令需要ecx，但ecx还此时用于外循环中，所以先push保存一下
   mov edi,[ebp+8]
   mov esi,[ebp+12]
   mov ecx,[ebp+16]
   rep movsb                              ; 逐字节拷贝

                                          ; 恢复
   pop ecx
   pop ebp
   ret

                                          ; ------ rd_disk_m_32，类似于mbr.S中的rd_disk_m_16 ------
rd_disk_m_32:
                                          ; 1 写入待操作磁盘数
                                          ; 2 写入LBA 低24位寄存器 确认扇区
                                          ; 3 device 寄存器 第4位主次盘 第6位LBA模式 改为1
                                          ; 4 command 写指令
                                          ; 5 读取status状态寄存器 判断是否完成工作
                                          ; 6 完成工作 取出数据

                                          ; 1 写入待操作磁盘数
   mov esi,eax                            ; !!! 备份eax
   mov di,cx                              ; !!! 备份cx

   mov dx,0x1F2                           ; 0x1F2为Sector Count 端口号 送到dx寄存器中
   mov al,cl                              ; !!! 忘了只能由ax al传递数据
   out dx,al                              ; !!! 这里修改了 原out dx,cl

   mov eax,esi                            ; !!!原来备份是这个用 前面需要ax来传递数据 麻了

                                          ; 2 写入LBA 24位寄存器 确认扇区
   mov cl,0x8                             ; shr 右移8位 把24位给送到 LBA low mid high 寄存器中

   mov dx,0x1F3                           ; LBA low
   out dx,al

   mov dx,0x1F4                           ; LBA mid
   shr eax,cl                             ; eax为32位 ax为16位 eax的低位字节 右移8位即8~15
   out dx,al

   mov dx,0x1F5
   shr eax,cl
   out dx,al

                                          ; 3 device 寄存器 第4位主次盘 第6位LBA模式 改为1
                                          ; 24 25 26 27位 尽管我们知道ax只有2 但还是需要按规矩办事
                                          ; 把除了最后四位的其他位置设置成0
   shr eax,cl

   and al,0x0f
   or al,0xe0                             ; !!! 把第四-七位设置成0111 转换为LBA模式
   mov dx,0x1F6                           ; 参照硬盘控制器端口表 Device
   out dx,al

                                          ; 4 向Command写操作 Status和Command一个寄存器
   mov dx,0x1F7                           ; Status寄存器端口号
   mov ax,0x20                            ; 0x20是读命令
   out dx,al

                                          ; 5 向Status查看是否准备好惹
                                          ; 设置不断读取重复 如果不为1则一直循环
.not_ready:
   nop                                    ; !!! 空跳转指令 在循环中达到延时目的
   in al,dx                               ; 把寄存器中的信息返还出来
   and al,0x88                            ; !!! 0100 0100 0x88
   cmp al,0x08
   jne .not_ready                         ; !!! jump not equal == 0

                                          ; 6 读取数据
   mov ax,di                              ; 把 di 储存的cx 取出来
   mov dx,256
   mul dx                                 ; 与di 与 ax 做乘法 计算一共需要读多少次 方便作循环 低16位放ax 高16位放dx
   mov cx,ax                              ; loop 与 cx相匹配 cx-- 当cx == 0即跳出循环
   mov dx,0x1F0
.go_read_loop:
   in ax,dx                               ; 两字节dx 一次读两字
   mov [ebx],ax
   add ebx,2
   loop .go_read_loop
   ret
```

### 特权级

CPU总是在执行代码，代码总是处于某个段中，CS有自己的值，CS中的RPL位就是CPU当前的CPL。当这一段代码想要跳转到另一段代码中执行时，就需要加载另一段代码的选择子去GDT中查找对应的段描述符，段描述符中有被访问代码的DPL值，CPU就根据当前的CPL，与目的代码段的DPL做比较，来进行访问限制实现安全检查。理论上CPL<=DPL（数值）才能访问某个段，但实际上只允许平级访问。因为特权级低代码能做的事情，高特权级代码也能做。所以根本不会出现由特权级高代码切换到特权级低代码这种情况（除了中断返回）。而且特权级低代码肯定不能直接切换到特权级高的代码，自然就只能平级访问。但是仅仅依靠CPL与DPL是不够的，典型场景就是一个应用通过系统调用去操作操作系统的数据，在这种情况下是绝对不允许的。因此又引入了RPL，RPL是这个应用要加载的段描述符选择子的RPL位的值，比如刚刚那个场景，应用为了操作操作系统的数据，那么加载到ds中的段描述符选择子的RPL是0，但是应用此时的CPL是3，因此CPU就能通过CPL与RPL的差异来判断应用想要搞鬼，所以就会强行将加载到ds中的段描述符的选择子的RPL改为应用的CPL。

CPU的初始CPL是在保护模式开启时（只有保护模式开启时，才有特权级这一概念）初始化的。因为当我们BIOS加载MBR，MBR加载loader并执行时，需要用到一句jmp 0:loader_start，后面保护模式开启后，现在的CS值是全0（虽然这是个非法段描述符选择子），我们需要用jmp SLE_CODE:p_mode_start，来刷新流水线，CPU会将当前的CS（值为全0）当做一个段描述符选择子，其中的RPL是0，也就是CPU的CPL是0，然后将SLE_CODE作为选择子查段描述符，对应的段描述符（我们设置的）中的DPL为0，cpu允许跳转。然后跳转之后的段的CS值的RPL，又成为当前CPU的CPL，这样CPL就被初始化为0了。

一致性代码段能够实现低特权级访问高特权级，但不会改变CPU的CPL，cpu的CPL仍然以访问前的低特权级代码的RPL。所以一致性代码段的DPL实际上是访问特权级的上限。也就是DPL=1，那么CPL=1,2，3都可以访问（=0应该也可以访问，只是一般没必要）。

同样的逻辑可以用于eflags的IOPL位，与IO位图来实现应用对端口（硬件）操作的安全性检查。

### 函数调用约定

在高级语言中，参数压栈顺序问题和栈空间的清理工作，这两个问题是通过调用约定来解决的，调用约定就是调用方和被调用方就以上问题达 成一致解决方案的约定，双方按照这种约定合作就不会发生问题。

![调用约定简述表](/home/zhj/.config/Typora/typora-user-images/image-20240803151537528.png)

### 汇编语言和 C 语言混合编程

- 汇编语言和 C 语言可以互相调用。

- 在汇编代码中导出符号供外部引用是用的关键字 global，引用外部文件的符号是用的关键字 extern。 
- 在 C 代码中只要将符号定义为全局便可以被外部引用，引用外部符号时用 extern 声明即可。

### 实现自己的打印函数

通过对显存段操作，我们能够在屏幕上显示字符，通过与显卡寄存器打交道，我们可以获得光标位置，结合上述两个步骤能够实现我们平常见的那种在光标处显示字符，数字，字符串，然后光标向后移动的效果。光标位置需要与VGA寄存器（显卡的寄存器）中CRT Controller Registers组中索引号为0Eh与0Fh寄存器来打交道。

![VGA寄存器表](/home/zhj/.config/Typora/typora-user-images/image-20240803152616459.png)

![CRT控制器数据寄存器表](/home/zhj/.config/Typora/typora-user-images/image-20240803152759220.png)

编写数据类型声明(yourPath/chapter6/lib/stdint.h)

```C
#ifndef __LIB_STDINT_H 
#define __LIB_STDINT_H 
typedef signed char int8_t; 
typedef signed short int int16_t; 
typedef signed int int32_t; 
typedef signed long long int int64_t; 
typedef unsigned char uint8_t; 
typedef unsigned short int uint16_t; 
typedef unsigned int uint32_t; 
typedef unsigned long long int uint64_t; 
#endif
```

编写函数声明(yourPath/chapter6/lib/kernel/print.h)

```c
#ifndef __LIB_KERNEL_PRINT_H 
#define __LIB_KERNEL_PRINT_H 
#include "stdint.h" 
void put_char(uint8_t char_asci);
void put_str(char* message);
void put_int(uint32_t num);
#endif 
```

编写函数实现(yourPath/chapter6/lib/kernel/print.S)

```asm
TI_GDT equ  0                                               ; 从这里开始三步是在定义显存段段描述符的选择子
RPL0  equ   0
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0
section .data 
put_int_buffer dq 0 ; 定义 8 字节缓冲区用于数字到字符的转换

[bits 32]
section .text
                                                            ; --------------------------------------------
                                                            ; put_str 通过put_char来打印以0字符结尾的字符串
                                                            ; --------------------------------------------
                                                            ; 输入：栈中参数为打印的字符串
                                                            ; 输出：无

global put_str
put_str:
                                                            ; 由于本函数中只用到了ebx和ecx,只备份这两个寄存器
    push ebx
    push ecx
    xor ecx, ecx		                                    ; 准备用ecx存储参数,清空
    mov ebx, [esp + 12]	                                    ; 从栈中得到待打印的字符串地址 
.goon:
    mov cl, [ebx]                                           ; ebx是字符串的地址，对地址进行取地址操作，然后取出一字节的数据，就是取出了字符串的第一个字符
    cmp cl, 0		                                        ; 如果处理到了字符串尾,跳到结束处返回
    jz .str_over
    push ecx		                                        ; 为put_char函数传递参数
    call put_char
    add esp, 4		                                        ; 回收参数所占的栈空间
    inc ebx		                                            ; 使ebx指向下一个字符
    jmp .goon
.str_over:
    pop ecx
    pop ebx
    ret


[bits 32]                                                   ; 采用32位编译
section .text                                               ; 表明这是个代码段
                                                            ; ------------------------   put_char   -----------------------------
                                                            ; 功能描述:把栈中的1个字符写入光标所在处
                                                            ; -------------------------------------------------------------------   
global put_char                                             ; 将put_char导出为全局符号，这样其他文件也可以使用
put_char:
    pushad	                                                ; 备份32位寄存器环境
                                                                ; 需要保证gs中为正确的视频段选择子,为保险起见,每次打印时都为gs赋值
    mov ax, SELECTOR_VIDEO	                                ; 不能直接把立即数送入段寄存器
    mov gs, ax

                                                            ; ------  获取当前光标位置 ------
                                                            ; 先获得高8位
    mov dx, 0x03d4                                          ; 索引寄存器
    mov al, 0x0e	                                        ; 用于提供光标位置的高8位
    out dx, al
    mov dx, 0x03d5                                          ; 通过读写数据端口0x3d5来获得或设置光标位置 
    in al, dx	                                            ; 得到了光标位置的高8位
    mov ah, al

                                                            ; 再获取低8位
    mov dx, 0x03d4
    mov al, 0x0f
    out dx, al
    mov dx, 0x03d5 
    in al, dx                                                  
    mov bx, ax	                                            ; 现在bx中存的是光标的位置
                                                            ; 下面这行是在栈中获取待打印的字符
    mov ecx, [esp + 36]	                                    ; pushad压入4×8＝32字节,加上主调函数的返回地址4字节,故esp+36字节,现在ecx中是要打印的字符
    cmp cl, 0xd				                                ; 判断是否是CR(回车)0x0d
    jz .is_carriage_return
    cmp cl, 0xa                                             ; 判断是否是LF(换行)0x0a
    jz .is_line_feed

    cmp cl, 0x8				                                ; 判断是否是BS(backspace退格)的asc码8
    jz .is_backspace
    jmp .put_other	    

.is_backspace:		      
                                                            ; ------ backspace的一点说明 ------
                                                            ; 当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符
                                                            ; 但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处,
                                                            ; 这就显得好怪异,所以此处添加了空格或空字符0
    dec bx                                                  ; 光标位置-1, 以符合我们的常识认知, 即按下退格符, 光标回退
    shl bx,1                                                ; 光标的位置就转换成了对应字符的显存位置的偏移
    mov byte [gs:bx], 0x20		                            ; 将待删除的字节补为0或空格皆可, 0x20是空格符的ascii码值 
    inc bx                                                  ; bx+1, 指向这个字符的属性位置, 也就是设定背景色, 字符颜色
    mov byte [gs:bx], 0x07                                  ; 0x07, 就是黑底白字
    shr bx,1                                                ; bx虽然指向这个字符的颜色属性字节，但是除以2还是变回这个字符的光标位置
    jmp .set_cursor                                         ; 去设置光标位置, 这样光标位置才能真正在视觉上更新

 .put_other:
    shl bx, 1				                                ; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节
    mov [gs:bx], cl			                                ; ascii字符本身
    inc bx
    mov byte [gs:bx],0x07		                            ; 字符属性
    shr bx, 1				                                ; 恢复老的光标值
    inc bx				                                    ; 下一个光标值
    cmp bx, 2000		   
    jl .set_cursor			                                ; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值
					                                        ; 若超出屏幕字符数大小(2000)则换行处理
.is_line_feed:				                                ; 是换行符LF(\n)
.is_carriage_return:			                            ; 是回车符CR(\r)
					                                        ; 如果是CR(\r),只要把光标移到行首就行了。
    xor dx, dx				                                ; 要进行16位除法，高16位置会放在dx中，要先清零
    mov ax, bx				                                ; ax是被除数的低16位.
    mov si, 80				                                ; 用si寄存器来存储除数80 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，
    div si				                                    ; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。ax/80后，ax中存商，dx中存储的是余数,汇编除法https://blog.csdn.net/loovejava/article/details/7044242
    sub bx, dx				                                ; 光标值减去除80的余数便是取整
					                                        ; 以上4行处理\r的代码

 .is_carriage_return_end:		                            ; 回车符CR处理结束
    add bx, 80
    cmp bx, 2000
 .is_line_feed_end:			                                ; 若是LF(\n),将光标移+80便可。  
    jl .set_cursor

                                                            ; 屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充
.roll_screen:				                                ; 若超出屏幕大小，开始滚屏
    cld                                                     
    mov ecx, 960				                            ; 一共有2000-80=1920个字符要搬运,共1920*2=3840字节.一次搬4字节,共3840/4=960次 
    mov esi, 0xb80a0			                            ; 第1行行首
    mov edi, 0xb8000			                            ; 第0行行首
    rep movsd				                                ; rep movs word ptr es:[edi], word ptr ds:[esi] 简写为: rep movsw

                                                            ; 将最后一行填充为空白
    mov ebx, 3840			                                ; 最后一行首字符的第一个字节偏移= 1920 * 2
    mov ecx, 80				                                ; 一行是80字符(160字节),每次清空1字符(2字节),一行需要移动80次
 .cls:
    mov word [gs:ebx], 0x0720		                        ; 0x0720是黑底白字的空格键
    add ebx, 2
    loop .cls 
    mov bx,1920				                                ; 将光标值重置为1920,最后一行的首字符.

.set_cursor:   
					                                        ; 将光标设为bx值
                                                            ; ------ 1 先设置高8位 ------
    mov dx, 0x03d4			                                ; 索引寄存器
    mov al, 0x0e				                            ; 用于提供光标位置的高8位
    out dx, al
    mov dx, 0x03d5			                                ; 通过读写数据端口0x3d5来获得或设置光标位置 
    mov al, bh
    out dx, al

                                                            ; ------ 2 再设置低8位 ------
    mov dx, 0x03d4
    mov al, 0x0f
    out dx, al
    mov dx, 0x03d5 
    mov al, bl
    out dx, al
.put_char_done: 
    popad
    ret


[bits 32]
section .text
                                                            ; --------------------   将小端字节序的数字变成对应的ascii后，倒置   -----------------------
                                                            ; 输入：栈中参数为待打印的数字
                                                            ; 输出：在屏幕上打印16进制数字,并不会打印前缀0x,如打印10进制15时，只会直接打印f，不会是0xf
                                                            ; ------------------------------------------------------------------------------------------
global put_int
put_int:
    pushad
    mov ebp, esp
    mov eax, [ebp+4*9]		                                ; call的返回地址占4字节+pushad的8个4字节，现在eax中就是要显示的32位数值
    mov edx, eax                                            ; ebx中现在是要显示的32位数值
    mov edi, 7                                              ; 指定在put_int_buffer中初始的偏移量，也就是把栈中第一个字节取出放入buffer最后一个位置，第二个字节放入buff倒数第二个位置
    mov ecx, 8			                                    ; 32位数字中,16进制数字的位数是8个
    mov ebx, put_int_buffer                                 ; ebx现在存储的是buffer的起始地址

                                                            ; 将32位数字按照16进制的形式从低位到高位逐个处理,共处理8个16进制数字
.16based_4bits:			                                    ; 每4位二进制是16进制数字的1位,遍历每一位16进制数字
    and edx, 0x0000000F		                                ; 解析16进制数字的每一位。and与操作后,edx只有低4位有效
    cmp edx, 9			                                    ; 数字0～9和a~f需要分别处理成对应的字符
    jg .is_A2F 
    add edx, '0'			                                ; ascii码是8位大小。add求和操作后,edx低8位有效。
    jmp .store
.is_A2F:
    sub edx, 10			                                    ; A~F 减去10 所得到的差,再加上字符A的ascii码,便是A~F对应的ascii码
    add edx, 'A'

                                                            ; 将每一位数字转换成对应的字符后,按照类似“大端”的顺序存储到缓冲区put_int_buffer
                                                            ; 高位字符放在低地址,低位字符要放在高地址,这样和大端字节序类似,只不过咱们这里是字符序.
.store:
    mov [ebx+edi], dl		                                ; 此时dl中是数字对应的字符的ascii码
    dec edi                                                 ; edi是表示在buffer中存储的偏移，现在向前移动
    shr eax, 4                                              ; eax中是完整存储了这个32位数值，现在右移4位，处理下一个4位二进制表示的16进制数字
    mov edx, eax                                            ; 把eax中的值送入edx，让edx去处理
    loop .16based_4bits

                                                            ; 现在put_int_buffer中已全是字符,打印之前,
                                                            ; 把高位连续的字符去掉,比如把字符00000123变成123
.ready_to_print:
    inc edi			                                        ; 此时edi退减为-1(0xffffffff),加1使其为0
.skip_prefix_0:                                             ; 跳过前缀的连续多个0
    cmp edi,8			                                    ; 若已经比较第9个字符了，表示待打印的字符串为全0 
    je .full0 
                                                            ; 找出连续的0字符, edi做为非0的最高位字符的偏移
.go_on_skip:   
    mov cl, [put_int_buffer+edi]
    inc edi
    cmp cl, '0' 
    je .skip_prefix_0		                                ; 继续判断下一位字符是否为字符0(不是数字0)
    dec edi			                                        ; edi在上面的inc操作中指向了下一个字符,若当前字符不为'0',要恢复edi指向当前字符		       
    jmp .put_each_num

.full0:
    mov cl,'0'			                                    ; 输入的数字为全0时，则只打印0
.put_each_num:
    push ecx			                                    ; 此时cl中为可打印的字符
    call put_char
    add esp, 4
    inc edi			                                        ; 使edi指向下一个字符
    mov cl, [put_int_buffer+edi]	                        ; 获取下一个字符到cl寄存器
    cmp edi,8                                               ; 当edi=8时，虽然不会去打印，但是实际上已经越界访问缓冲区了
    jl .put_each_num
    popad
    ret
```

### 内联汇编

基本内联汇编

```c
asm [volatile] ("assembly code") 
```

assembly code 规则：

- 指令必须用双引号引起来，无论双引号中是一条指令或多条指令。
- 一对双引号不能跨行，如果跨行需要在结尾用反斜杠'\'转义。
- 指令之间用分号'；'、换行符'\n'或换行符加制表符'\n''\t'分隔。

扩展内联汇编

```c
asm [volatile] (“assembly code”:output : input : clobber/modify)
```

- 寄存器约束

  - a：表示寄存器 eax/ax/al  
  - b：表示寄存器 ebx/bx/bl  
  - c：表示寄存器 ecx/cx/cl  
  - d：表示寄存器 edx/dx/dl
  - D：表示寄存器 edi/di  
  - S：表示寄存器 esi/si  
  - q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx  
  - r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi  
  - g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中 
  - A：把 eax 和 edx 组合成 64 位整数 
  - f：表示浮点寄存器 
  - t：表示第 1 个浮点寄存器 
  - u：表示第 2 个浮点寄存器

- 内存约束

  - m：表示操作数可以使用任意一种内存形式。
  - o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含 offset_address 的格式。

- 立即数约束

  - i：表示操作数为整数立即数 
  - F：表示操作数为浮点数立即数 
  - I：表示操作数为 0～31 之间的立即数 
  - J：表示操作数为 0～63 之间的立即数 
  - N：表示操作数为 0～255 之间的立即数 
  - O：表示操作数为 0～32 之间的立即数 
  - X：表示操作数为任何类型立即数

- 通用约束

  0～9：此约束只用在 input 部分，但表示可与 output 和 input 中第 n 个操作数用相同的寄存器或内存。

- 序号占位符

  序号占位符是对在 output 和 input 中的操作数，按照它们从左到右出现的次序从 0 开始编号，一直到 9，也就是说最多支持 10 个序号占位符。 操作数用在 assembly code 中，引用它的格式是%0～9。

- 名称占位符

  名称占位序需要在 output 和 input 中把操作数显式地起个名字，它用这样的格式来标识操作数： [名称]”约束名”（C 变量） 这样，该约束对应的汇编操作数便有了名字，在 assembly code 中引用操作数时，采用%[名称]的形式就可以了。

扩展内联汇编之机器模式

- 机器模式用来在机器层面上指定数据的大小及格式。

- 机器模式是用枚举类型 enum machine_mode 来定义的。

  ![机器模式的枚举定义图](/home/zhj/.config/Typora/typora-user-images/image-20240803160534752.png)

- 机器模式名称的结构大致是这样的：数据大小+数据类型+mode。

  ![整型机器模式示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803160613073.png)
