# 操作系统真象还原杂记

## 杂记

### 硬件的输入输出模式

硬件在输入输出上大体分为串行和并行 相应的接口也就是串行接口和并行接口。 串行硬件通过串行 接口与 CPU通信, 反过来也是， CPU通过串行接口与串行设备数据传输。 并行设备的访问类似, 只不过 是通过并行接口迸行的。

### 访问硬件的俩种方式

- **内存映射**：将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中, 这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。

- **IO接口**：外设是通过 IO 接口与 CPU 通信的, CPU访问外设， 就是i方问 IO 接口， 由 IO接口将信息传递 给另一端的外设。访问IO接口是通过端口进行的，端口是指IO接口上的一部分寄存器。

### 用户态与内核态是对 CPU来讲的,

是指 CPU 运行在用户态 (特权3级) 还是内核态 (特权0级）

### 内存分段

使用绝地物理地址的话，如果编译出俩个相同地址的用户程序，那么只能运行一个，所以采用内存分段，即通过段基址+段内偏移地址来访问内存，首先这样可以实现程序的重定位，重定位是指将程序中的指令的地址改写为另外一个地址，但是该地址指向的内容和原地址的而内容相同，其次这样可以通过改变段基址所指向的位置来实现访问内存的任意部分。

### 平坦模型和多段模型

平坦模型是相对于多端模型来说的，多个小段再加上不断换段基址的方式访问内存过于迂回繁琐，比如在实模式下, 访问超过 64KB 的内存 需要重新指定不同的段基址'通过这种迂回变通的方式才能达到目的 在保护模式下， 由于其是 32 位的， 寻址范围便能够达到4GB， 段内偏移地址也是地址， 所以也是 32 位。 可见， 在32 位环境下用一个段就能够访问到硬件所支持的所有内存。 也就是说， 段的大小可以是地址总线能够到达 的范围 

### 段寄存器(sreg)

- **CS**：代码段
- **DS**：数据段
- **ES FS GS**：附加段
- **SS**：堆栈段

由于CPU有俩种工作模式，即**实模式**和**保护模式**，在实模式下， CS、 DS、 ES、 SS 中〈的值为段基址， 是具体的物理地址， 内存单元的逻辑地址仍为 “段基值:段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址,而是“段选择子″(Sdector)， 当然， 选择子也是数值， 其依然为16位宽度。`

### Section和Segement

-  section称为节， 是指在汇编源码中经由关键字 section或segment修饰、 逻辑划分的指令或数据区域, 汇编器会将这两个关键字修饰的区域在目标文邗牛中编译成节， 也就是说 “节” 最初诞生于目标文件中。

-  segment 称为段， 是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合, 这个集合 称为 segment, 也就是段， 链接器把目标文件链接成可执行文件， 因此段最终诞生于可执行文件中。 我们 平时所说的可执行程序内存空间中的代码段和数据段就是指的 segment。

### 魔数

操作系统通过魔数实现按区分文件系统。

### 控制CPU的下一条指令

对于x86来说，程序计数器PC(PC只是一个概念，它的有多种实现方式)，是由CS:IP共同控制的，所以我们不能通过mov来修改其值。

对于ARM来说，是可以直接通过mov修改其PC的值的。

### 指令集和微架构

指令集(CISC RISC)是具体的一套指令编码, 微架构是指令集的物理实现方式。

### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

- 物理地址：物理上在内存中的位置，实际的地址。
- 逻辑地址/有效地址：无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。
- 线性地址：在保护模式下，“段基址+段内偏移地址”称为线性地址，不过此时的段基址不在是真正的地址，而是选择字。
- 虚拟地址：线性地址在开启地址分页功能下为被称为虚拟地址。

### 段重叠

![段重叠](/home/zhj/.config/Typora/typora-user-images/image-20240725194616289.png)

CPU 的内存寻址方式是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存。 它并不要求一个内存地址只隶属于某一个段，所以段重叠是科学的。

### 大小端序

- 小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址。因为低位在低字节，强制转换数据型时不需要再调整字节了。

- 大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字 节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。

### BIOS 中断、DOS 中断、Linux 中断的区别

BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt  Vector Table，IVT）中的。它们都是通过软中断指令 int 中断号来调用的。

中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理例程（程序）的段基址和 段内偏移地址。因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序。

- BIOS中断：提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。
- DOS中断：只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程。通过先往 ah 寄存器中写好子功能号，再执行 int 0x21。 这时在中断向量表中第 0x21 个表项，即物理地址 0x21*4 处中的中断处理程序开始根据寄存器 ah 中的值来调用相应的子功能
- Linux中断： Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。如果在实模式下执行 int 指令，会自动去访问 中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。

### 库函数是用户进程与内核的桥梁

- 操作系统有自己支持、加载用户进程的规则，而 C 运行时库是针对此操作系统的规则，为了让用户程序开发更加容易，用来支持用户进程的代码库。、
- 用户进程要与 C 运行时库的诸多目标文件链接后合并成一个可执行文件，也就是说我们的用户进程被加进了大量的运行库中的代码。
- C 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工 作，所以即使不包含标准库文件，链接阶段也要用到 C 运行时库。
- 用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整，后面章节会有详解。 
- 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效。

## 主引导记录 MBR

### MBR、EBR、DBR 和 OBR 各是什么

- MBR 是主引导记录：0盘0道1扇区(CHS方式) 0盘0道0扇区(LBA方式)
- 446 字节的引导程序及参数；
  - 64 字节的分区表；
- 2 字节结束标记 0x55 和 0xaa。

- EBR是为扩展分区存储分区表的扇区
- DBR是DOS 操作系统的引导记录(程序)：
  - 跳转指令，使 MBR 跳转到引导代码；
  - 厂商信息、DOS 版本信息； 
  - BIOS 参数块 BPB，即 BIOS Parameter Block；
  - 操作系统引导程序；
  - 结束标记 0x55 和 0xaa。
- OBR是操作系统引导记录：在 OBR 扇区的前 3 个字节存放了跳转指令，因此 MBR 找到活动分区后，就大胆主动跳到活动分区 OBR 引导扇区的起始处，该起始处的跳 转指令马上将处理器带入操作系统引导程序。

![MBR OBR EBR的位置关系图](/home/zhj/.config/Typora/typora-user-images/image-20240726102324443.png)

### 计算机的启动过程

理解从 BIOS 到 MBR 到 Boot Loader 到 OS Boot Record（OBR）的启动过程：

1. **BIOS/UEFI**：
   - 计算机加电后，首先由 BIOS（基本输入输出系统）或者现代计算机上的 UEFI（统一扩展固件接口）控制启动。BIOS/UEFI负责硬件初始化、执行加电自检（POST）以及检测和初始化关键硬件设备如内存、CPU等。

2. **MBR（主引导记录）**：
   - BIOS/UEFI完成初始化后，会读取启动设备（通常是硬盘）的第一个扇区，即主引导记录（MBR）。MBR是一个特定的引导扇区，其中包含了引导加载程序（Boot Loader）的信息和位置。

3. **Boot Loader**：
   - MBR中存储的引导加载程序会被加载到内存中执行。引导加载程序的主要作用是加载操作系统的核心部分到内存中，并将控制权传递给操作系统的启动文件（如Windows的NTLDR或GRUB引导加载程序）。

4. **OS Boot Record（操作系统启动记录）**：
   - 引导加载程序加载操作系统的核心文件后，会继续加载操作系统的启动记录（OBR）。这是操作系统在磁盘上的特定扇区或分区，包含了操作系统启动所需的信息和配置。OBR的内容会进一步指导操作系统完成初始化和加载。

5. **操作系统加载**：
   - 最终，引导加载程序会将控制权传递给操作系统内核，操作系统开始初始化各种系统服务和用户界面，完成整个启动过程并显示登录屏幕或桌面环境。

这些步骤构成了从计算机加电到操作系统启动的完整过程，每个步骤都是确保计算机能够正常运行和准备好用户操作的重要环节。

### 地址总线和物理内存的关系 

在计算机中，并不是只有咱们插在主板上的内存条需要通过地址总线访问， 还有一些外设同样是需要通过地址总线来访问的，这类设备还很多呢。若把全部的地址总线都指向物理内 存，那其他设备该如何访问呢？由于这个原因，只好在地址总线上提前预留出来一些地址空间给这些外设 用，这片连续的地址给显存，这片连续的地址给硬盘控制器等。留够了以后，地址总线上其余的可用地址 再指向 DRAM，也就是指插在主板上的内存条、我们眼中的物理内存。

![地址映射关系图](/home/zhj/.config/Typora/typora-user-images/image-20240726104001483.png)

### 深入理解BIOS

![实模式下的 1MB 内存布局图](/home/zhj/.config/Typora/typora-user-images/image-20240726104530376.png)

在8086计算机开机时，CPU的cs:ip寄存器被强制初试化为0xF000:0xFFF0，在实模式下由于CPU访问的内存是段地址+偏移地址的方式来实现的，所以0xF000:0xFFF0，访问的地址是0xF000*16+0xFFF0=0xFFFF0。

0xFFFF0这个地址存放着一条指令，该指令内容是跳转至BIOS程序的入口（该指令由跳转指令与BIOS程序的入口地址组成，共16B)。BIOS有四个主要功能：1、硬件自检；2、建立一些需要用到的数据结构与中断向量表；3、校验启动盘中位于0盘0道1扇区（其实就是0扇区，只不过CHS方法用1开头）的内容，校验这里是不是放着主引导记录MBR，校验方法是检测这个扇区最后两个字节是不是0x55与0xaa（所以我们编写的主引导记录MBR最后两个字节应该是这两个）；4、在3的基础上是，那么就将该扇区内容加载至0x7c00内存处，这个位置是由于历史遗留导致的兼容，由最初的操作系统本身所占内存大小与布局所决定（书p58）。加载完毕后，然后跳转过去执行。

MBR的任务就是加载Loader，由loader加载操作系统到指定位置，然后执行加载过来的操作系统。MBR大小必须是512字节，这是为了占满硬盘0盘0道1扇区，且最最后两个字节必须是0x55与0xaa。

编写MBR(主引导记录)(yourPath/chapter2/a/boot/mbr.S)。

```ASM
                                ;主引导程序 
                                ;------------------------------------------------------------
SECTION MBR vstart=0x7c00       ;编译起始地址为0x7c00
    mov ax,cs                   ;此时cs寄存器为0，自然可以用来将ax寄存器置0
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00

                                ; 清屏 利用0x06号功能，上卷全部行，则可清屏。
                                ; -----------------------------------------------------------
                                ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                ;------------------------------------------------------
                                ;输入：
                                ;AH 功能号= 0x06
                                ;AL = 上卷的行数(如果为0,表示全部)
                                ;BH = 上卷行属性
                                ;(CL,CH) = 窗口左上角的(X,Y)位置
                                ;(DL,DH) = 窗口右下角的(X,Y)位置
                                ;无返回值：
    mov ax, 0x600               ;ah中输入功能号
    mov bx, 0x700               ;设置上卷行属性，0x70表示用黑底白字的属性填充空白行
    mov cx, 0                   ;左上角: (0, 0)
    mov dx, 0x184f	            ;右下角: (80,25),
			                    ;VGA文本模式中,一行只能容纳80个字符,共25行。
			                    ;下标从0开始,所以0x18=24,0x4f=79
    int 0x10                    ;int 0x10

                                ;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;
    mov ah, 3		            ;输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0		            ;bh寄存器存储的是待获取光标的页号

    int 0x10		            ;输出: ch=光标开始行,cl=光标结束行
		    	                ;dh=光标所在行号,dl=光标所在列号

                                ;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

                                ;;;;;;;;;     打印字符串    ;;;;;;;;;;;
                                ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message 
    mov bp, ax		            ; es:bp 为串首地址, es此时同cs一致，
			                    ; 开头时已经为sreg初始化

                                ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
    mov cx, 5		            ; cx 为串长度,不包括结束符0的字符个数
    mov ax, 0x1301	            ; 子功能号13是显示字符及属性,要存入ah寄存器,
			                    ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动
    mov bx, 0x2		            ; bh存储要显示的页号,此处是第0页,
			                    ; bl中是字符属性, 属性黑底绿字(bl = 02h,07是黑底白字)
    int 0x10		            ; 执行BIOS 0x10 号中断
                                ;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;

    jmp $		                ; 使程序悬停在此

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55,0xaa
```

$和$$是编译器 NASM 预留的关键字，用来表示当前行和本 section 的地址，起到了标号的作用，它 是 NASM 提供的，并不是 CPU 原生支持的，相当于伪指令一样，对 CPU 来说是假的。

### IO接口

CPU是通过内存映射或者IO接口来访问硬件的，这里我们主要看IO接口。IO 接口是连接 CPU 与外部设备的逻辑控制部件，既然称为逻辑，就说明可分为硬件和软件两部分。 硬件部分所做的都是一些实质具体的工作，其功能是协调 CPU 和外设之间的种种不匹配，如双方由于速 度不匹配，那 IO 接口就实现数据缓冲以减少等待时间，数据格式不匹配，IO 接口就在这两种格式间互相 转换。IO 接口内部实际上也是由软件来控制运作的，这就是所谓的“逻辑”部分，所以软件是指用来控 制接口电路工作的驱动程序以及完成内部数据传输所需要的程序。IO接口有以下功能：

- 设置数据缓冲，解决 CPU 与外设的速度不匹配；
- 设置信号电平转换电路；
- 设置数据格式转换；
- 设置时序控制电路来同步 CPU 和外部设备；
- 提供地址译码。

### 显卡、显存和显示器

显存是由显卡提供的，它是位于显卡内部的一块内存，所以它称为显存。有的显卡制品上标注的DDR 512M或者DDR2 1G。这指的就是显存大小。显卡的工作就是不断地读取这块内存，随后将其内容发送到显示器。

![显存地址分布表](/home/zhj/.config/Typora/typora-user-images/image-20240726113248070.png)

![字符属性表](/home/zhj/.config/Typora/typora-user-images/image-20240726113534939.png)

![RGB的配位颜色表](/home/zhj/.config/Typora/typora-user-images/image-20240726113735193.png)

### 完善MBR

之前，我们是通过BIOS中断来实现打印字符串。现在，我们尝试绕过BIOS来直接来显示字符。这是为了应对进入保护模式后不能使用BIOS。

能这样的原理是因为显卡的内存已经编排到了CPU能够寻址的范围之内，当CPU操作这部分“内存”时，实际上是直接在和显卡打交道。显卡拿到了数据处理之后，显示器最终会按照要求显示这些数据。

完善MBR，使其可以直接操作显卡(yourPath/chapter3/a/boot/mbr.S)。

```ASM
                                        ;主引导程序 
                                        ;
                                        ;LOADER_BASE_ADDR equ 0xA000 
                                        ;LOADER_START_SECTOR equ 0x2
                                        ;------------------------------------------------------------
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

                                        ; 清屏
                                        ;利用0x06号功能，上卷全部行，则可清屏。
                                        ; -----------------------------------------------------------
                                        ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                        ;------------------------------------------------------
                                        ;输入：
                                        ;AH 功能号= 0x06
                                        ;AL = 上卷的行数(如果为0,表示全部)
                                        ;BH = 上卷行属性
                                        ;(CL,CH) = 窗口左上角的(X,Y)位置
                                        ;(DL,DH) = 窗口右下角的(X,Y)位置
                                        ;无返回值：
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                           ; 左上角: (0, 0)
    mov dx, 184fh	                    ; 右下角: (80,25),
			                            ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
			                            ; 下标从0开始，所以0x18=24,0x4f=79
    int 10h                             ; int 10h

                                        ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
    mov byte [gs:0x00],'1'				; gs为数据段基址 低8位字符的ASII码或者字符本身 高8位为显示设置
    mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色 0xA4即0x10100100

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4   

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4

    jmp $		                        ; 通过死循环使程序悬停在此

    times 510-($-$$) db 0
    db 0x55,0xaa
```

### 硬盘

针对于硬盘的IO接口，被称为硬盘控制器，硬盘控制器同硬盘的关系，如同显卡和显示器一样，它们都是专门驱动外部设备的模块电路。

![硬盘控制器端口寄存器表](/home/zhj/.config/Typora/typora-user-images/image-20240726145423010.png)

端口可以被分为两组，Command Block registers 和 Control Block registers。Command Block registers 用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers 用于控制硬盘工作 状态。

逻辑块地址LBA(Logical Block Address)：不考虑扇区所在的物理结构，磁盘中扇区从 0 开 始依次递增编号，这是一 种逻辑上为扇区编址的方法。LBA分为俩种：

- LBA28：用 28 位比特来描述一个扇区的地址。最大寻址范围是 2 的 28 次方等 于 268435456 个扇区，每个扇区是 512 字节，最大支持 128GB，这里我们采用LBA28。
- LBA48：用 48 位比特来描述一个扇区的地址，最大可寻址范围是 2 的 48 次方， 等于 281474976710656 个扇区，乘以 512 字节后，最大支持 131072TB，即 128PB。

| 端口号(寄存器名)             | 功能                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 0x1F0 / 0x170 Data寄存器     | 管理数据                                                     |
| 0x1F1 / 0x171                | 读硬盘失败时，记录失败的信息，为Error寄存器<br />写硬盘时，为Features寄存器 |
| 0x1F2 / 0x172 Sector寄存器   | 指定待读取或待写入的扇区数                                   |
| 0x1F3 / 0x173 LBA low寄存器  | LBA28的0-7位                                                 |
| 0x1F4 / 0x174 LBA mid寄存器  | LBA28的8-15位                                                |
| 0x1F5 / 0x175 LBA high寄存器 | LBA28的16-23位                                               |
| 0x1F6 / 0x176 Device寄存器   | 低四位存放LBA28的24-27位<br />第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代 表从盘<br />第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式<br />第 5 位和第 7 位是固定为 1 的，称为 MBS 位 |
| 0x1F7 / 0x177                | 读硬盘时，为Status寄存器，给出硬盘的 状态信息<br />写硬盘时，为Command寄存器， |

![Device寄存器和Status寄存器详细位图](/home/zhj/.config/Typora/typora-user-images/image-20240726151836453.png)

### 一般的数据传送方式 

- 无条件传送方式
- 查询传送方式
- 中断传送方式
- 直接存储器存取方式（DMA）
- I/O 处理机传送方式。

硬盘不符合第 1 种方法，因为它需要在某种条件下才能传输。第 4 种和第 5 种需要单独的硬件支持，在Bochs中，我们用了第 2、3 这两种软件传输方式。

### 更完善MBR

我们的 MBR 受限于 512 字节大小的，在那么小的空间中，没法为内核准备好环境，更没法将内核成功加载到内存并运行。所以我们要在另一个程序中完成初始化环境及加载内核的任务，这个程序我们称之为 Loader，即加载器。问题来了，Loader 在哪里？如何跳过去执行？这就是新 款 MBR 的使命，简而言之就是负责从硬盘上把 Loader 加载到内存，

操作磁盘的步骤

![磁盘操作的步骤图](/home/zhj/.config/Typora/typora-user-images/image-20240726152925238.png)

操作端口的方法

![端口操作的方法指令图](/home/zhj/.config/Typora/typora-user-images/image-20240726153247554.png)

完善MBR，使其可以加载Loader(yourPath/chapter3/b/boot/mbr.S)。

```ASM
                                    ;主引导程序 
                                    ;------------------------------------------------------------
%include "boot.inc"
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

                                    ; 清屏
                                    ;利用0x06号功能，上卷全部行，则可清屏。
                                    ; -----------------------------------------------------------
                                    ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                    ;------------------------------------------------------
                                    ;输入：
                                    ;AH 功能号= 0x06
                                    ;AL = 上卷的行数(如果为0,表示全部)
                                    ;BH = 上卷行属性
                                    ;(CL,CH) = 窗口左上角的(X,Y)位置
                                    ;(DL,DH) = 窗口右下角的(X,Y)位置
                                    ;无返回值：
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                       ; 左上角: (0, 0)
    mov dx, 184fh		            ; 右下角: (80,25),
				                    ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
				                    ; 下标从0开始，所以0x18=24,0x4f=79
    int 10h                         ; int 10h

                                    ; 输出字符串:MBR
    mov byte [gs:0x00],'1'
    mov byte [gs:0x01],0xA4

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4	        ;A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4
	 
    mov eax,LOADER_START_SECTOR	    ; 起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 写入的地址
    mov cx,1			            ; 待读入的扇区数
    call rd_disk_m_16		        ; 以下读取程序的起始部分（一个扇区）
  
    jmp LOADER_BASE_ADDR
       
                                    ;-------------------------------------------------------------------------------
                                    ;功能:读取硬盘n个扇区
rd_disk_m_16:	   
                                    ;-------------------------------------------------------------------------------
				                    ; eax=LBA扇区号
				                    ; ebx=将数据写入的内存地址
				                    ; ecx=读入的扇区数
    mov esi,eax	                    ;备份eax
    mov di,cx		                ;备份cx
                                    ;读写硬盘:
                                    ;第1步：选择特定通道的寄存器，设置要读取的扇区数
    mov dx,0x1f2
    mov al,cl
    out dx,al                       ;读取的扇区数

    mov eax,esi	                    ;恢复ax

                                    ;第2步：在特定通道寄存器中放入要读取扇区的地址，将LBA地址存入0x1f3 ~ 0x1f6
                                    ;LBA地址7~0位写入端口0x1f3
    mov dx,0x1f3                       
    out dx,al                          

                                    ;LBA地址15~8位写入端口0x1f4
    mov cl,8
    shr eax,cl
    mov dx,0x1f4
    out dx,al

                                    ;LBA地址23~16位写入端口0x1f5
    shr eax,cl
    mov dx,0x1f5
    out dx,al

    shr eax,cl
    and al,0x0f	                    ;lba第24~27位
    or al,0xe0	                    ; 设置7～4位为1110,表示lba模式
    mov dx,0x1f6
    out dx,al

                                    ;第3步：向0x1f7端口写入读命令，0x20 
    mov dx,0x1f7
    mov al,0x20                        
    out dx,al

                                    ;第4步：检测硬盘状态
.not_ready:
                                    ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
    nop
    in al,dx
    and al,0x88	                    ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
    cmp al,0x08
    jnz .not_ready	                ;若未准备好，继续等。

                                    ;第5步：从0x1f0端口读数据
    mov ax, di                      ;di当中存储的是要读取的扇区数
    mov dx, 256                     ;每个扇区512字节，一次读取两个字节，所以一个扇区就要读取256次，与扇区数相乘，就等得到总读取次数
    mul dx                          ;8位乘法与16位乘法知识查看书p133,注意：16位乘法会改变dx的值！！！！
    mov cx, ax	                    ; 得到了要读取的总次数，然后将这个数字放入cx中
    mov dx, 0x1f0
.go_on_read:
    in ax,dx
    mov [bx],ax
    add bx,2		  
    loop .go_on_read
    ret

    times 510-($-$$) db 0
    db 0x55,0xaa
```

编写Loader，Loader 是要经过实模式到保护模 式的过渡，并最终在保护模式下加载内核，这只是一个简单而Loader程序(yourPath/chapter3/b/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR

                                    ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		                        ; 通过死循环使程序悬停在此
```

编写配置文件boot.inc，之后的配置信息都将写在这(yourPath/chapter3/b/boot/include/boot.inc)。

```ASM
                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900          ;定义了 loader 在内存中的位置
LOADER_START_SECTOR equ 0x2         ;定义了 loader 在硬盘上的逻辑扇区地址，即 LBA 地址
```

## 保护模式

### 初识保护模式

CPU实模式有诸多不足：

- 实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。 
- 用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地指哪打哪。 
- 用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。 
- 访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎。 
- 一次只能运行一个程序，无法充分利用计算机资源。 
- 共 20 条地址线，最大可用内存为 1MB。

其中最致命的有两条：1、仅能寻址1MB内存空间；2、用户程序可以通过自由修改段基址来访问所有内存空间而引出的安全问题。所以后来的CPU自然就要解决以上的两个问题，CPU厂商为了凸显出自己新的CPU的安全性，将新开发出的CPU命名为工作在保护模式下——也就是提供了一种保护机制让程序不能随意访问所有内存空间，同时CPU的寻址范围也达到了4GB。而8086的那种工作模式由于保护模式的出现而被命名为实模式。

但由于8086CPU在当时取得了非凡的市场成功，所以后来的IA32体系架构CPU必须兼容8086的那种工作模式，所以IA32体系架构CPU也必须可以运行在实模式下。8086只能运行实模式，它使用[段基址：偏移]这种寻址方式，所以IA32体系架构CPU为了兼容8086上开发的程序，也得用[段基址：偏移]这种模式，但是又同时为了能够寻址更大的地址空间以及获得安全性检查，所以就采用了将段寄存器提供的值(16位)不再作为段基址，而是作为一个选择子去GDT表中找到对应的表项，然后从这个表项中得到段基址（32位）与进行安全性检查。所以说 32 位 CPU 具有保护模式和实模式两种运行模式，可以兼容实模式下的程序。兼容实模式，是指能够正确处理好实模式下的程序，并不是说在实模式下运行时就完全变成了纯 16 位的 CPU。

### 保护模式之寄存器扩展

实模式对应的是16位CPU，保护模式对应的是32位CPU，地址线的扩展，也就意味着寄存器的位扩展。

![保护模式下的寄存器扩展图](/home/zhj/.config/Typora/typora-user-images/image-20240726162945553.png)

除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器都由原来的 16 位扩展到了 32 位。寄存器中低 16 位的部分是为了兼容实模式，可以单独使用。高 16 位没办法单独使用，只能在用 32 位寄存器时才有机会用到它们。

### 保护模式之寻址扩展

![保护模式与实模式的寻址方式对比图](/home/zhj/.config/Typora/typora-user-images/image-20240726164333072.png)

保护模式相比与实模式拥有更为灵活，更大寻址范围的寻址方式。

### 保护模式之运行模式反转

在实模式下，运行的指令都是 16 位的，所以编译器 要将代码编译成 16 位的指令。在实模式下准备好了保护模式所需要的环境后，进入保护模式后的代码就应该 是 32 位指令。也就是，同一段程序要经历两种模式，所以同一段程序中有两种模式的机器码。 

bits 的指令格式是[bits 16]或[bits 32]：

- [bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。

- [bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码

由于运行模式的不同，操作数和寻址方式都各不相同，所以在改变运行模式时，需要在机器码中加入操作数反转前缀 0x66 和寻址方式反转前缀 0x67

### 保护模式之指令扩展

在 16 位的实模式下，CPU 的操作数是 16 位。在 32 位的保护模式下，操作数扩展到了 32 位，于是 涉及到操作数变化的指令也要跟着扩展，既要兼容 16 的操作数，也要支持 32 位的操作数。

在实模式下： 

- 当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2；

- 当压入 16 位立即数时，CPU 会将其直接入栈，sp-2；

- 当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

在保护模式下：

- 当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp-4；
-  当压入 16 位立即数时，CPU 直接压入 2 字节，esp-2；
-  当压入 32 位立即数时，CPU 直接压入 4 字节，esp-4。

### 段描述符（Segment Descriptor）

大小为 8 字节，用来描述各个内存段的起始地址、大小、 权限等信息。

![段描述符格式图](/home/zhj/.config/Typora/typora-user-images/image-20240726172135423.png)

-  段界限：表示段边界的扩展最值，扩展方向只有上下两种。对于数据段和代码段，段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。对于栈段，段的扩展方向是向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。段界限只是个单位量，它的单位要么是字节，要么是 4KB，这是由描述符中的 G 位来指定的，G=0，粒度大小为 1 ，G=1，粒度大小为4KB，最终段的边界是此段界限值单位，故段的大小要么是 2 的 20 次方等于 1MB，要么是 2 的 32 次方 (4KB 等于 2 的 12 次方，12+20=32)等于 4GB。 上面所说的 1MB 和 4GB 只是个范围，并不是具体的边界值。由于段界限只是个偏移量，是从 0 算起的，所以实际的段界限边界值=(描述符中段界限+1)(段界限的粒度大小：4KB 或者 1)-1。

- S段：要么描述系统段，要么描述的是数据段，S=0，是系统段，S=1,是数据段。

- TYPE段：本描述符的类型，表示内存段或门的子类型，与S段共同作用确定描述符类型。

  ![S=1，TYPE段的配位说明图](/home/zhj/.config/Typora/typora-user-images/image-20240726173447753.png)
  
  - A 位表示 Accessed 位，这是由 CPU 来设置的，每当该段被 CPU 访问过后，CPU 就将此位置 1。 所以，创建一个新段描述符时，应该将此位置 0。
  - C 位表示一致性代码段，也称为依从代码段，Conforming。一致性代码段是指如果自己是转移的目标段， 并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主， 而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码 段，C 为 0 时则表示该段为非一致性代码段。
  - E 位是用来标识段的扩展方向，Extend。E 为 0 表示向上扩展，即地址越来越高，通常用于代码段和数 据段。E 为 1 表示向下扩展，地址越来越低，通常用于栈段。
  - W 位指段是否可写，Writable。W 为 1 表示可写，通常用于数据段。W 为 0  表示不可写入，通常用于代码段。对于 W 为 0 的段有写入行为，同样会引发 CPU 抛出异常。
  - X 位表示该段是否可执行，EXecutable。指令和数据代码段是可执行的， 即 X 为 1。而数据段是不可执行的，即 X 为 0。
  - R 位表示可读，R 为 1 表示可读，R 为 0 表示不可读。

- DPL 段：即描述符特权级，这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级。
- P段：即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。
- AVL段：随意位。
- L段：是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32 位代码段。
- D/B 段：用来指示有效地址（段内偏移地址）及操作数的大小。D/B 为 0 表示指令中的有效地址和操作数是 16 位，D/B 为 1 表示指令中的有效地址和操作数是 32 位。
- G 段：Granularity，粒度，用来指定段界限的单位大小，G=0，粒度大小为 1 ，G=1，粒度大小为4KB。

### 全局描述符表 (Global Descriptor Table, GDT)

是一个存储段描述符的表格，每个段描述符描述了一个内存段的位置和属性，GDT可以被加载到GDTR寄存器中。

-  GDT的第0个段是不可用的，若选择字的索引值是0，会发生异常，但是LDT的第0个段是可用的。

### GDTR寄存器 (GDTR Register)
GDTR寄存器是x86架构中的一个控制寄存器，存储着全局描述符表（GDT）的起始地址和大小。

 - ![GDTR寄存器配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726192657785.png)
 - 前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于 GDT 的字节大小减 1。后 32 位是 GDT 的起始地址。由于 GDT 的大小是 16 位二进制，其表示的范围是 2 的16次方等于65536字节。每个描述符大小是8字节，故GDT中最多可容纳的描述符数量是65536/8=8192 个，即 GDT 中可容纳 8192 个段或门。

### 选择子 (Selector)
选择子是x86架构中用于选择GDT或LDT中段描述符的一种方式，它包含了一个索引和权限等信息，它是一个数字，用于索引访问全局描述符表或本地描述符表中的段描述符。
 -  ![选择字配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726193109018.png)
 - 其低 2 位即第 0～1 位， 用来存储 RPL，即请求特权级，可以表示 0、1、2、3 四种特权级。在选择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。TI 为 0 表示在 GDT 中索引描述符，TI 为 1 表示在 LDT 中索引描述符。选择子的高 13 位，即第 3～15 位是 描述符的索引值，用此值在 GDT 中索引描述符。13位最有索引8192个段 ，与GDT 中最多定义 8192 个描述符相吻合。
### 段描述符缓冲寄存器 (Segment Descriptor Cache Register)
用于缓存最近使用的段描述符，以提高内存访问效率。

### 打开A20地址线

以24位机器内存举例：

- 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存；

- 如果 A20Gate 被禁止，当访问 0x100000～0x10FFEF 之间的地址时，CPU 将采用 8086/8088 的地址回绕。

打开A20地址线的方式：端口 0x92 的第 1 位置 1。

```ASM
in al，0x92 
or al，0000_0010B 
out 0x92，al 
```

### 保护模式的开关，CR0 寄存器的 PE 位

![CRO配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726194054701.png)

打开位于CRO中的PE位，PE 为 0 表示在实模式下运行，PE 为 1 表示在保护模式下运行。

```ASM
mov eax, cr0 
or eax, 0x00000001 
mov cr0, eax 
```

### 打开保护模式的三步骤

![打开保护模式的三步骤](/home/zhj/.config/Typora/typora-user-images/image-20240726194352633.png)

编写配置文件(yourPath/chapter4/a/boot/include/boot.inc)。

```ASM
                                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2

                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的粒度为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中

```

编写Loader(yourPath/chapter4/a/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
    jmp loader_start					                ;loader一进来是一大堆GDT段描述符数据，无法执行，所以要跳过
   
                                                        
GDT_BASE:                                               ;构建gdt及其内部的描述符 8字节
    dd 0x00000000 
	dd 0x00000000

CODE_DESC:  
    dd 0x0000FFFF 
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	                                    ;limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE
    GDT_LIMIT equ GDT_SIZE - 1 
    times 60 dq 0					                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 
gdt_ptr dw GDT_LIMIT                                    ;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	    dd  GDT_BASE
loadermsg db '2 loader in real.'

loader_start:

                                                        ;------------------------------------------------------------
                                                        ;INT 0x10    功能号:0x13    功能描述:打印字符串
                                                        ;------------------------------------------------------------
                                                        ;输入:
                                                        ;AH 子功能号=13H
                                                        ;BH = 页码
                                                        ;BL = 属性(若AL=00H或01H)
                                                        ;CX＝字符串长度
                                                        ;(DH、DL)＝坐标(行、列)
                                                        ;ES:BP＝字符串地址 
                                                        ;AL＝显示输出方式
                                                        ;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变
                                                        ;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变
                                                        ;   2——字符串中含显示字符和显示属性。显示后，光标位置不变
                                                        ;   3——字符串中含显示字符和显示属性。显示后，光标位置改变
                                                        ;无返回值
    mov sp,LOADER_BASE_ADDR
    mov	bp,loadermsg                                    ; ES:BP = 字符串地址
    mov	cx,17			                                ; CX = 字符串长度
    mov	ax,0x1301		                                ; AH = 13,  AL = 01h
    mov	bx,0x001f		                                ; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)
    mov	dx,0x1800		                                ;
    int	0x10                                            ; 10h 号中断

                                                        ;-----------------   准备进入保护模式   ------------------------------------------
                                                        ;1 打开A20
                                                        ;2 加载gdt
                                                        ;3 将cr0的pe位置1


                                                        ;-----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ;----------------  cr0第0位即pe位置1  ---------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ;jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $
```

修改MBR，即将加载 loader.bin 的读入扇区数增大(yourPath/chapter4/a/boot/mbr.S)。

```ASM
....... 
    mov eax,LOADER_START_SECTOR	    ; 起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 写入的地址
    mov cx,4			            ; 修改读入的扇区数为4
    call rd_disk_m_16		        ; 以下读取程序的起始部分（一个扇区）
........
```

### 处理器微架构

- 流水线技术：取指，译码，执行，三级流水线技术，提高CPU效率。
- 乱序执行：CPU 中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执 行，也许后面的指令先执行，当然，得保证指令之间不具备相关性。
- 缓存：是用一些存取速度较快的存储设备作为数据缓冲区，避免频繁访问速度 较慢的低速存储设备，这是以程序而时空局限性为根据的。
- 分支预测： 2 位预测法，分支目标缓冲器 BTB。

### 远跳转指令jmp

- 清空流水线：流水线中指令译码错误，需要清空流水线。
- 更新段描述符缓冲寄存器：段描述符缓冲寄存器在 CPU 的实模式和保护模式中都同时使用，在不重新引用一个段时，段描述符 缓冲寄存器中的内容是不会更新的，无论是在实模式，还是保护模式下，CPU 都以段描述符缓冲寄存器 中的内容为主。实模式进入保护模式时，由于段描述符缓冲寄存器中的内容仅仅是实模式下的 20 位的段 基址，很多属性位都是错误的值，这对保护模式来说必然会造成错误，所以需要马上更新段描述符缓冲寄 存器，也就是要想办法往相应段寄存器中加载选择子。

### 保护模式之内存段的保护

- 向段寄存器加载选择子时的保护

  - 根据选择子的值验证段描述符是否超越界限，且不是0。当选择字索引值为0时会索引到GDT的第0段，而GDT第0段不可用，会抛出异常。

    ![保护选择字示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726203216518.png)

  - 检查段寄存器的用途和段类型是否匹配

    ![段类型匹配规则表](/home/zhj/.config/Typora/typora-user-images/image-20240726203634579.png)

  - 检查段是否存在：如果 P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选 择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0， 则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。 这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。
  
- 代码段和数据段的保护 

  - CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围。

    ![非法访问示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726204034729.png)

- 栈段的保护

  -  对于向上扩展的段，实际的段界限是段内可以访问的最后一字节。

  - 对于向下扩展的段，实际的段界限是段内不可以访问的第一个字节。

    ![栈的段界限示意图](/home/zhj/.config/Typora/typora-user-images/image-20240726204201433.png)
    
  - 32 位保护模式下栈的栈顶指针是 esp 寄存器，栈的操作数大小是由 B 位决定的，我们这里假设 B 为 1，即操作数是 32 位。栈段也是位于内存中，所以它也要受控于段描述符中的 G 位。 
  
    - 如果 G 为 0，实际的段界限大小=描述符中的段界限。 
    - 如果 G 为 1，实际的段界限大小=描述符中段界限*0x1000+0xFFF。

### 获取物理内存的方式

- 利用 BIOS 中断 0x15 子功能 0xE820 获取内存 

  由于系统内存各部分的类型属性不同， BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。子功能 0xE820 的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符（Address Range Descriptor Structure，ARDS），格式如下：

  ![ARDS结构表](/home/zhj/.config/Typora/typora-user-images/image-20240802163758652.png)

  ![ARDS的Type字段表](/home/zhj/.config/Typora/typora-user-images/image-20240802163838967.png)

  由表可知，此结构中的字段大小都是 4 字节，共 5 个字段，所以此结构大小为 20 字节。每次 int 0x15 之后，BIOS 就返回这样一个结构的数据。注意，ARDS 结构中用 64 位宽度的属性来描述这段内存基地址（起始地址） 及其长度，所以表中的基地址和长度都分为低 32 位和高 32 位两部分。在所有返回的 ARDS 结构里，此值最大的内存块 一定是操作系统可使用的部分，即主板上配置的物理内存容量。BIOS 中断也是函数例程，所以调用它也需要传参，它也会有”返回值“。

  ![0xE820参数示意表1](/home/zhj/.config/Typora/typora-user-images/image-20240802164549543.png)

  ![0xE820中断参数示意表2](/home/zhj/.config/Typora/typora-user-images/image-20240802164641669.png)

  0xE820 调用步骤如下：

  -  填写好“调用前输入”中列出的寄存器。
  - 执行中断调用 int 0x15。
  -  CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

- 利用 BIOS 中断 0x15 子功能 0xE801 获取内存

  分为俩部分，0-15MB和16MB-4GB，低于 15MB 的内存以 1KB 为单位大小来记录， 单位数量在寄存器 AX 和 CX 中记录，其中 AX 和 CX 的值是一样的，所以在 15MB 空间以下的实际内存容量 =AX * 1024。AX、CX 最大值为 0x3c00，即 0x3c00 * 1024=15MB。16MB～4GB 是以 64KB 为单位大小来记录的， 单位数量在寄存器 BX 和 DX 中记录，其中 BX 和 DX 的值是一样的，所以 16MB 以上空间的内存实际大小 =BX * 64 * 1024。

  ![0xE801参数示意表](/home/zhj/.config/Typora/typora-user-images/image-20240802165848936.png)

  分为两部分的原因任然是历史遗留问题，为支持ISA设备，ISA设备会使用到地址15MB以上的1MB的内存作为缓冲区，这部分内存操作系统不可用，即内存空洞。所以实际的物理内存大小，是通过 0xE801 子功能检测到的内存大小 + 1MB 得来的。

  0xE801 调用步骤如下：

  - 将 AX 寄存器写入 0xE801。 
  - 执行中断调用 int 0x15。
  - 在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

- 利用 BIOS 中断 0x15 子功能 0x88 获取内存

  只能识别最大 64MB 的内存。即使内存容量大于 64MB，也只会显示 63MB。

  ![0x88参数示意表](/home/zhj/.config/Typora/typora-user-images/image-20240802171503102.png)
  
  0x88 调用步骤如下：
  
  - 将 AX 寄存器写入 0x88。 
  - 执行中断调用 int 0x15。
  - 在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

编写加载程序(yourPath/chapter5/a/boot/loader.S)。

```asm
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
                                                        
GDT_BASE:                                               ; 构建gdt及其内部的描述符
    dd 0x00000000 
	dd 0x00000000

CODE_DESC:  
    dd 0x0000FFFF 
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	                                    ; limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE
    GDT_LIMIT equ GDT_SIZE - 1 
    times 60 dq 0					                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 

    total_mem_bytes dd 0				                ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。
                                                        ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,
                                                        ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址	 
                                                        
    gdt_ptr dw GDT_LIMIT                                ; 定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	        dd  GDT_BASE

    ards_buf times 244 db 0                             ; 人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节
    ards_nr dw 0	

loader_start:
                                                        ; -------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------

    xor ebx, ebx		                                ; 第一次调用时，ebx值要为0
    mov edx, 0x534d4150	                                ; edx只赋值一次，循环体中不会改变
    mov di, ards_buf	                                ; ards结构缓冲区
.e820_mem_get_loop:	                                    ; 循环获取每个ARDS内存范围描述结构
    mov eax, 0x0000e820	                                ; 执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。
    mov ecx, 20		                                    ; ARDS地址范围描述符结构大小是20字节
    int 0x15
    add di, cx		                                    ; 使di增加20字节指向缓冲区中新的ARDS结构位置
    inc word [ards_nr]	                                ; 记录ARDS数量
    cmp ebx, 0		                                    ; 若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个
    jnz .e820_mem_get_loop

                                                        ; 在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。
    mov cx, [ards_nr]	                                ; 遍历每一个ARDS结构体,循环次数是ARDS的数量
    mov ebx, ards_buf 
    xor edx, edx		                                ; edx为最大的内存容量,在此先清0
.find_max_mem_area:	                                    ; 无须判断type是否为1,最大的内存块一定是可被使用
    mov eax, [ebx]	                                    ; base_add_low
    add eax, [ebx+8]	                                ; length_low
    add ebx, 20		                                    ; 指向缓冲区中下一个ARDS结构
    cmp edx, eax		                                ; 冒泡排序，找出最大,edx寄存器始终是最大的内存容量
    jge .next_ards 
    mov edx, eax                                        ; edx 为总内存大小
.next_ards:
    loop .find_max_mem_area 
    jmp .mem_get_ok 

                                                        ; ------ int 15h ax = E801h 获取内存大小，最大支持 4G ------ 
                                                        ;  返回后, ax cx 值一样,以 1KB 为单位，bx dx 值一样，以 64KB 为单位
                                                        ;  在 ax 和 cx 寄存器中为低 16MB，在 bx 和 dx 寄存器中为 16MB 到 4GB 
.e820_failed_so_try_e801:
    mov ax,0xe801 
    int 0x15 
    jc .e801_failed_so_try88                            ; 若当前 e801 方法失败，就尝试 0x88 方法

                                                        ; 1 先算出低 15MB 的内存
                                                        ; ax 和 cx 中是以 1KB 为单位的内存数量，将其转换为以 byte 为单位
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
    mul cx                                              ; 用 AX 寄存器中的值乘以 CX 的值，结果存入 DX:AX
    shl edx, 16                                         ; 将 EDX 中的值左移 16 位，结果存入 EDX
    and eax, 0x0000FFFF                                 ; 仅保留 EAX 的低 16 位，高 16 位清零
    or edx, eax                                         ; 将 EAX 的值合并到 EDX 的低 16 位
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
    mov esi, edx                                        ; 将 EDX 的值存入 ESI 寄存器
                                                        ; 先把低 15MB 的内存容量存入 esi 寄存器备份

                                                        ; 2 再将 16MB 以上的内存转换为 byte 为单位
                                                        ; 寄存器 bx 和 dx 中是以 64KB 为单位的内存数量
    xor eax,eax 
    mov ax,bx 
    mov ecx, 0x10000                                    ; 0x10000 十进制为 64KB 
    mul ecx                                             ; 32 位乘法，默认的被乘数是 eax，积为 64 位
                                                        ; 高 32 位存入 edx，低 32 位存入 eax 
    add esi,eax 
                                                        ; 由于此方法只能测出 4GB 以内的内存，故 32 位 eax 足够了
                                                        ; edx 肯定为 0，只加 eax 便可
    mov edx,esi                                         ; edx 为总内存大小
    jmp .mem_get_ok 

                                                        ; ----- int 15h     ah = 0x88 获取内存大小，只能获取 64MB 之内 ----- 
.e801_failed_so_try88: 
    mov ah, 0x88                                        ; 设置 AH 寄存器为 0x88，准备调用 BIOS 中断
    int 0x15                                            ; 调用 BIOS 中断 0x15，子功能 0x88，获取内存信息
    jc .error_hlt                                       ; 如果调用失败（进位标志被设置），跳转到 .error_hlt 标签

    and eax, 0x0000FFFF                                 ; 清除 EAX 的高 16 位，仅保留低 16 位
                                                        ; AX 存储的是以 1KB 为单位的内存容量
    
                                                        ; 16 位乘法，被乘数是 AX，积为 32 位。积的高 16 位在 DX 中，积的低 16 位在 AX 中
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
                                                        ; 用于将 AX 中的内存容量转换为字节
    
    mul cx                                              ; 进行乘法运算，AX * CX，结果为 32 位，高 16 位在 DX 中，低 16 位在 AX 中
    shl edx, 16                                         ; 将 DX 的值左移 16 位，结果存储在 EDX 中
    or edx, eax                                         ; 将 EAX 中的低 16 位值与 EDX 进行按位或操作，合并结果存储在 EDX 中
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
                                                        ; 因为 0x88 子功能只会返回 1MB 以上的内存，所以要加上 1MB


.mem_get_ok:
mov [total_mem_bytes], edx                              ; 将内存换为 byte 单位后存入 total_mem_bytes 处


                                                        ; -----------------   准备进入保护模式   ------------------------------------------
                                                        ; 1 打开A20
                                                        ; 2 加载gdt
                                                        ; 3 将cr0的pe位置1


                                                        ; -----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ; -----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ; -----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ; jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

                                                        
    .error_hlt:		                                    ; 出错则挂起
    hlt

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $
```

显然，作者是错误的，他得出32MB的这个数据是碰巧得到的。作者这样寻找最大地址的方法，最后得出来整个内存大小是32MB的确是巧合。因为最后一个ARDS结构体最大地址是4GB，溢出eax寄存器的值，所以最后得到的最大地址是倒数第二个类型ARDS结构体(type=1)的baseaddr low + length low。
现代操作系统（如Linux）在计算可用物理内存时通常只考虑类型为1的ARDS结构体。类型1表示可用的RAM，这是操作系统和应用程序可以使用的内存。如果作者计算的是整个内存大小（包含可用和不可用），那么与现代操作系统通常做法不符；如果作者计算的是可用内存大小，那么作者并没有考虑ARDS结构体的类型字段，并且方法错误。
所以作者是错的。正确做法应该是计算可用内存大小，这通过相加类型为1的ARDS结构体的lengthlow得到。并且还应该记录ARDS结构体类型字段为1所指示的可用内存区域的起始地址，这样后续内存分配机制才能算得上真正正确。

### 内存分页，虚拟内存

分段模型最大的缺点就是每个段大小不一，带来内存管理的困难。为了解决这一系列问题，必须先解除线性地址与物理地址一一对应的关系，通过实现某种映射关系，实现线性地址可以对应到所有的物理地址，这就引出了分页机制，即通过固定大小且比一般段更小的块管理来代替原有的段管理。而且正是由于分页机制的引入，原有CPU设计者所设想的那种分段机制就基本被弃用，如现代操作系统都用平坦模型，抛弃了原来的那种在内存中分段管理的思路。

分页机制的核心就是，将程序所要用的虚拟内存空间（也就是32位编程时给程序分配的空间）与实际用到的内存空间分离。将程序所要用到的虚拟内存空间，拆分成一个个固定大小的小块（虚拟的4K），与物理内存上的固定大小的小块建立映射关系。就是这样的一种分离，带来了内存管理的粒度更小（原有的段机制下段可能远比4K大得多）、粒度更标准（段大小不一，现在统一成了4K大小）、更灵活（将程序暂时用不到的小块不放入内存中，等用到了再从磁盘中调入）等优点。

### 分页机制

![分段机制和分页机制的区别图](/home/zhj/.config/Typora/typora-user-images/image-20240802195145498.png)

经过段部件处理后，保护模式的寻址空间是 4GB，这个寻址空间是指线性地址空间，它在逻辑上是连续的。分页机制的思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑 上连续的线性地址其对应的物理地址可以不连续。 

分页机制的作用有两方面：

- 将线性地址转换成物理地址。  
- 用大小相等的页代替大小不等的段。

![分页机制的作用示意图](/home/zhj/.config/Typora/typora-user-images/image-20240802195956143.png)

由于分页机制的基础是分段机制，所以为保证向前兼容，所以原有段机制得到的地址被重新命名为线性地址，需要经过页机制的处理得到物理地址，具体做法就是用段机制下得到的线性地址查询页表找到内存上的页。上图，表示得是进程的段，从线性地址空间到虚拟地址空间再到物理地址空间的过程，每个空间都是4GB，图上的 4GB 物理地址空间属于所有进程包括操作系统在内的共享资源，其中标注为已分配页的内存块被分配给了其他进程，当前进程只能使用未分配页。此转换过程对任意一个进程都是一样的，也就是说，每个进程都有自己的 4GB 虚拟空间，代码段和数据段在逻辑上被拆分成以页为单位的小内存块。这时的虚拟地址虚如其名，不能存放任何数据。接着操作系统开始为这些虚拟内存页分配真实的物理内存页，它查找物理内存中可用的页，然后在页表中登记这些物理页地址，这样就完成了虚拟页到物理页的映射，每个进程都以为自己独享 4GB 地址空间。

### 一级页表

如果采用线性地址和物理地址进行一一映射的关系，4GB的物理内存会有4G个页表项，32位的地址需要4字节来存储，那也就是需要4B * 4G = 16GB，直接得不偿失，分页机制本质上是将大小不同的大内存段拆分成大小相等的小内存块。所以我们需要在内存块数量和内存块大小之间取一个平衡值，即寻取一个合适的页尺寸。

![页尺寸的寻找和页表与物理内存关系示意图](/home/zhj/.config/Typora/typora-user-images/image-20240802202737226.png)

在一级页表中我们选择，高20位作为页表项的数目，低12位作为页尺寸的大小。即在一级页表中，有1M个页表项，页尺寸为 4KB。

### 二级页表

一级页表中最多可容纳 1M（1048576）个页表项，每个页表项是 4 字节，如果页表项全满的话， 便是 4MB 大小，一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB， 用户进程要占用低 3GB，每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。所以二级页表就此诞生。

![二级页表示意图](/home/zhj/.config/Typora/typora-user-images/image-20240802204014847.png)

二级页表地址转换原理是将 32 位虚拟地址拆分成高 10 位、中间 10 位、低 12 位三部分，它们 的作用是：高 10 位作为页表的索引，用于在页目录表中定位一个页目录项 PDE，页目录项中有页表物理地址， 也就是定位到了某个页表。中间 10 位作为物理页的索引，用于在页表内定位到某个页表项 PTE，页表项中有分 配的物理页地址，也就是定位到了某个物理页。低 12 位作为页内偏移量用于在已经定位到的物理页内寻址。

- 用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的 和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。 
- 用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址， 所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。 
- 虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PTE 的索引值，所以它们需要乘以 4。但低 12 位 就不是索引值啦，其表示的范围是 0～0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第 2 步 中得到的物理页地址，所得的和便是最终转换的物理地址

![二级页表虚拟地址到真实物理地址的转换示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803091834644.png)

![页目录项和页表项结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803092021345.png)

由于页目录项和页表项都存储的是物理页的真实地址，都是4KB的整数倍，所以只需要20位即可，剩下的12位作为属性位。

P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操 作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。 

RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。 

US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、 3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页， 该页只允许特权级别为 0、1、2 的程序可以访问。 

PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式， 表示该页不仅是普通内存，还是高速缓存。

PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。

Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。与段描述符中的 A 和 P 位相似。 

D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项仅针对页表项有效，并不会修改页目录项中的 D 位。

PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。

G,Global，意为全局位。为 0 表示不是全局页。若为全局页，该页将在高速 缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址，无需那三步骤转换。由于 TLB 容量比较小（一般 、速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。 

AVL，意为 Available 位，表示可用。

### 启动分页机制的三步骤

- 准备好页目录表及页表。

- 将页表地址写入控制寄存器 CR3。

  PDBR寄存器(控制寄存器CR3)

  ![PDBR寄存器结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803093839588.png)

  PCD 和 PWT 都与高速缓存有关，在这里置 0 即可。

- 寄存器 CR0 的 PG 位置 1。

  ![CRO配位图](/home/zhj/.config/Typora/typora-user-images/image-20240726194054701.png)

  PG置1,即开启分页机制。

### 开启分页机制

![页目录表与页表的关系示意图和页目录表与页表内存布局示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803094710360.png)

这里我们选择 0x10000 作为第一个页目录项的起始地址。也就是留出低端 1MB 的大小为了存放 MBR Loader 以及操作系统内核。对于Linux系统来说，在用户进程 4GB 虚拟地址空间的 高 3GB 以上的部分划分给操作系统，0～3GB 是用户进程自己的虚拟空间。为了实现共享操作系统，让所有用户进程 3GB～4GB 的虚拟地址空间都指向同一个操作系统，只要保证所有用户进程虚拟地址空间 3GB～4GB 对应的页表项中所记录的物理页地址是相同就可以了。操作系统应该在虚拟地址 0xc0000000 以上， 高10 位是 0x300，即十进制的 768。这样虚拟地址 0xc0000000～0xc03fffff 之间的内存都指向的是低端 4MB 之内的物理地址，自然包括了操作系统所占的低 1MB 的物理内存，从而实现了操作系统高 3GB 以上的虚拟地址对应到了低端 1MB。

编写配置文件(yourPath/chapter5/b/boot/include/boot.inc)。

```asm
                                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2
PAGE_DIR_TABLE_POS equ 0x100000 
                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的单位为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中

                                                    ;---------------- 页表相关属性 -------------- 
PG_P equ 1b 
PG_RW_R equ 00b 
PG_RW_W equ 10b 
PG_US_S equ 000b 
PG_US_U equ 100b 
```

编写加载器(yourPath/chapther/b/boot/loader.S)。

```ASM
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
                                                        
GDT_BASE:                                               ; 构建gdt及其内部的描述符
    dd 0x00000000 
	dd 0x00000000

CODE_DESC:  
    dd 0x0000FFFF 
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	                                    ; limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE
    GDT_LIMIT equ GDT_SIZE - 1 
    times 60 dq 0					                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 

    total_mem_bytes dd 0				                ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。
                                                        ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,
                                                        ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址	 
                                                        
    gdt_ptr dw GDT_LIMIT                                ; 定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	        dd  GDT_BASE

    ards_buf times 244 db 0                             ; 人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节
    ards_nr dw 0	

loader_start:
                                                        ; -------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------

    xor ebx, ebx		                                ; 第一次调用时，ebx值要为0
    mov edx, 0x534d4150	                                ; edx只赋值一次，循环体中不会改变
    mov di, ards_buf	                                ; ards结构缓冲区
.e820_mem_get_loop:	                                    ; 循环获取每个ARDS内存范围描述结构
    mov eax, 0x0000e820	                                ; 执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。
    mov ecx, 20		                                    ; ARDS地址范围描述符结构大小是20字节
    int 0x15
    add di, cx		                                    ; 使di增加20字节指向缓冲区中新的ARDS结构位置
    inc word [ards_nr]	                                ; 记录ARDS数量
    cmp ebx, 0		                                    ; 若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个
    jnz .e820_mem_get_loop

                                                        ; 在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。
    mov cx, [ards_nr]	                                ; 遍历每一个ARDS结构体,循环次数是ARDS的数量
    mov ebx, ards_buf 
    xor edx, edx		                                ; edx为最大的内存容量,在此先清0
.find_max_mem_area:	                                    ; 无须判断type是否为1,最大的内存块一定是可被使用
    mov eax, [ebx]	                                    ; base_add_low
    add eax, [ebx+8]	                                ; length_low
    add ebx, 20		                                    ; 指向缓冲区中下一个ARDS结构
    cmp edx, eax		                                ; 冒泡排序，找出最大,edx寄存器始终是最大的内存容量
    jge .next_ards 
    mov edx, eax                                        ; edx 为总内存大小
.next_ards:
    loop .find_max_mem_area 
    jmp .mem_get_ok 

                                                        ; ------ int 15h ax = E801h 获取内存大小，最大支持 4G ------ 
                                                        ; 返回后, ax cx 值一样,以 1KB 为单位，bx dx 值一样，以 64KB 为单位
                                                        ; 在 ax 和 cx 寄存器中为低 16MB，在 bx 和 dx 寄存器中为 16MB 到 4GB 
.e820_failed_so_try_e801:
    mov ax,0xe801 
    int 0x15 
    jc .e801_failed_so_try88                            ; 若当前 e801 方法失败，就尝试 0x88 方法

                                                        ; 1 先算出低 15MB 的内存
                                                        ; ax 和 cx 中是以 1KB 为单位的内存数量，将其转换为以 byte 为单位
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
    mul cx                                              ; 用 AX 寄存器中的值乘以 CX 的值，结果存入 DX:AX
    shl edx, 16                                         ; 将 EDX 中的值左移 16 位，结果存入 EDX
    and eax, 0x0000FFFF                                 ; 仅保留 EAX 的低 16 位，高 16 位清零
    or edx, eax                                         ; 将 EAX 的值合并到 EDX 的低 16 位
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
    mov esi, edx                                        ; 将 EDX 的值存入 ESI 寄存器
                                                        ; 先把低 15MB 的内存容量存入 esi 寄存器备份

                                                        ; 2 再将 16MB 以上的内存转换为 byte 为单位
                                                        ; 寄存器 bx 和 dx 中是以 64KB 为单位的内存数量
    xor eax,eax 
    mov ax,bx 
    mov ecx, 0x10000                                    ; 0x10000 十进制为 64KB 
    mul ecx                                             ; 32 位乘法，默认的被乘数是 eax，积为 64 位
                                                        ; 高 32 位存入 edx，低 32 位存入 eax 
    add esi,eax 
                                                        ; 由于此方法只能测出 4GB 以内的内存，故 32 位 eax 足够了
                                                        ; edx 肯定为 0，只加 eax 便可
    mov edx,esi                                         ; edx 为总内存大小
    jmp .mem_get_ok 

                                                        ; ----- int 15h     ah = 0x88 获取内存大小，只能获取 64MB 之内 ----- 
.e801_failed_so_try88: 
    mov ah, 0x88                                        ; 设置 AH 寄存器为 0x88，准备调用 BIOS 中断
    int 0x15                                            ; 调用 BIOS 中断 0x15，子功能 0x88，获取内存信息
    jc .error_hlt                                       ; 如果调用失败（进位标志被设置），跳转到 .error_hlt 标签

    and eax, 0x0000FFFF                                 ; 清除 EAX 的高 16 位，仅保留低 16 位
                                                        ; AX 存储的是以 1KB 为单位的内存容量
    
                                                        ; 16 位乘法，被乘数是 AX，积为 32 位。积的高 16 位在 DX 中，积的低 16 位在 AX 中
    mov cx, 0x400                                       ; 将值 0x400 (1024) 存入 CX 寄存器
                                                        ; 用于将 AX 中的内存容量转换为字节
    
    mul cx                                              ; 进行乘法运算，AX * CX，结果为 32 位，高 16 位在 DX 中，低 16 位在 AX 中
    shl edx, 16                                         ; 将 DX 的值左移 16 位，结果存储在 EDX 中
    or edx, eax                                         ; 将 EAX 中的低 16 位值与 EDX 进行按位或操作，合并结果存储在 EDX 中
    add edx, 0x100000                                   ; 向 EDX 中的值加上 0x100000 (1MB)
                                                        ; 因为 0x88 子功能只会返回 1MB 以上的内存，所以要加上 1MB


.mem_get_ok:
mov [total_mem_bytes], edx                              ; 将内存换为 byte 单位后存入 total_mem_bytes 处


                                                        ; -----------------   准备进入保护模式   ------------------------------------------
                                                        ; 1 打开A20
                                                        ; 2 加载gdt
                                                        ; 3 将cr0的pe位置1


                                                        ; -----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ; -----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ; -----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ; jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

                                                        
    .error_hlt:		                                    ; 出错则挂起
    hlt

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    call setup_page                                     ; 创建页目录表的函数,我们的页目录表必须放在1M开始的位置，所以必须在开启保护模式后运行
                                                        ; 要将描述符表地址及偏移量写入内存 gdt_ptr，一会儿用新地址重新加载
    sgdt [gdt_ptr]                                      ; 存储到原来 gdt 所有的位置
                                                        ; 以下两句是将gdt描述符中视频段描述符中的段基址+0xc0000000
    mov ebx, [gdt_ptr + 2]                              ; ebx中存着GDT_BASE
    or dword [ebx + 0x18 + 4], 0xc0000000               ; 视频段是第3个段描述符,每个描述符是8字节,故0x18 = 24，然后+4，是取出了视频段段描述符的高4字节。然后or操作，段基址最高位+c
                                            
    add dword [gdt_ptr + 2], 0xc0000000                 ; 将gdt的基址加上0xc0000000使其成为内核所在的高地址

    add esp, 0xc0000000                                 ; 将栈指针同样映射到内核地址

    mov eax, PAGE_DIR_TABLE_POS                         ; 把页目录地址赋给cr3
    mov cr3, eax
                                                        
    mov eax, cr0                                        ; 打开cr0的pg位(第31位)
    or eax, 0x80000000  
    mov cr0, eax
                                                        
    lgdt [gdt_ptr]                                      ; 在开启分页后,用gdt新的地址重新加载

    mov byte [gs:160], 'V'                              ; 视频段段基址已经被更新,用字符v表示virtual addr

    jmp $
    
                                                        
setup_page:                                             ; ------------------------------------------   创建页目录及页表  -------------------------------------
                                                        ; ----------------以下6行是将1M开始的4KB置为0，将页目录表初始化
    mov ecx, 4096                                       ; 创建4096个byte 0，循环4096次
    mov esi, 0                                          ; 用esi来作为偏移量寻址
.clear_page_dir:
    mov byte [PAGE_DIR_TABLE_POS + esi], 0				
    inc esi
    loop .clear_page_dir								; 执行一次 loop ， ecx 中的值 -1

                                                        ; ----------------初始化页目录表，让0号项与768号指向同一个页表，该页表管理从0开始4M的空间
.create_pde:				                            ; 一个页目录表项可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，这是为将地址映射为内核地址做准备
    mov eax, PAGE_DIR_TABLE_POS                         ; eax中存着页目录表的位置
    add eax, 0x1000 			                        ; 在页目录表位置的基础上+4K（页目录表的大小），现在eax中第一个页表的起始位置
    mov ebx, eax				                        ; 此处为ebx赋值，现在ebx存着第一个页表的起始位置
    or eax, PG_US_U | PG_RW_W | PG_P	                ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.
                                                        ; 现在eax中的值符合一个页目录项的要求了，高20位是一个指向第一个页表的4K整数倍地址，低12位是相关属性设置
    mov [PAGE_DIR_TABLE_POS + 0x0], eax                 ; 页目录表0号项写入第一个页表的位置(0x101000)及属性(7)
    mov [PAGE_DIR_TABLE_POS + 0xc00], eax               ; 页目录表768号项写入第一个页表的位置(0x101000)及属性(7)
					                                    
    sub eax, 0x1000                                     ; ----------------- 使最后一个目录项指向页目录表自己的地址，为的是将来动态操作页表做准备
    mov [PAGE_DIR_TABLE_POS + 4092], eax	            ; 属性包含PG_US_U是为了将来init进程（运行在用户空间）访问这个页目录表项
                                                        
    mov ecx, 256				                        ; -----------------初始化第一个页表，因为我们的操作系统不会超过1M，所以只用初始化256项
    mov esi, 0                                          ; esi来做寻址页表项的偏移量
    mov edx, PG_US_U | PG_RW_W | PG_P	                ; 属性为7,US=1,RW=1,P=1
.create_pte:				                            ; 创建Page Table Entry
    mov [ebx+esi*4],edx			                        ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 
    add edx,4096                                        ; edx指向下一个4kb空间，且已经设定好了属性，故edx中是一个完整指向下一个4kb物理空间的页表表项
    inc esi                                             ; 寻址页表项的偏移量+1
    loop .create_pte                                    ; 循环设定第一个页表的256项

                                                        ; -------------------初始化页目录表769号-1022号项，769号项指向第二个页表的地址（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推
    mov eax, PAGE_DIR_TABLE_POS                         ; eax存页目录表的起始位置
    add eax, 0x2000 		                            ; 此时eax为第二个页表的位置
    or eax, PG_US_U | PG_RW_W | PG_P                    ; 设置页目录表项相关属性，US,RW和P位都为1，现在eax中的值是一个完整的指向第二个页表的页目录表项
    mov ebx, PAGE_DIR_TABLE_POS                         ; ebx现在存着页目录表的起始位置
    mov ecx, 254			                            ; 要设置254个表项
    mov esi, 769                                        ; 要设置的页目录表项的偏移起始
.create_kernel_pde:
    mov [ebx+esi*4], eax                                ; 设置页目录表项
    inc esi                                             ; 增加要设置的页目录表项的偏移
    add eax, 0x1000                                     ; eax指向下一个页表的位置，由于之前设定了属性，所以eax是一个完整的指向下一个页表的页目录表项
    loop .create_kernel_pde                             ; 循环设定254个页目录表项
    ret
```

### 虚拟地址获取页表中各数据类型的方法

- 获取页目录表物理地址：让虚拟地址的高 20 位为 0xfffff，低 12 位为 0x000，即 0xfffff000，这也 是页目录表中第 0 个页目录项自身的物理地址。
- 访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为 0xfffffxxx，其中 xxx 是页目录 项的索引乘以 4 的积。
- 访问页表中的页表项：要使虚拟地址高 10 位为 0x3ff，目的是获取页目录表物理地址。中间 10 位为页表的索引，因为是 10 位的索引值，所以这里不用乘以 4。低 12 位为页表内的偏移地址，用来定位页表项，它必须是已经乘以 4 后的值。

### 快表 TLB

处理器准备了一个高速缓存，可以匹配高速的处理器速率和低速的内存访问速度，它专门用来存放虚拟地址页框与物理地址页框的映射关系，这个调整缓存就是 TLB。就是说可以直接用虚拟地址的低 12 位在该物理页框中寻址，大大提高了地址转换速度。

清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。 

![TLB简图](/home/zhj/.config/Typora/typora-user-images/image-20240803103637304.png)

## 加载内核

### ELF文件格式

程序中最重要的部分就是段和节。program header用于描述每个段的信息，section header用于描述每个节的信息。由于程序中段与节的大小和数量是不固定的，所以program header与section header的数量大小也是不固定的，因此需要为它们专门找个数据结构来描述它们，这个描述结构就是program header table与section header table。但是，多一个段，就多一个program header，program header table就会变大，所以program header table与section header table的大小也是不固定的，就又需要一个elf header来描述program header table与section header table。

下图是编译好的操作系统的elf文件头格式，我们要从elf header中取得program header table的信息，又从program header table中得到关于对每个段program header的信息，根据这个信息去确定每个段的大小，起始地址，在内存中的目的地址（都是虚拟地址）。

![ELF文件格式布局图](/home/zhj/.config/Typora/typora-user-images/image-20240803110916575.png)

本节中所说的目标文件即指各种类型符合 ELF 规范的文件。

![ELF眼中的目标文件示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803111114540.png)

ELF header结构如下：

![ELF header结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803111325885.png)

![ELF header数据类型表](/home/zhj/.config/Typora/typora-user-images/image-20240803111425597.png)

e_ident[16]是 16 字节大小的数组，用来表示 elf 字符等信息，开头的 4 个字节是固定不变的，是 elf 文件的魔数，它们分别是 0x7f，以及字符串 ELF 的 ASCII 码：0x45, 0x4c, 0x46。

![e_ident数组功能表](/home/zhj/.config/Typora/typora-user-images/image-20240803111558926.png)

e_type 占用 2 字节，是用来指定 elf 目标文件的类型。

![ELF目标文件类型表1](/home/zhj/.config/Typora/typora-user-images/image-20240803111823792.png)

![ELF目标文件类型表2](/home/zhj/.config/Typora/typora-user-images/image-20240803111916605.png)

e_machine 占用 2 字节，用来描述 elf 目标文件的体系结构类型，即文件要在哪种硬件平台上运行。

![e_machine示意表](/home/zhj/.config/Typora/typora-user-images/image-20240803112047924.png)

e_version 占用 4 字节，用来表示版本信息。 

e_entry 占用 4 字节，用来指明操作系统运行该程序时，将控制权转交到的虚拟地址。

e_phoff 占用 4 字节，用来指明程序头表（program header table）在文件内的字节偏移量。如果没有程序头表，该值为 0。

e_shoff 占用 4 字节，用来指明节头表（section header table）在文件内的字节偏移量。若没有节头表， 该值为 0。 

e_flags 占用 4 字节，用来指明与处理器相关的标志。

e_ehsize 占用 2 字节，用来指明 elf header 的字节大小。

e_phentsize 占用 2 字节，用来指明程序头表（program header table）中每个条目（entry）的字节大小， 即每个用来描述段信息的数据结构的字节大小，该结构是后面要介绍的 struct Elf32_Phdr。 

e_phnum 占用 2 字节，用来指明程序头表中条目的数量。实际上就是段的个数。 

e_shentsize 占用 2 字节，用来指明节头表（section header table）中每个条目（entry）的字节大小，即 每个用来描述节信息的数据结构的字节大小。

e_shnum 占用 2 字节，用来指明节头表中条目的数量。实际上就是节的个数。

e_shstrndx 占用 2 字节，用来指明 string name table 在节头表中的索引 index。

![描述段信息的数据结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803112420880.png)

Elf32_Phdr 和 Elf32_Ehdr 的关系就如同段描述符和GDT一样，段描述符用来描述物理内存中的一个内存段，而 struct Elf32_Phdr 是用来描述位于磁盘上的程序中的一个段，它被加载到内存后才属于 GDT 中段描述符所指向的内存段的子集。

p_type 占用 4 字节，用来指明程序中该段的类型。

![程序中的段类型示意表](/home/zhj/.config/Typora/typora-user-images/image-20240803113038908.png)

p_offset 占用 4 字节，用来指明本段在文件内的起始偏移字节。

p_vaddr 占用 4 字节，用来指明本段在内存中的起始虚拟地址。 

p_paddr 占用 4 字节，仅用于与物理地址相关的系统中，以此项暂且保留，未设定。

p_filesz 占用 4 字节，用来指明本段在文件中的大小。

p_memsz 占用 4 字节，用来指明本段在内存中的大小。

p_flags 占用 4 字节，用来指明与本段相关的标志。

![p_flags取值示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803113202926.png)

p_align 占用 4 字节，用来指明本段在文件和内存中的对齐方式。如果值为 0 或 1，则表示不对齐。否 则 p_align 应该是 2 的幂次数。

### 将内核载入内存

内核是由Loader加载至内存中的，Loader要获取物理内存，切换模式，打开分页机制以及加载并初始化内核。

- 获取物理内存：0x15 中断的三个子功能。
- 切换模式：从实模式切换至保护模式。
- 打开分页机制：虚拟内存的出现。

- 加载内核：需要把内核文件加载到内存缓冲区。 
- 初始化内核：需要在分页后，将加载进来的 elf 内核文件安置到相应的虚拟内存地址。

加载内核到内存中，得有个加载地址，也就是缓冲区。这个缓冲区便是前文提到的低端1MB的空间了。

![低端1MB空间分布图](/home/zhj/.config/Typora/typora-user-images/image-20240803114843243.png)

编写配置文件(yourPath/chapter5/c/boot/include/boot.inc)

```ASM
                                                    ; -------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2
PAGE_DIR_TABLE_POS equ 0x100000 
                                                    ; --------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ; 设置段界限的单位为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ; 设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ; 64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ; 此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ; 可以将这个位用于任何自定义的需求。
                                                    ; 比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ; 这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ; 定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ; 定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ; 定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ; 定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ; 定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ; 定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ; 定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ; 定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ; 无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ; 无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ; 将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ; x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ; x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ; 定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ; --------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ; 定义选择字的RPL为0
RPL1  equ   01b                                     ; 定义选择子的RPL为1
RPL2  equ   10b                                     ; 定义选择字的RPL为2
RPL3  equ   11b                                     ; 定义选择子的RPL为3
TI_GDT	 equ   000b                                 ; 定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ; 定义段选择子请求的段描述符是在LDT中

                                                    ; ---------------- 页表相关属性 -------------- 
PG_P equ 1b 
PG_RW_R equ 00b 
PG_RW_W equ 10b 
PG_US_S equ 000b 
PG_US_U equ 100b 

LOADER_STACK_TOP equ LOADER_BASE_ADDR               ; 这一条之前是在loader.S中定义，现在搬过来了

KERNEL_BIN_BASE_ADDR equ 0x70000                    ; 定义内核在内存中的缓冲区，也就是将编译好的内核文件暂时存储在内存中的位置
KERNEL_START_SECTOR equ 0x9                         ; 定义内核在磁盘的起始扇区
KERNEL_ENTER_ADDR equ 0xc0001500                    ; 定义内核可执行代码的入口地址

PT_NULL equ 0                                       ; -------------  程序段的 type 定义   --------------
                                                    ; 用于判断该段是否应该被加载
```

编写加载器(yourPath/chapter5/c/boot/loader.S)

```ASM
%include "boot.inc"
SECTION LOADER vstart=LOADER_BASE_ADDR    ; 同书上，设置为0x900
LOADER_STACK_TOP equ LOADER_BASE_ADDR     ; 初始化栈顶，0x900向下为栈空间
jmp loader_start

                                          ; 构建GDT及其内部的描述符
   GDT_BASE:   
   dd   0x00000000                        ; 没用的第0个段描述符
   dd   0x00000000

   CODE_DESC: 
   dd   0x0000FFFF
   dd   DESC_CODE_HIGH4

   DATA_STACK_DESE:   
   dd   0x0000FFFF
   dd   DESC_DATA_HIGH4
                                          
   VIDEO_DESC: 
   dd   0x80000007                        ; limit=(0xbffff-0xb8000)/4k=0x7
   dd   DESC_VIDEO_HIGH4                  ; 此时DPL为0
   
   GDT_SIZE    equ  $-GDT_BASE            ; 地址差作尺寸：当前行地址-GDT_BASE地址
   GDT_LIMIT   equ  GDT_SIZE-1

   times 59 dq 0                          ; dq 定义4字/8字节
   times 5 db 0

   total_mem_bytes dd 0                 
   SELECTOR_CODE   equ   (0x0001<<3)+TI_GDT+RPL0
                                          ; 相当于(CODE_DESC-GDT_BASE)/8+TI_GDT+RPL0
   SELECTOR_DATA   equ   (0x0002<<3)+TI_GDT+RPL0
   SELECTOR_VIDEO  equ   (0x0003<<3)+TI_GDT+RPL0

                                          ; 以下是GDT的指针GDTR,6B/48bit，前2字节是GDT界限，后4字节是GDT起始地址
   gdt_ptr     dw  GDT_LIMIT
               dd  GDT_BASE

   ards_buf times 244 db 0
   ards_nr dw 0

loader_start:
                                          ; int 15h eax=0000E820h, edx=534D4150h('SMAP'的ASCII码)获取内存布局
   xor ebx,ebx                            ; 第一次调用时，ebx要为0
   mov edx,0x534d4150                     ; edx只赋值一次，循环体中不会改变，用于签名校验
   mov di,ards_buf                        ; ards结构缓冲区

.e820_mem_get_loop:                       ; 循环获取每个ARDS内存范围描述结构
   mov eax,0x0000e820                     ; 执行int 0x15后，eax值变为0x534d4150，所以每次执行int前都要更新为子>功能号
   mov ecx,20                             ; ARDS地址范围描述符结构大小是20字节
   int 0x15                               ; 0x15为获取内存容量的中断号
   jc .e820_failed_so_try_e801            ; 若cf位为1则有错误发生，尝试0xe801子功能
   add di,cx                              ; 使di增加20字节指向缓冲区中新的ARDS结构位置
   inc word [ards_nr]                     ; 记录ARDS数量
   cmp ebx,0                              ; 若ebx为0且cf不为1，这说明ards全部返回，当前已是最后一个

   jnz .e820_mem_get_loop

                                          ; 在所有ards结构中找出(base_add_low+length_low)的最大值，即内存的容量
   mov cx,[ards_nr]                       ; 遍历每个ARDS结构体，循环次数是ARDS的数量
   mov ebx,ards_buf
   xor edx,edx                            ; 此后edx用于记录最大内存容量，在此先请0

.find_max_mem_area:                       ; 无需判断type是否为1，最大的内存块一定是可以被使用的
   mov eax,[ebx]                          ; base_add_low
   add eax,[ebx+8]                        ; length_low
   add ebx,20                             ; 指向缓冲区下一个ARDS结构
   cmp edx,eax                            ; 冒泡排序，找出最大，edx寄存器始终是最大的内存容量
   jge .next_ards
   mov edx,eax                            ; edx为总内存大小

.next_ards:
   loop .find_max_mem_area
   jmp .mem_get_ok

                                          ; ---------- int 15h ax=E801h 获取内存大小，最大支持4G ----------
                                          ; 返回后，ax cx值一样，以KB为单位，bx dx值一样，以64KB为单位
                                          ; 在ax和cx寄存器中为低16MB，在bx和dx寄存器中为16MB到4GB
.e820_failed_so_try_e801:
   mov ax,0xe801
   int 0x15
   jc .e801_failed_so_try88               ; 若当前e801方法也失败，则尝试0x88方法

                                          ; 1.先算出低15MB内存。ax cx是以KB为单位的内存数量，将其转换为以Byte为单位
   mov cx,0x400                           ; 0x400十进制为1K。cx和ax一样，cx用作乘数
   mul cx
   shl edx,16
   and eax,0x0000FFFF
   or edx,eax
   add edx,0x100000                       ; ax只是15MB，故要追加1MB
   mov esi,edx                            ; 先把低15MB内存容量存入esi寄存器备份

                                          ; 2.再将16MB以上的内存转换为Byte为单位。bx dx是以64KB为单位的内存数量
   xor eax,eax
   mov ax,bx
   mov ecx,0x10000                        ; 0x10000十进制为64KB
   mul ecx                                ; 32位乘法，默认的被乘数是eax，积为64位。高32位存入edx，低32位存入eax
   add esi,eax                            ; 4GB内存，edx为0，低32位足矣
   mov edx,esi                            ; edx为总内存大小
   jmp .mem_get_ok

                                          ; ------- int 15h ah=0x88获取内存大小，只能获取64MB之内 ---------
.e801_failed_so_try88:
                                          ; int 15h后，ax存入的是以KB为单位的内存容量
   mov ah,0x88
   int 0x15
   jc .error_hlt
   and eax,0x0000FFFF

                                          ; 16位乘法，被乘数是ax，积为32位。积的高16位在dx中，低16位在ax中
   mov cx,0x400
   mul cx
   shl edx,16                             ; 把edx移动高16位
   or edx,eax                             ; 把低16位组合到edx，即为32为积
   add edx,0x100000                       ; 0x88只会返回1MB以上的内存，故实际内存还要加上1MB

.error_hlt:
   jmp $

.mem_get_ok:
   mov [total_mem_bytes],edx              ; 将内存换位Byte单位后存入total_mem_bytes处

                                          ; --------------------- 准备进入保护模式 ------------------------
                                          ; 1 打开A20
                                          ; 2 加载GDT
                                          ; 3 将cr0的PE位置1

                                          ; --------------------------- 打开A20 ---------------------------
   in al,0x92
   or al,0000_0010B                       ; 简单说，将端口0x92的第1位置1即可
   out 0x92,al

                                          ; --------------------------- 加载GDT ---------------------------
   lgdt [gdt_ptr]                         ; load GDT [addr]

                                          ; -------------------------- cr0第0位置1 ------------------------
   mov eax,cr0
   or eax,0x00000001
   mov cr0,eax

   jmp dword SELECTOR_CODE:p_mode_start   ; 刷新流水线。因为要远转移，cs更新，所>以流水线上的其它指令都没用了，就会刷新

[bits 32]                                 ; 开启32位指令
p_mode_start:
   mov ax,SELECTOR_DATA
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov esp,LOADER_STACK_TOP

                                          ; -------------------------- 加载kernel ------------------------
   mov eax,KERNEL_START_SECTOR            ; kernel.bin所在扇区号
   mov ebx,KERNEL_BIN_BASE_ADDR           ; 从磁盘读出后，写入到ebx指定的地址
   mov ecx,200                            ; 读入的扇区数

   call rd_disk_m_32					  ; 用于从硬盘上读取文件 与 mbr.S 中的 rd_disk_m_16 相似，将16位寄存器修改为32位寄存即可

                                          ; -------------------------- 建立页表 --------------------------
                                          ; 创建页目录及页表并初始化页内存位图
   call setup_page

   sgdt [gdt_ptr]

   mov ebx,[gdt_ptr+2]

   or dword [ebx+0x18+4],0xc0000000
   add dword [gdt_ptr+2],0xc0000000

   add esp,0xc0000000

   mov eax,PAGE_DIR_TABLE_POS
   mov cr3,eax

   mov eax,cr0
   or eax,0x80000000
   mov cr0,eax

   lgdt [gdt_ptr]

   mov eax,SELECTOR_VIDEO
   mov gs,eax

   jmp SELECTOR_CODE:enter_kernel

                                          ; ---------------------- 跳转到kernel -----------------------
enter_kernel:
   call kernel_init
   mov esp,0xc009f000
   jmp KERNEL_ENTER_ADDR

                                          ; ------------------------ 创建页表 ------------------------
setup_page:
   mov ecx,4096
   mov esi,0
.clear_page_dir:
   mov byte [PAGE_DIR_TABLE_POS+esi],0
   inc esi
   loop .clear_page_dir

                                          ; 创建页目录项(PDE)
.create_pde:
   mov eax,PAGE_DIR_TABLE_POS
   add eax,0x1000                         ; 此时的eax为第一个页表的物理地址
   mov ebx,eax                            ; ebx=eax，为后续的.create_pte做准备，ebx为基址

                                          ; 下面将偏移地址0x0（第1个）和0xc00（第768个页目录项）存为第1个页表的地址，每个页表表示4MB内存
   or eax,PG_US_U|PG_RW_W|PG_P            ; 最低特权级|可读写|存在
   mov [PAGE_DIR_TABLE_POS+0x0],eax       ; 第1个页目录项
   mov [PAGE_DIR_TABLE_POS+0xc00],eax     ; 第768个页目录项
   sub eax,0x1000
   mov [PAGE_DIR_TABLE_POS+4092],eax      ; 最后一个页目录项指向页目录自己

                                          ; 创建页表项(PTE)
   mov ecx,256                            ; 对低端内存1MB建页表：1MB/4KB=256（256个页表项，1个页表足矣）
   mov esi,0
   mov edx,PG_US_U|PG_RW_W|PG_P           ; 最低特权第|可读写|存在
.create_pte:
   mov [ebx+esi*4],edx                    ; 逐个页表项设置
   add edx,4096                           ; 因为1个页表4KB，所以edx的基址+4KB
   inc esi
   loop .create_pte

                                          ; 创建内核其它页表的PDE
   mov eax,PAGE_DIR_TABLE_POS
   add eax,0x2000                         ; 此时的eax为第二个页表的物理地址
   or eax,PG_US_U|PG_RW_W|PG_P            ; 最低特权级|可读写|存在
   mov ebx,PAGE_DIR_TABLE_POS
   mov ecx,254
   mov esi,769
.create_kernel_pde:
   mov [ebx+esi*4],eax                   ; 将第2个~第256个页表的地址逐个存入页表项
   inc esi
   add eax,0x1000                        ; 下一个页表的地址
   loop .create_kernel_pde

   ret

                                          ; ------ 初始化内核 把缓冲区的内核代码放到0x1500区域 ------
kernel_init:
   xor eax,eax
   xor ebx,ebx                            ; ebx记录程序头表地址
   xor ecx,ecx                            ; cx记录程序头表中的program header数量
   xor edx,edx                            ; dx记录program header尺寸，即e_phentsize

   mov dx,[KERNEL_BIN_BASE_ADDR+42]       ; 偏移文件42字节处的属性是e_phentsize，表示program header大小
   mov ebx,[KERNEL_BIN_BASE_ADDR+28]      ; 偏移文件28字节处是e_phoff，表示第一个program>在文件中的偏移量
   add ebx,KERNEL_BIN_BASE_ADDR
   mov cx,[KERNEL_BIN_BASE_ADDR+44]       ; 偏移文件44字节处是e_phnum，表示有几个program header
.each_segment:
   cmp byte [ebx+0],PT_NULL               ; 若p_type等于PT_NULL，说明此program header未使用
   je .PTNULL

   mov eax,[ebx+8]
   mov esi,0xc0001500
   cmp eax,esi
   jb .PTNULL

                                          ; 为函数memcpy压入参数，参数是从右往左依次压入，函数原型类似于memcpy(dst,src,size)
   push dword [ebx+16]                    ; 偏移16字节的地方是p_filesz，压入函数memcpy的第三个参数：size
   mov eax,[ebx+4]                        ; 偏移4字节的位置是p_offset
   add eax,KERNEL_BIN_BASE_ADDR           ; 加上kernel.bin被加载到的物理地址，eax为该段的物理地址
   push eax                               ; 压入函数memcpy的第二个参数：src
   push dword [ebx+8]                     ; 压入函数memcpy的第三个参数：dst，偏移量为8字节的位置是p_vaddr
   call mem_cpy                           ; 调用memcpy完成段复制
   add esp,12                             ; 清理栈中压入的三个参数
.PTNULL:
   add ebx,edx                            ; edx为program header大小，即e_phentsize，ebx指向下一个program_header
   loop .each_segment
   ret

mem_cpy:
   cld
   push ebp
   mov ebp,esp
   push ecx                               ; rep指令需要ecx，但ecx还此时用于外循环中，所以先push保存一下
   mov edi,[ebp+8]
   mov esi,[ebp+12]
   mov ecx,[ebp+16]
   rep movsb                              ; 逐字节拷贝

                                          ; 恢复
   pop ecx
   pop ebp
   ret

                                          ; ------ rd_disk_m_32，类似于mbr.S中的rd_disk_m_16 ------
rd_disk_m_32:
                                          ; 1 写入待操作磁盘数
                                          ; 2 写入LBA 低24位寄存器 确认扇区
                                          ; 3 device 寄存器 第4位主次盘 第6位LBA模式 改为1
                                          ; 4 command 写指令
                                          ; 5 读取status状态寄存器 判断是否完成工作
                                          ; 6 完成工作 取出数据

                                          ; 1 写入待操作磁盘数
   mov esi,eax                            ; !!! 备份eax
   mov di,cx                              ; !!! 备份cx

   mov dx,0x1F2                           ; 0x1F2为Sector Count 端口号 送到dx寄存器中
   mov al,cl                              ; !!! 忘了只能由ax al传递数据
   out dx,al                              ; !!! 这里修改了 原out dx,cl

   mov eax,esi                            ; !!!原来备份是这个用 前面需要ax来传递数据 麻了

                                          ; 2 写入LBA 24位寄存器 确认扇区
   mov cl,0x8                             ; shr 右移8位 把24位给送到 LBA low mid high 寄存器中

   mov dx,0x1F3                           ; LBA low
   out dx,al

   mov dx,0x1F4                           ; LBA mid
   shr eax,cl                             ; eax为32位 ax为16位 eax的低位字节 右移8位即8~15
   out dx,al

   mov dx,0x1F5
   shr eax,cl
   out dx,al

                                          ; 3 device 寄存器 第4位主次盘 第6位LBA模式 改为1
                                          ; 24 25 26 27位 尽管我们知道ax只有2 但还是需要按规矩办事
                                          ; 把除了最后四位的其他位置设置成0
   shr eax,cl

   and al,0x0f
   or al,0xe0                             ; !!! 把第四-七位设置成0111 转换为LBA模式
   mov dx,0x1F6                           ; 参照硬盘控制器端口表 Device
   out dx,al

                                          ; 4 向Command写操作 Status和Command一个寄存器
   mov dx,0x1F7                           ; Status寄存器端口号
   mov ax,0x20                            ; 0x20是读命令
   out dx,al

                                          ; 5 向Status查看是否准备好惹
                                          ; 设置不断读取重复 如果不为1则一直循环
.not_ready:
   nop                                    ; !!! 空跳转指令 在循环中达到延时目的
   in al,dx                               ; 把寄存器中的信息返还出来
   and al,0x88                            ; !!! 0100 0100 0x88
   cmp al,0x08
   jne .not_ready                         ; !!! jump not equal == 0

                                          ; 6 读取数据
   mov ax,di                              ; 把 di 储存的cx 取出来
   mov dx,256
   mul dx                                 ; 与di 与 ax 做乘法 计算一共需要读多少次 方便作循环 低16位放ax 高16位放dx
   mov cx,ax                              ; loop 与 cx相匹配 cx-- 当cx == 0即跳出循环
   mov dx,0x1F0
.go_read_loop:
   in ax,dx                               ; 两字节dx 一次读两字
   mov [ebx],ax
   add ebx,2
   loop .go_read_loop
   ret
```

### 特权级

CPU总是在执行代码，代码总是处于某个段中，CS有自己的值，CS中的RPL位就是CPU当前的CPL。当这一段代码想要跳转到另一段代码中执行时，就需要加载另一段代码的选择子去GDT中查找对应的段描述符，段描述符中有被访问代码的DPL值，CPU就根据当前的CPL，与目的代码段的DPL做比较，来进行访问限制实现安全检查。理论上CPL<=DPL（数值）才能访问某个段，但实际上只允许平级访问。因为特权级低代码能做的事情，高特权级代码也能做。所以根本不会出现由特权级高代码切换到特权级低代码这种情况（除了中断返回）。而且特权级低代码肯定不能直接切换到特权级高的代码，自然就只能平级访问。但是仅仅依靠CPL与DPL是不够的，典型场景就是一个应用通过系统调用去操作操作系统的数据，在这种情况下是绝对不允许的。因此又引入了RPL，RPL是这个应用要加载的段描述符选择子的RPL位的值，比如刚刚那个场景，应用为了操作操作系统的数据，那么加载到ds中的段描述符选择子的RPL是0，但是应用此时的CPL是3，因此CPU就能通过CPL与RPL的差异来判断应用想要搞鬼，所以就会强行将加载到ds中的段描述符的选择子的RPL改为应用的CPL。

CPU的初始CPL是在保护模式开启时（只有保护模式开启时，才有特权级这一概念）初始化的。因为当我们BIOS加载MBR，MBR加载loader并执行时，需要用到一句jmp 0:loader_start，后面保护模式开启后，现在的CS值是全0（虽然这是个非法段描述符选择子），我们需要用jmp SLE_CODE:p_mode_start，来刷新流水线，CPU会将当前的CS（值为全0）当做一个段描述符选择子，其中的RPL是0，也就是CPU的CPL是0，然后将SLE_CODE作为选择子查段描述符，对应的段描述符（我们设置的）中的DPL为0，cpu允许跳转。然后跳转之后的段的CS值的RPL，又成为当前CPU的CPL，这样CPL就被初始化为0了。

一致性代码段能够实现低特权级访问高特权级，但不会改变CPU的CPL，cpu的CPL仍然以访问前的低特权级代码的RPL。所以一致性代码段的DPL实际上是访问特权级的上限。也就是DPL=1，那么CPL=1,2，3都可以访问（=0应该也可以访问，只是一般没必要）。

同样的逻辑可以用于eflags的IOPL位，与IO位图来实现应用对端口（硬件）操作的安全性检查。

### 函数调用约定

在高级语言中，参数压栈顺序问题和栈空间的清理工作，这两个问题是通过调用约定来解决的，调用约定就是调用方和被调用方就以上问题达 成一致解决方案的约定，双方按照这种约定合作就不会发生问题。

![调用约定简述表](/home/zhj/.config/Typora/typora-user-images/image-20240803151537528.png)

### 汇编语言和 C 语言混合编程

- 汇编语言和 C 语言可以互相调用。

- 在汇编代码中导出符号供外部引用是用的关键字 global，引用外部文件的符号是用的关键字 extern。 
- 在 C 代码中只要将符号定义为全局便可以被外部引用，引用外部符号时用 extern 声明即可。

### 实现自己的打印函数

通过对显存段操作，我们能够在屏幕上显示字符，通过与显卡寄存器打交道，我们可以获得光标位置，结合上述两个步骤能够实现我们平常见的那种在光标处显示字符，数字，字符串，然后光标向后移动的效果。光标位置需要与VGA寄存器（显卡的寄存器）中CRT Controller Registers组中索引号为0Eh与0Fh寄存器来打交道。

![VGA寄存器表](/home/zhj/.config/Typora/typora-user-images/image-20240803152616459.png)

![CRT控制器数据寄存器表](/home/zhj/.config/Typora/typora-user-images/image-20240803152759220.png)

编写数据类型声明(yourPath/chapter6/lib/stdint.h)

```C
#ifndef __LIB_STDINT_H 
#define __LIB_STDINT_H 
typedef signed char int8_t; 
typedef signed short int int16_t; 
typedef signed int int32_t; 
typedef signed long long int int64_t; 
typedef unsigned char uint8_t; 
typedef unsigned short int uint16_t; 
typedef unsigned int uint32_t; 
typedef unsigned long long int uint64_t; 
#endif
```

编写函数声明(yourPath/chapter6/lib/kernel/print.h)

```c
#ifndef __LIB_KERNEL_PRINT_H 
#define __LIB_KERNEL_PRINT_H 
#include "stdint.h" 
void put_char(uint8_t char_asci);
void put_str(char* message);
void put_int(uint32_t num);
#endif 
```

编写函数实现(yourPath/chapter6/lib/kernel/print.S)

```asm
TI_GDT equ  0                                               ; 从这里开始三步是在定义显存段段描述符的选择子
RPL0  equ   0
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0
section .data 
put_int_buffer dq 0 ; 定义 8 字节缓冲区用于数字到字符的转换

[bits 32]
section .text
                                                            ; --------------------------------------------
                                                            ; put_str 通过put_char来打印以0字符结尾的字符串
                                                            ; --------------------------------------------
                                                            ; 输入：栈中参数为打印的字符串
                                                            ; 输出：无

global put_str
put_str:
                                                            ; 由于本函数中只用到了ebx和ecx,只备份这两个寄存器
    push ebx
    push ecx
    xor ecx, ecx		                                    ; 准备用ecx存储参数,清空
    mov ebx, [esp + 12]	                                    ; 从栈中得到待打印的字符串地址 
.goon:
    mov cl, [ebx]                                           ; ebx是字符串的地址，对地址进行取地址操作，然后取出一字节的数据，就是取出了字符串的第一个字符
    cmp cl, 0		                                        ; 如果处理到了字符串尾,跳到结束处返回
    jz .str_over
    push ecx		                                        ; 为put_char函数传递参数
    call put_char
    add esp, 4		                                        ; 回收参数所占的栈空间
    inc ebx		                                            ; 使ebx指向下一个字符
    jmp .goon
.str_over:
    pop ecx
    pop ebx
    ret


[bits 32]                                                   ; 采用32位编译
section .text                                               ; 表明这是个代码段
                                                            ; ------------------------   put_char   -----------------------------
                                                            ; 功能描述:把栈中的1个字符写入光标所在处
                                                            ; -------------------------------------------------------------------   
global put_char                                             ; 将put_char导出为全局符号，这样其他文件也可以使用
put_char:
    pushad	                                                ; 备份32位寄存器环境
                                                                ; 需要保证gs中为正确的视频段选择子,为保险起见,每次打印时都为gs赋值
    mov ax, SELECTOR_VIDEO	                                ; 不能直接把立即数送入段寄存器
    mov gs, ax

                                                            ; ------  获取当前光标位置 ------
                                                            ; 先获得高8位
    mov dx, 0x03d4                                          ; 索引寄存器
    mov al, 0x0e	                                        ; 用于提供光标位置的高8位
    out dx, al
    mov dx, 0x03d5                                          ; 通过读写数据端口0x3d5来获得或设置光标位置 
    in al, dx	                                            ; 得到了光标位置的高8位
    mov ah, al

                                                            ; 再获取低8位
    mov dx, 0x03d4
    mov al, 0x0f
    out dx, al
    mov dx, 0x03d5 
    in al, dx                                                  
    mov bx, ax	                                            ; 现在bx中存的是光标的位置
                                                            ; 下面这行是在栈中获取待打印的字符
    mov ecx, [esp + 36]	                                    ; pushad压入4×8＝32字节,加上主调函数的返回地址4字节,故esp+36字节,现在ecx中是要打印的字符
    cmp cl, 0xd				                                ; 判断是否是CR(回车)0x0d
    jz .is_carriage_return
    cmp cl, 0xa                                             ; 判断是否是LF(换行)0x0a
    jz .is_line_feed

    cmp cl, 0x8				                                ; 判断是否是BS(backspace退格)的asc码8
    jz .is_backspace
    jmp .put_other	    

.is_backspace:		      
                                                            ; ------ backspace的一点说明 ------
                                                            ; 当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符
                                                            ; 但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处,
                                                            ; 这就显得好怪异,所以此处添加了空格或空字符0
    dec bx                                                  ; 光标位置-1, 以符合我们的常识认知, 即按下退格符, 光标回退
    shl bx,1                                                ; 光标的位置就转换成了对应字符的显存位置的偏移
    mov byte [gs:bx], 0x20		                            ; 将待删除的字节补为0或空格皆可, 0x20是空格符的ascii码值 
    inc bx                                                  ; bx+1, 指向这个字符的属性位置, 也就是设定背景色, 字符颜色
    mov byte [gs:bx], 0x07                                  ; 0x07, 就是黑底白字
    shr bx,1                                                ; bx虽然指向这个字符的颜色属性字节，但是除以2还是变回这个字符的光标位置
    jmp .set_cursor                                         ; 去设置光标位置, 这样光标位置才能真正在视觉上更新

 .put_other:
    shl bx, 1				                                ; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节
    mov [gs:bx], cl			                                ; ascii字符本身
    inc bx
    mov byte [gs:bx],0x07		                            ; 字符属性
    shr bx, 1				                                ; 恢复老的光标值
    inc bx				                                    ; 下一个光标值
    cmp bx, 2000		   
    jl .set_cursor			                                ; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值
					                                        ; 若超出屏幕字符数大小(2000)则换行处理
.is_line_feed:				                                ; 是换行符LF(\n)
.is_carriage_return:			                            ; 是回车符CR(\r)
					                                        ; 如果是CR(\r),只要把光标移到行首就行了。
    xor dx, dx				                                ; 要进行16位除法，高16位置会放在dx中，要先清零
    mov ax, bx				                                ; ax是被除数的低16位.
    mov si, 80				                                ; 用si寄存器来存储除数80 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，
    div si				                                    ; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。ax/80后，ax中存商，dx中存储的是余数,汇编除法https://blog.csdn.net/loovejava/article/details/7044242
    sub bx, dx				                                ; 光标值减去除80的余数便是取整
					                                        ; 以上4行处理\r的代码

 .is_carriage_return_end:		                            ; 回车符CR处理结束
    add bx, 80
    cmp bx, 2000
 .is_line_feed_end:			                                ; 若是LF(\n),将光标移+80便可。  
    jl .set_cursor

                                                            ; 屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充
.roll_screen:				                                ; 若超出屏幕大小，开始滚屏
    cld                                                     
    mov ecx, 960				                            ; 一共有2000-80=1920个字符要搬运,共1920*2=3840字节.一次搬4字节,共3840/4=960次 
    mov esi, 0xb80a0			                            ; 第1行行首
    mov edi, 0xb8000			                            ; 第0行行首
    rep movsd				                                ; rep movs word ptr es:[edi], word ptr ds:[esi] 简写为: rep movsw

                                                            ; 将最后一行填充为空白
    mov ebx, 3840			                                ; 最后一行首字符的第一个字节偏移= 1920 * 2
    mov ecx, 80				                                ; 一行是80字符(160字节),每次清空1字符(2字节),一行需要移动80次
 .cls:
    mov word [gs:ebx], 0x0720		                        ; 0x0720是黑底白字的空格键
    add ebx, 2
    loop .cls 
    mov bx,1920				                                ; 将光标值重置为1920,最后一行的首字符.

.set_cursor:   
					                                        ; 将光标设为bx值
                                                            ; ------ 1 先设置高8位 ------
    mov dx, 0x03d4			                                ; 索引寄存器
    mov al, 0x0e				                            ; 用于提供光标位置的高8位
    out dx, al
    mov dx, 0x03d5			                                ; 通过读写数据端口0x3d5来获得或设置光标位置 
    mov al, bh
    out dx, al

                                                            ; ------ 2 再设置低8位 ------
    mov dx, 0x03d4
    mov al, 0x0f
    out dx, al
    mov dx, 0x03d5 
    mov al, bl
    out dx, al
.put_char_done: 
    popad
    ret


[bits 32]
section .text
                                                            ; --------------------   将小端字节序的数字变成对应的ascii后，倒置   -----------------------
                                                            ; 输入：栈中参数为待打印的数字
                                                            ; 输出：在屏幕上打印16进制数字,并不会打印前缀0x,如打印10进制15时，只会直接打印f，不会是0xf
                                                            ; ------------------------------------------------------------------------------------------
global put_int
put_int:
    pushad
    mov ebp, esp
    mov eax, [ebp+4*9]		                                ; call的返回地址占4字节+pushad的8个4字节，现在eax中就是要显示的32位数值
    mov edx, eax                                            ; ebx中现在是要显示的32位数值
    mov edi, 7                                              ; 指定在put_int_buffer中初始的偏移量，也就是把栈中第一个字节取出放入buffer最后一个位置，第二个字节放入buff倒数第二个位置
    mov ecx, 8			                                    ; 32位数字中,16进制数字的位数是8个
    mov ebx, put_int_buffer                                 ; ebx现在存储的是buffer的起始地址

                                                            ; 将32位数字按照16进制的形式从低位到高位逐个处理,共处理8个16进制数字
.16based_4bits:			                                    ; 每4位二进制是16进制数字的1位,遍历每一位16进制数字
    and edx, 0x0000000F		                                ; 解析16进制数字的每一位。and与操作后,edx只有低4位有效
    cmp edx, 9			                                    ; 数字0～9和a~f需要分别处理成对应的字符
    jg .is_A2F 
    add edx, '0'			                                ; ascii码是8位大小。add求和操作后,edx低8位有效。
    jmp .store
.is_A2F:
    sub edx, 10			                                    ; A~F 减去10 所得到的差,再加上字符A的ascii码,便是A~F对应的ascii码
    add edx, 'A'

                                                            ; 将每一位数字转换成对应的字符后,按照类似“大端”的顺序存储到缓冲区put_int_buffer
                                                            ; 高位字符放在低地址,低位字符要放在高地址,这样和大端字节序类似,只不过咱们这里是字符序.
.store:
    mov [ebx+edi], dl		                                ; 此时dl中是数字对应的字符的ascii码
    dec edi                                                 ; edi是表示在buffer中存储的偏移，现在向前移动
    shr eax, 4                                              ; eax中是完整存储了这个32位数值，现在右移4位，处理下一个4位二进制表示的16进制数字
    mov edx, eax                                            ; 把eax中的值送入edx，让edx去处理
    loop .16based_4bits

                                                            ; 现在put_int_buffer中已全是字符,打印之前,
                                                            ; 把高位连续的字符去掉,比如把字符00000123变成123
.ready_to_print:
    inc edi			                                        ; 此时edi退减为-1(0xffffffff),加1使其为0
.skip_prefix_0:                                             ; 跳过前缀的连续多个0
    cmp edi,8			                                    ; 若已经比较第9个字符了，表示待打印的字符串为全0 
    je .full0 
                                                            ; 找出连续的0字符, edi做为非0的最高位字符的偏移
.go_on_skip:   
    mov cl, [put_int_buffer+edi]
    inc edi
    cmp cl, '0' 
    je .skip_prefix_0		                                ; 继续判断下一位字符是否为字符0(不是数字0)
    dec edi			                                        ; edi在上面的inc操作中指向了下一个字符,若当前字符不为'0',要恢复edi指向当前字符		       
    jmp .put_each_num

.full0:
    mov cl,'0'			                                    ; 输入的数字为全0时，则只打印0
.put_each_num:
    push ecx			                                    ; 此时cl中为可打印的字符
    call put_char
    add esp, 4
    inc edi			                                        ; 使edi指向下一个字符
    mov cl, [put_int_buffer+edi]	                        ; 获取下一个字符到cl寄存器
    cmp edi,8                                               ; 当edi=8时，虽然不会去打印，但是实际上已经越界访问缓冲区了
    jl .put_each_num
    popad
    ret
```

### 内联汇编

基本内联汇编

```c
asm [volatile] ("assembly code") 
```

assembly code 规则：

- 指令必须用双引号引起来，无论双引号中是一条指令或多条指令。
- 一对双引号不能跨行，如果跨行需要在结尾用反斜杠'\'转义。
- 指令之间用分号'；'、换行符'\n'或换行符加制表符'\n''\t'分隔。

扩展内联汇编

```c
asm [volatile] (“assembly code”:output : input : clobber/modify)
```

- 寄存器约束

  - a：表示寄存器 eax/ax/al  
  - b：表示寄存器 ebx/bx/bl  
  - c：表示寄存器 ecx/cx/cl  
  - d：表示寄存器 edx/dx/dl
  - D：表示寄存器 edi/di  
  - S：表示寄存器 esi/si  
  - q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx  
  - r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi  
  - g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中 
  - A：把 eax 和 edx 组合成 64 位整数 
  - f：表示浮点寄存器 
  - t：表示第 1 个浮点寄存器 
  - u：表示第 2 个浮点寄存器

- 内存约束

  - m：表示操作数可以使用任意一种内存形式。
  - o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含 offset_address 的格式。

- 立即数约束

  - i：表示操作数为整数立即数 
  - F：表示操作数为浮点数立即数 
  - I：表示操作数为 0～31 之间的立即数 
  - J：表示操作数为 0～63 之间的立即数 
  - N：表示操作数为 0～255 之间的立即数 
  - O：表示操作数为 0～32 之间的立即数 
  - X：表示操作数为任何类型立即数

- 通用约束

  0～9：此约束只用在 input 部分，但表示可与 output 和 input 中第 n 个操作数用相同的寄存器或内存。

- 序号占位符

  序号占位符是对在 output 和 input 中的操作数，按照它们从左到右出现的次序从 0 开始编号，一直到 9，也就是说最多支持 10 个序号占位符。 操作数用在 assembly code 中，引用它的格式是%0～9。

- 名称占位符

  名称占位序需要在 output 和 input 中把操作数显式地起个名字，它用这样的格式来标识操作数： [名称]”约束名”（C 变量） 这样，该约束对应的汇编操作数便有了名字，在 assembly code 中引用操作数时，采用%[名称]的形式就可以了。

扩展内联汇编之机器模式

- 机器模式用来在机器层面上指定数据的大小及格式。

- 机器模式是用枚举类型 enum machine_mode 来定义的。

  ![机器模式的枚举定义图](/home/zhj/.config/Typora/typora-user-images/image-20240803160534752.png)

- 机器模式名称的结构大致是这样的：数据大小+数据类型+mode。

  ![整型机器模式示意图](/home/zhj/.config/Typora/typora-user-images/image-20240803160613073.png)

## 中断

### 什么是中断，为什么要有中断

由于 CPU 获知了计算机中发生的某些事，CPU 暂停正在执行的程序，转而去执行处理该事件的程序， 当这段程序执行完毕后，CPU 继续执行刚才的程序。整个过程称为中断处理，也称为中断。

运行中断能显著提高并发，大幅度提升效率。

### 操作系统是由中断驱动的

操作系统是一个死循环，它负责等待事件的发生，这个等待说明操作系统是被动工作的，有事情发生它才会工 作，所以它是被事件驱动的，而这个事件是以中断的形式通知操作系统的，所以说操作系统是由中断驱动的。

### 中断的分类

- 外部中断(硬件中断)

  外部硬件的中断是通过两根信号线通知 CPU 的，这两根信号线就是 INTR（INTeRrupt）和 NMI（Non Maskable Interrupt）。

  ![外部中断](/home/zhj/.config/Typora/typora-user-images/image-20240809144826470.png)

  外部中断分为两种，可屏蔽中断( INTR 传入)和不可屏蔽中断 ( NMI 传入)。

  中断处理程序也就是中断，其实在CPU中是由两部分组成，把中断处理程序中需要立即执行的部分（分分钟不能耽误的部分）划分到上半部，这部分是要限时执行的，所以通常情况下只完成中断应答或硬件复位等重要紧迫的工作。而中断处理程序中那些不紧急的部分则被推迟到下半部中去完成。所以说，，中断的上半部分在关中断的情况下进行的，而中断的下半部分是在开中断的情况下进行的，也就是说，如果此时有新的中断产生，那么旧中断的下半部分会被换下CPU，CPU转而去执行的新中断的上半部分，旧中断的下半部分，等待线程调度机制为旧其择一日期（就是指调度算法认为的某个恰当时机）后，再调度其上 CPU 完成其下半部的执行。

  中断种类多样，所以需要CPU在收到中断后，得知道发生了什么事情才能执行相应的处理办法。这是通过中断向量表或中断描述 符表（中断向量表是实模式下的中断处理程序数组，在保护模式下已经被中断描述符表代替，在后面章节 中会细说）来实现的，首先为每一种中断分配一个中断向量号，中断向量号就是一个整数，它就是中断向 量表或中断描述符表中的索引下标，用来索引中断项。中断发起时，相应的中断向量号通过 NMI 或 INTR 引脚被传入 CPU，中断向量号是中断向量表或中断描述符表里中断项的下标，CPU 根据此中断向量号在 中断向量表或中断描述符表中检索对应的中断处理程序并去执行。

  可屏蔽中断一般不会造成致命的问题，比如系统宕机，所以每一种中断源由对应一个中断向量号，而不可屏蔽中断所造成的后果一般不可忽略，所以只为不可屏蔽中断分配了一个中断向量号，即为2 。

- 内部中断

  内部中断分为两种，软中断和异常。

  软中断：由软件主动发起的中断，因为它来自于软件，所以称之为软中断。由于该中断是软件运 行中主动发起的，所以它是主观上的，并不是客观上的某种内部错误。

  -  int 8位立即数  常用于系统调用，8 位立即数可表示 256 种中断，这与处理器所支持的中断数是相吻合的
  - int3 断点调试指令 触发中断向量号为 3 的中断
  - into 中断溢出指令 触发中断向量号为 4 的中断 能否引发 4 号中断是要看 eflags 标志寄存器中的 OF 位是否为 1，如果是 1 才会引发中断，否则无事发生
  - bound 数组索引越界指令 触发中断向量号为 5 的中断，用于检测数组索引下标是否在数组的上下边界内 
  - ud2 未定义指令 触发中断向量号为 6 的中断，表示指令无效，CPU无法识别指令，主动使用它发 起中断，常用于软件测试中，无实际用途。

  只要中断关系到“正常”运行，就不受 IF 位影响：
  
  - 只要是导致运行错误的中断类型都会无视 IF 位，不受 IF 位的管束，如 NMI、异常。 
  - 由于 int n 型的软中断用于实现系统调用功能，不能因为 IF 位为 0 就不顾用户请求，所以为了用户功能正常，软中断必须也无视 IF 位。

  异常：
  
  - Fault，也称为故障。这种错误是可以被修复的一种类型，属于最轻的一种异常，它给软件一次“改 过自新”的机会。当发生此类异常时 CPU 将机器状态恢复到异常之前的状态，之后调用中断处理程序时， CPU 将返回地址依然指向导致 fault 异常的那条指令。通常中断处理程序中会将此问题修复，待中断处理 程序返回后便能重试。最典型的例子就是操作系统课程中所说的缺页异常 page fault，话说 Linux 的虚拟内 存就是基于 page fault 的，这充分说明这种异常是极易被修复的，甚至是有益的。 
  - Trap，也称为陷阱，这一名称很形象地说明软件掉进了 CPU 设下的陷阱，导致停了下来。此异 常通常用在调试中，比如 int3 指令便引发此类异常，为了让中断处理程序返回后能够继续向下执行，CPU 将中断处理程序的返回地址指向导致异常指令的下一个指令地址。 
  - Abort，也称为终止，从名字上看，这是最严重的异常类型，一旦出现，由于错误无法修复，程 序将无法继续运行，操作系统为了自保，只能将此程序从进程表中去掉。导致此异常的错误通常是硬件错误，或者某些系统数据结构出错。
  
  ![异常与中断表](/home/zhj/.config/Typora/typora-user-images/image-20240809162207149.png)

### 中断描述符表

中断描述符表是保护模式下用于存储中断处理程序入口的表，通过中断向量索引对应的描述符，在该描述符中找到中断处理程序的起始地址，然后执行中断处理程序。

中断向量表是实模式下用于存储中断处理程序入口的表，通过中断向量索引。

中断描述符符表中不仅有中断描述符，还有任务门描述符，陷阱门描述符，这些描述符都指向一段地址的起始地址，所以这些描述符也被称作门。

![任务门描述符格式图](/home/zhj/.config/Typora/typora-user-images/image-20240812091632220.png)

![中断门描述符格式图](/home/zhj/.config/Typora/typora-user-images/image-20240812091743517.png)

![陷阱门和调用门描述符格式图](/home/zhj/.config/Typora/typora-user-images/image-20240812091825001.png)

1．任务门：

任务门和任务状态段（Task Status Segment，TSS）是 Intel 处理器在硬件一级提供的任务切换机制，所以任务门需要和 TSS 配合在一起使用，在任务门中记录的是 TSS 选择子，偏移量未使用。任务门可以存在于全局描述符表 GDT、局部描述符表 LDT、中断描述符表 IDT 中。描述符中任务门的 type 值为二进制 0101，大多数操作系统（包括 Linux）都未用 TSS 实现任务切换。 

2．中断门：

中断门包含了中断处理程序所在段的段选择子和段内偏移地址。当通过此方式进入中断后，标志寄存器 eflags 中的 IF 位自动置 0，也就是在进入中断后，自动把中断关闭，避免中断嵌套。Linux 就是利用中断门实现的系统调用，就是那个著名的 int 0x80。中断门只允许存在于 IDT 中。描述符中中断门的 type 值 为二进制 1110。 

3．陷阱门：一种特殊的中断门

陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器 eflags 中的 IF 位不会自动置 0。 陷阱门只允许存在于 IDT 中。描述符中陷阱门的 type 值为二进制 1111。

4．调用门：

调用门是提供给用户进程进入特权 0 级的方式，其 DPL 为 3。调用门中记录例程的地址，它不能用 int 指令调用，只能用 call 和 jmp 指令。调用门可以安装在 GDT 和 LDT 中。描述符中调用门的 type 值为 二进制 1100。

相比于中断向量表，中断描述符表有以下两个区别：

- 中断描述符表的地址不受限制
- 中断描述符表中的每一个描述符为8字节

### 中断描述符表寄存器(IDTR)

![IDTR结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812093132620.png)

表基址：CPU 通过表基址找到 IDT

表界限：IDT 的大小 -1 范围 0 - 0xffff 即8KB

理论上 IDT 最多可以容纳 8192 个描述符，但处理器只支持 256 个中断，所以其他的描述符不可用，

加载指令：lidt 16 位表界限 + 32 位表基址

### 中断处理过程及保护

完整的中断过程分为 CPU 外和 CPU 内两部分：

- CPU 外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到 CPU。 

- CPU 内：CPU 执行该中断向量号对应的中断处理程序。
  1. 处理器根据中断向量号定位中断门描述符：中断向量号 * 8 + IDTR 中的表基址 = 该中断向量的中断描述符
  2. 处理器进行特权级检查：
     - 下限：当前特权级 CPL  >=  门描述符特权级  DPL
     - 上限：当前特权级 CPL <  门中目标代码段特权级 DPL
  3. 执行中断处理程序：特权级检查通过后，将目标代码段的选择字加载到 CS 中，将目标代码的偏移地址加载到 EIP 中。

![中断的处理过程示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812095600873.png)

中断发生后，eflags 中的 NT 位和 TF 位会被置 0。如果中断对应的门描述符是中断门，标志寄存器 eflags 中的 IF 位被自动置 0，避免中断嵌套，发生保护性异常(GP异常)。如果中断对应的门描述符是陷阱门和任务门，CPU 是不会将 IF 位清 0 的。因为陷阱门主要用 于调试，它允许 CPU 响应更高级别的中断，所以允许中断嵌套。而对任务门来说，这是执行一个新任务， 任务都应该在开中断的情况下进行，否则就独占 CPU 资源，操作系统也会由多任务退化成单任务了。当中断处理程序执行完成后，通过iret进行中断返回。

cli 指令，IF 位置0，关中断。

sti 指令，IF 位置1，开中断。

### 中断发生时的压栈

![中断发生时的压栈过程示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812101537305.png)

涉及特权级转移时，需要切换至高特权级的栈，所以需要先保护旧栈的 SS 和 ESP。

ERROP_CODE：在中段返回时，需要手动跳过错误码。

![操作码结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812102316560.png)

EXT 表示 EXTernal event，即外部事件，用来指明中断源是否来自处理器外部，如果中断源是不可屏蔽中断 NMI 或外部设备，EXT 为 1，否则为 0。 

IDT 表示选择子是否指向中断描述符表 IDT，IDT 位为 1，则表示此选择子指向中断描述符表，否则 指向全局描述符表 GDT 或局部描述符表 LDT。

TI ，表示为 0 时用来指明选择子是从 GDT 中检索描述符，为 1 时是从 LDT 中 检索描述符。

选择子高 13 位索引就是选择子中用来在表中索引描述符用的下标。

### 中断控制器 8259A

用于管理和控制可屏蔽中断，它表现在屏蔽外设中断，对它们实行优先级判决，向 CPU 提供中断向量号等功能。

Intel 处理器支持256个中断，8259A通过级联的方式可以支持64个中断。

![级联示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812113935764.png)

![8259A内部结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812114021486.png)

8259A中断控制器的工作流程：

1. **中断信号接收**：
   - 外设发出中断信号，信号通过主板的中断通路到达8259A中断控制器。

2. **中断屏蔽检查**：
   - 8259A检查IMR（Interrupt Mask Register）寄存器中对应IRQ接口的位。如果该位为1，表示中断被屏蔽，信号被丢弃；如果为0，中断被放行。

3. **中断请求寄存器（IRR）**：
   - 如果中断未被屏蔽，8259A将其送入IRR寄存器，并将对应位置为1，表示待处理中断。

4. **优先级仲裁**：
   - 8259A的优先级仲裁器（PR）从IRR中选择优先级最高的中断（IRQ号越低优先级越高），并将其发送到CPU。

5. **中断请求信号**：
   - 8259A通过INT接口向CPU发送INTR信号，通知CPU有中断请求。

6. **中断响应**：
   - CPU收到INTR信号后，在完成当前指令后，通过INTA接口向8259A发送中断响应信号。

7. **中断向量号获取**：
   - 8259A在收到INTA信号后，将中断向量号通过系统数据总线发送给CPU。中断向量号用于在中断向量表中查找对应的中断处理程序。

8. **执行中断处理程序**：
   - CPU使用中断向量号找到并执行相应的中断处理程序。

9. **中断结束（EOI）**：
   - 如果8259A的EOI通知被设置为手工模式，中断处理程序结束时需要向8259A发送EOI信号，8259A在ISR寄存器中将对应位置为0。
   - 如果EOI通知设置为自动模式，在处理程序执行期间，8259A在收到第二个INTA信号时自动清除ISR中的中断位。

10. **中断替换**：
    - 如果在处理中断时，有优先级更高的新中断到达，8259A将当前处理中断的位清除，将新中断放入ISR，并发送新中断的中断向量号。

通过以上步骤，8259A控制器有效地管理和调度中断请求，确保系统能够正确处理外设的中断信号。

外部设备并不知道中断向量号，外部设备只负责发送中断信号，中断向量号是通过 8259A 发送给 CPU 的。

在硬件构建的中断处理框架基础上，软件层需要做的事：构造好 IDT以及提供中断向量号。

### 8259A 编程

8259A 内部存在两组寄存器，一组为初始化命令寄存器组，用于保存初始化命令字(ICW)，有ICW1-ICW4，共4个寄存器

一组为操作命令寄存器组，用于保存操作命令字(OCW)，有OCW1-OCW3，共3个寄存器。

| 初始化命令寄存器组<br />ICW1 - ICW4 |                                                              |
| ----------------------------------- | ------------------------------------------------------------ |
| ICW1                                | 写入主片 0x20 端口，从片 0xA0 端口 <br />初始化8259A的连接方式和中断信号的触发方式<br />![ICW1格式示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812150224300.png)<br  />IC4：表示是否写入 ICW4，为1，表示写入ICW4，为0，表示不写入ICW4<br   />SNGL：为1，表示单片，为0，表示级联<br />ADI：设置8055的调用时间间隔<br />LTIM：设置中断检测方式，为1，表示电平触发，为0，表示边沿触发 |
| ICW2                                | 写入主片 0x21 端口，从片 0xA1 端口<br />设置起始中断向量号<br />![ICW2格式示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812151934979.png)<br />设置高五位即可，一定是8的倍数，这个数字表示的便是设定的起始中断向量号。 |
| ICW3                                | 写入主片 0x21 端口，从片 0xA1 端口<br />设置主片和从片用哪一个IRQ接口互连<br />主片：ICW3 中置1的那一位对应的IRQ接口用于连接从片，置0，则表示接外部设置<br />从片：设置与8259A的的连接方式，低3位ID0-ID2表示主片用于连接从片的IRQ接口号，高5位置0 |
| ICW4                                | 写入主片 0x21 端口，从片 0xA1 端口<br />用于设置8259A的工作模式，只有ICW1中IC4为1时才需要ICW4<br />![ICW4结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812152844827.png)<br />SFNM：表示特殊全嵌套模式，为0，表示全嵌套模式，为1，表示特殊全嵌套模式<br />BUF：表示是否工作在缓冲模式下，为0，表示工作在非缓冲模式，为1，表示工作在缓冲模式<br />M/S：在缓冲模式下，用来规定主从片，为0，表示为从片，为1，表示主片，在非缓冲模式下，M/S位无效<br />AEOI：表示自动结束中断，为0，表示手动结束中断，为1，表示自动结束中断<br />μPM：表示微处理器类型，用于兼容老处理器，为0，表示8080或8085处理器，为1，表示x86处理器 |

| 操作命令寄存器组        <br /> OCW1-OCW3 |                                                              |
| ---------------------------------------- | ------------------------------------------------------------ |
| OCW1                                     | 写入主片 0x21 端口，从片 0xA1 端口<br />用于屏蔽连接在 8259A 上的外部设备的中断信号，受eflags寄存器中IF位的影响<br />![OCW1g格式示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812154606238.png)<br />某位为 1，对应的 IRQ 上的中断信号就被屏蔽了。否则某位为 0 的话，对应的 IRQ 中断信号则被放行 |
| OCW2                                     | 写入主片 0x20 端口，从片 0xA0 端口<br />用于设置中断结束方式和优先级模式<br />![OCW2结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240812155236363.png)<br />SL：表示是否指定优先等级，为0，表示低3位无效，为1，i示低3位有效<br />R：设置优先级的控制方式，为0，表示固定优先级控制方式，即IRQ 接口号越低，优先级越高。为1，表示循环优先级控制方式，IR（i）优先级最低，IR（i+1)则优先级最高。可以通过将SL位置1，用L2 ～ L0 ，指定最低优先级<br />EOI：表示中断处理结束，为1，表示处理结束，是手动结束中断的做法，如果中断来自主片，只需要向主片发送 EOI 就行了，如果中断来自从片，除了向从片发送 EOI 以外，还要再向主片发送 EOI。 |
| OCW3                                     | 写入主片的0x20端口或从片的0xA0端口<br />用来设定特殊屏蔽方式及查询方式 |

### 编写中断处理程序

![启用中断的流程](/home/zhj/.config/Typora/typora-user-images/image-20240812162154316.png)

init_all()：main函数调用，用来初始化所有的设备及数据结构

idt_init()：初始化中断内容

pic_init()：初始化 8259A 中断控制器

idt_desc_init()：初始化中断描述符表 IDT

加载 IDT

创建中断处理函数(yourPath/chapter7/a/kernel/kernel.S)：创建了33个中断处理程序。33=20+12+1，0-19中断号为处理器内部固定的异常类型，20-31是Intel保留的。同时为了演示中断机理，写一个时钟中断处理程序，所以共33个。

```ASM
[bits 32]
%define ERROR_CODE nop		                ; 有些中断进入前CPU会自动压入错误码(32位),为保持栈中格式统一,这里不做操作.
%define ZERO push 0		                    ; 有些中断进入前CPU不会压入错误码,对于这类中断,我们为了与前一类中断统一管理,就自己压入32位的0
extern put_str			                    ; 声明外部函数，为的是调用put_str

section .data
intr_str db "interrupt occur!", 0xa, 0      ; 第二个是一个换行符，第三个定义一个ascii码为0的字符，用来表示字符串的结尾
global intr_entry_table
intr_entry_table:                           ; 编译器会将之后所有同属性的section合成一个大的segment，所以这个标号后面会聚集所有的中断处理程序的地址

%macro VECTOR 2                             ; 汇编中的宏用法
section .text                               ; 中断处理函数的代码段
intr%1entry:		                        ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少,此标号来表示中断处理程序的入口
    %2                                      ; 这一步是根据宏传入参数的变化而变化的
    push intr_str
    call put_str
    add esp,4			                    ; 抛弃调用put_str压入的字符串地址参数

                                            ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI 
    mov al,0x20                             ; 中断结束命令EOI
    out 0xa0,al                             ; 向主片发送OCW2,其中EOI位为1，告知结束中断，详见书p317
    out 0x20,al                             ; 向从片发送OCW2,其中EOI位为1，告知结束中断

    add esp,4			                    ; 对于会压入错误码的中断会抛弃错误码（这个错误码是执行中断处理函数之前CPU自动压入的），对于不会压入错误码的中断，就会抛弃上面push的0
    iret				                    ; 从中断返回,32位下等同指令iretd

section .data                               ; 这个段就是存的此中断处理函数的地址
    dd    intr%1entry	                    ; 存储各个中断入口程序的地址，形成intr_entry_table数组,定义的地址是4字节，32位
%endmacro

VECTOR 0x00,ZERO                            ; 调用之前写好的宏来批量生成中断处理函数，传入参数是中断号码与上面中断宏的%2步骤，这个步骤是什么都不做，还是压入0看p303
VECTOR 0x01,ZERO
VECTOR 0x02,ZERO
VECTOR 0x03,ZERO 
VECTOR 0x04,ZERO
VECTOR 0x05,ZERO
VECTOR 0x06,ZERO
VECTOR 0x07,ZERO 
VECTOR 0x08,ERROR_CODE
VECTOR 0x09,ZERO
VECTOR 0x0a,ERROR_CODE
VECTOR 0x0b,ERROR_CODE 
VECTOR 0x0c,ZERO
VECTOR 0x0d,ERROR_CODE
VECTOR 0x0e,ERROR_CODE
VECTOR 0x0f,ZERO 
VECTOR 0x10,ZERO
VECTOR 0x11,ERROR_CODE
VECTOR 0x12,ZERO
VECTOR 0x13,ZERO 
VECTOR 0x14,ZERO
VECTOR 0x15,ZERO
VECTOR 0x16,ZERO
VECTOR 0x17,ZERO 
VECTOR 0x18,ERROR_CODE
VECTOR 0x19,ZERO
VECTOR 0x1a,ERROR_CODE
VECTOR 0x1b,ERROR_CODE 
VECTOR 0x1c,ZERO
VECTOR 0x1d,ERROR_CODE
VECTOR 0x1e,ERROR_CODE
VECTOR 0x1f,ZERO 
VECTOR 0x20,ZERO
```

创建中断描述符表 IDT，安装中断处理程序(yourPath/chapter7/a/kernel/interrupt.c)：

```c
#include "interrupt.h"      //里面定义了intr_handler类型
#include "stdint.h"         //各种uint_t类型
#include "global.h"         //里面定义了选择子
#include "io.h"             
#include "print.h"


#define PIC_M_CTRL 0x20	       // 这里用的可编程中断控制器是8259A,主片的控制端口是0x20
#define PIC_M_DATA 0x21	       // 主片的数据端口是0x21
#define PIC_S_CTRL 0xa0	       // 从片的控制端口是0xa0
#define PIC_S_DATA 0xa1	       // 从片的数据端口是0xa1


#define IDT_DESC_CNT 0x21	   //支持的中断描述符个数33

//按照中断门描述符格式定义结构体
struct gate_desc {
   uint16_t    func_offset_low_word;        //函数地址低字
   uint16_t    selector;                    //选择子字段
   uint8_t     dcount;                      //此项为双字计数字段，是门描述符中的第4字节。这个字段无用
   uint8_t     attribute;                   //属性字段
   uint16_t    func_offset_high_word;       //函数地址高字
};

// 静态函数声明,非必须
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function);
static struct gate_desc idt[IDT_DESC_CNT];   //中断门描述符（结构体）数组，名字叫idt

extern intr_handler intr_entry_table[IDT_DESC_CNT];	    //引入kernel.s中定义好的中断处理函数地址数组，intr_handler就是void* 表明是一般地址类型

//此函数用于将传入的中断门描述符与中断处理函数建立映射，三个参数：中断门描述符地址，属性，中断处理函数地址
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
   p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
   p_gdesc->selector = SELECTOR_K_CODE;
   p_gdesc->dcount = 0;
   p_gdesc->attribute = attr;
   p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
}

//此函数用来循环调用make_idt_desc函数来完成中断门描述符与中断处理函数映射关系的建立,传入三个参数：中断描述符表某个中段描述符（一个结构体）的地址
//属性字段，中断处理函数的地址
static void idt_desc_init(void) {
   int i;
   for (i = 0; i < IDT_DESC_CNT; i++) {
      make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
   }
   put_str("   idt_desc_init done\n");
}
```

权限位的定义(yourPath/chapter7/a/kernel/global.h)：

```c
#ifndef __KERNEL_GLOBAL_H
#define __KERNEL_GLOBAL_H
#include "stdint.h"

//选择子的RPL字段
#define	 RPL0  0
#define	 RPL1  1
#define	 RPL2  2
#define	 RPL3  3

//选择子的TI字段
#define TI_GDT 0
#define TI_LDT 1

//定义不同的内核用的段描述符选择子
#define SELECTOR_K_CODE	   ((1 << 3) + (TI_GDT << 2) + RPL0)
#define SELECTOR_K_DATA	   ((2 << 3) + (TI_GDT << 2) + RPL0)
#define SELECTOR_K_STACK   SELECTOR_K_DATA 
#define SELECTOR_K_GS	   ((3 << 3) + (TI_GDT << 2) + RPL0)

//定义模块化的中断门描述符attr字段,attr字段指的是中断门描述符高字第8到16bit
#define	 IDT_DESC_P 1 
#define	 IDT_DESC_DPL0 0
#define	 IDT_DESC_DPL3 3
#define	 IDT_DESC_32_TYPE 0xE   // 32位的门
#define	 IDT_DESC_16_TYPE 0x6   // 16位的门，不用，定义它只为和32位门区分


#define	 IDT_DESC_ATTR_DPL0  ((IDT_DESC_P << 7) + (IDT_DESC_DPL0 << 5) + IDT_DESC_32_TYPE)  //DPL为0的中断门描述符attr字段
#define	 IDT_DESC_ATTR_DPL3  ((IDT_DESC_P << 7) + (IDT_DESC_DPL3 << 5) + IDT_DESC_32_TYPE)  //DPL为3的中断门描述符attr字段

#endif
```

使用内联汇编实现端口IO函数(yourPath/chapter7/a/lib/kernel/io.h)：将内联汇编封装成函数

```c
/******************机器模式 ******************* 
b -- 输出寄存器 QImode 名称，即寄存器中的最低 8 位:[a-d]l 
w -- 输出寄存器 HImode 名称，即寄存器中 2 个字节的部分,如[a-d]x 
HImode 
"Half-Integer"模式，表示一个两字节的整数
QImode 
"Quarter-Integer"模式，表示一个一字节的整数
******************************************************/

#ifndef __LIB_IO_H
#define __LIB_IO_H
#include "stdint.h"

 //一次送一字节的数据到指定端口，static指定只在本.h内有效，inline是让处理器将函数编译成内嵌的方式，就是在该函数调用处原封不动地展开
 //此函数有两个参数，一个端口号，一个要送往端口的数据
 //一次写入 1 个字节的 outb 函数
static inline void outb(uint16_t port, uint8_t data) {
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
}

//利用outsw（端口输出串，一次一字）指令，将ds:esi指向的addr处起始的word_cnt(存在ecx中)个字写入端口port,ecx与esi会自动变化
//一次写入多个字的 outsw 函数，注意，是以 2 字节为单位的
static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {
/*********************************************************
   +表示此限制即做输入又做输出.
   outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, 
   已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
}                                       //S表示寄存器esi/si

/* 将从端口port读入的一个字节返回 */
// 一次读入 1 个字节的 inb 函数
static inline uint8_t inb(uint16_t port) {
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
   return data;
}

/* 将从端口port读入的word_cnt个字写入addr */
//一次读入多个字的 insw 函数，同样以 2 字节为单位
static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {
/******************************************************
   insw是将从端口port处读入的16位内容写入es:edi指向的内存,
   我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,
   此时不用担心数据错乱。*/
   asm volatile ("cld; rep insw" : "+D" (addr), "+c" (word_cnt) : "d" (port) : "memory");
}                                   //D表示寄存器edi/di                       //通知编译器，内存已经被改变了

#endif
```

设置8259A(yourPath/chapter7/a/kernel/interrupt.c)：ICW1-ICW4依次初始化

```c
/* 初始化可编程中断控制器8259A */
static void pic_init(void) {

   /* 初始化主片 */
   outb (PIC_M_CTRL, 0x11);   // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_M_DATA, 0x20);   // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
   outb (PIC_M_DATA, 0x04);   // ICW3: IR2接从片. 
   outb (PIC_M_DATA, 0x01);   // ICW4: 8086模式, 正常EOI

   /* 初始化从片 */
   outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
   outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
   outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI

   /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */
   // OCW
   outb (PIC_M_DATA, 0xfe);
   outb (PIC_S_DATA, 0xff);

   put_str("   pic_init done\n");
}
```

完成初始化，加载IDT，开启中断(yourPath/chapter7/a/kernel/interrupt.c)：

```c
/*完成有关中断的所有初始化工作*/
void idt_init() {
   put_str("idt_init start\n");
   idt_desc_init();	   //调用上面写好的函数完成中段描述符表的构建
   pic_init();		  //设定化中断控制器，只接受来自时钟中断的信号

   /* 加载idt */
   uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));    //定义要加载到IDTR寄存器中的值
   asm volatile("lidt %0" : : "m" (idt_operand));
   put_str("idt_init done\n");
}
```

### 改进中断处理程序

每个中断入口 intrXXentry，都相当于用自己的中断向量号作为 idt_table 中的索引， 于是 intr_entry_table 数组中的每个元素均与 idt_table 中的每个元素 对等，相当于 intr_entry_table[i]调用 idt_table[i]。

![C版本的中断描述符表](/home/zhj/.config/Typora/typora-user-images/image-20240812202049687.png)

注册中断处理函数和异常名称注册以及给出通用的中断处理函数(yourPath/chapter7/b/kernel/interrupt.c)：

```c
char *intr_name[IDT_DESC_CNT];        // 存储中断/异常的名字
intr_handler idt_table[IDT_DESC_CNT]; // 定义中断处理程序数组.在kernel.S中定义的intrXXentry只是中断处理程序的入口,最终调用的是ide_table中的处理程序

/* 通用的中断处理函数,用于初始化,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr)
{
   if (vec_nr == 0x27 || vec_nr == 0x2f)
   { // 伪中断向量，无需处理。详见书p337
      return;
   }
   put_str("int vector: 0x");
   put_int(vec_nr);
   put_char('\n');
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void)
{ // 完成一般中断处理函数注册及异常名称注册
   int i;
   for (i = 0; i < IDT_DESC_CNT; i++)
   {

      /* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
       * 见kernel/kernel.S的call [idt_table + %1*4] */
      idt_table[i] = general_intr_handler; // 默认为general_intr_handler。
                                           // 以后会由register_handler来注册具体处理函数。
      intr_name[i] = "unknown";            // 先统一赋值为unknown
   }
   intr_name[0] = "#DE Divide Error";
   intr_name[1] = "#DB Debug Exception";
   intr_name[2] = "NMI Interrupt";
   intr_name[3] = "#BP Breakpoint Exception";
   intr_name[4] = "#OF Overflow Exception";
   intr_name[5] = "#BR BOUND Range Exceeded Exception";
   intr_name[6] = "#UD Invalid Opcode Exception";
   intr_name[7] = "#NM Device Not Available Exception";
   intr_name[8] = "#DF Double Fault Exception";
   intr_name[9] = "Coprocessor Segment Overrun";
   intr_name[10] = "#TS Invalid TSS Exception";
   intr_name[11] = "#NP Segment Not Present";
   intr_name[12] = "#SS Stack Fault Exception";
   intr_name[13] = "#GP General Protection Exception";
   intr_name[14] = "#PF Page-Fault Exception";
   // intr_name[15] 第15项是intel保留项，未使用
   intr_name[16] = "#MF x87 FPU Floating-Point Error";
   intr_name[17] = "#AC Alignment Check Exception";
   intr_name[18] = "#MC Machine-Check Exception";
   intr_name[19] = "#XF SIMD Floating-Point Exception";
}

/*完成有关中断的所有初始化工作*/
void idt_init()
{
   put_str("idt_init start\n");
   idt_desc_init();  // 调用上面写好的函数完成中段描述符表的构建
   exception_init(); // 异常名初始化并注册通常的中断处理函数
   pic_init();       // 设定化中断控制器，只接受来自时钟中断的信号

   /* 加载idt */
   uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16)); // 定义要加载到IDTR寄存器中的值
   asm volatile("lidt %0" : : "m"(idt_operand));
   put_str("idt_init done\n");
}
```

汇编实现保护上下文(yourPath/chapter7/b/kernel/interrupt.c)：

```asm
[bits 32]
%define ERROR_CODE nop		                ; 有些中断进入前CPU会自动压入错误码（32位）,为保持栈中格式统一,这里不做操作.
%define ZERO push 0		                    ; 有些中断进入前CPU不会压入错误码，对于这类中断，我们为了与前一类中断统一管理，就自己压入32位的0

extern idt_table		                    ;idt_table是C中注册的中断处理程序数组

section .data
global intr_entry_table
intr_entry_table:                           ;编译器会将之后所有同属性的section合成一个大的segment，所以这个标号后面会聚集所有的中断处理程序的地址

%macro VECTOR 2                             ;汇编中的宏用法见书p320
section .text                               ;中断处理函数的代码段
intr%1entry:		                        ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少,此标号来表示中断处理程序的入口
    %2                                      ;这一步是根据宏传入参数的变化而变化的
                                            
    push ds                                 ; 以下是保存上下文环境
    push es
    push fs
    push gs
    pushad

                                            ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI 
    mov al,0x20                             ; 中断结束命令EOI
    out 0xa0,al                             ;向主片发送OCW2,其中EOI位为1，告知结束中断，详见书p317
    out 0x20,al                             ;向从片发送OCW2,其中EOI位为1，告知结束中断

    push %1			                        ; 不管idt_table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便
    call [idt_table + %1*4]                 ; 调用idt_table中的C版本中断处理函数
    jmp intr_exit

section .data                               ;这个段就是存的此中断处理函数的地址
    dd    intr%1entry	                    ; 存储各个中断入口程序的地址，形成intr_entry_table数组,定义的地址是4字节，32位
%endmacro

section .text
global intr_exit
intr_exit:	     
                                            ; 以下是恢复上下文环境
    add esp, 4			                    ; 跳过中断号
    popad
    pop gs
    pop fs
    pop es
    pop ds
    add esp, 4			                    ;对于会压入错误码的中断会抛弃错误码（这个错误码是执行中断处理函数之前CPU自动压入的），对于不会压入错误码的中断，就会抛弃上面push的0                    
    iretd				                    ; 从中断返回,32位下iret等同指令iretd


VECTOR 0x00,ZERO                            ;调用之前写好的宏来批量生成中断处理函数，传入参数是中断号码与上面中断宏的%2步骤，这个步骤是什么都不做，还是压入0看p303
VECTOR 0x01,ZERO
VECTOR 0x02,ZERO
VECTOR 0x03,ZERO 
VECTOR 0x04,ZERO
VECTOR 0x05,ZERO
VECTOR 0x06,ZERO
VECTOR 0x07,ZERO 
VECTOR 0x08,ERROR_CODE
VECTOR 0x09,ZERO
VECTOR 0x0a,ERROR_CODE
VECTOR 0x0b,ERROR_CODE 
VECTOR 0x0c,ZERO
VECTOR 0x0d,ERROR_CODE
VECTOR 0x0e,ERROR_CODE
VECTOR 0x0f,ZERO 
VECTOR 0x10,ZERO
VECTOR 0x11,ERROR_CODE
VECTOR 0x12,ZERO
VECTOR 0x13,ZERO 
VECTOR 0x14,ZERO
VECTOR 0x15,ZERO
VECTOR 0x16,ZERO
VECTOR 0x17,ZERO 
VECTOR 0x18,ERROR_CODE
VECTOR 0x19,ZERO
VECTOR 0x1a,ERROR_CODE
VECTOR 0x1b,ERROR_CODE 
VECTOR 0x1c,ZERO
VECTOR 0x1d,ERROR_CODE
VECTOR 0x1e,ERROR_CODE
VECTOR 0x1f,ZERO 
VECTOR 0x20,ZERO
```

![无特权级变化下的保存与恢复上下文](/home/zhj/.config/Typora/typora-user-images/image-20240812215457020.png)

执行pushad后，保存好上下文，push %1 是指将中断向量号压入栈中，执行call，即调用在interrupt.c中定义的general_intr_handler函数，执行后， add esp, 4跳过中断向量号(general_intr_handler的参数)，然后popad ～ popds，恢复原寄存器的值，add esp, 4是指跳过ERROR_CODE，iretd，返回原程序。

### 时钟

时钟：一般分为内部时钟和外部时钟两种。

| 时钟分类 |                                                              |
| -------- | ------------------------------------------------------------ |
| 内部时钟 | 处理器中内部元件，如运算器、控制器的工作时序，主要用于控制、同步内部工作过程的步调<br />内部时钟是由晶体振荡器产生，也被称为晶振<br />晶振频率经分频后为外频<br />外频 * 倍频为主频，处理器取指令、执行指令中所消耗的时钟周期，都是基于主频的<br />内部时钟一般以纳秒为单位，且无法改变 |
| 外部时钟 | 处理器与外部设备或外部设备之间通信时采用的一种时序<br />两个串口设备进行数据传输前需要同步外部时钟<br />外部时钟一般以毫秒或者秒为单位 |

由于内部时钟和外部时钟是两套独立运行的定时体系，所以需要考虑处理器与外部设备间同步数据时的时序配合问题，如何保证运行在不同时钟节拍下的设备能够同步通信。所以定时器应运而生，以处理器的内部时钟为依据来设计外部设备的时钟，既要符合处理器内部运行时序的规定，又要满足外部设备工作时序的要求，将晶振分频以满足所需的各种定时信号。

### 可编程计数器/定时器 8253

修改计数值的方式有两种：正计时和倒计时，8253采用倒计时。

![8253内部结构示意图和计数器内部结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240813113324315.png)

8253内有3个16位计数器，完全相同，相互独立，互不影响。

CLK：表示时钟输入信号，即计数器自己工作的节拍，也就是计数器自己的时钟频率。每当此引脚收到一个时钟信号，减法计数器就将计数值减1。

GATE：门控输入信号，在某些工作方式下用于控制计数器是否可以开始计数，在不同工作方 式下 GATE 的作用不同。

OUT：计数器输出信号。当定时工作结束，也就是计数值为 0 时，根据计数器的工作方式， 会在 OUT 引脚上输出相应的信号。

计数初值寄存器：保存计数器的初始值，计数过程中不会发生改变。

计数器执行部件(减法计数器)：每次接受到一次时钟信号，该部件将计数值减一。

输出锁存器：当前计数值锁存器，把当前减法计数器中的计数值保存下来，其目的就是为了让外界可以随时获取当前计数值。

![8253计数器的作用表](/home/zhj/.config/Typora/typora-user-images/image-20240813114305779.png)

8253控制字：

![8253控制字格式](/home/zhj/.config/Typora/typora-user-images/image-20240813114419947.png)

![8253工作方式示意表](/home/zhj/.config/Typora/typora-user-images/image-20240813114513306.png)

8253的启动：

启动条件：

1. GATE 为高电平，即 GATE 为 1，这是由硬件来控制的。
2. 计数初值已写入计数器中的减法计数器，这是由软件 out 指令控制的。

启动方式：

- 软件启动：软件启动是指上面硬件负责的条件 1 已经完成，也就是 GATE 已经为 1，目前只差软件来完成条件 2， 即尚未写入计数初值，只要软件负责的条件准备好，计数器就开始启动。当处理器用 out 指令往计数器写入 计数初值，减法器将此初值加载后，计数器便开始计数。工作方式 0、2、3、4 都是用软件启动计数过程。
- 硬件启动：硬件启动是指上面软件负责的条件 2 已经完成，即计数初值已写入计数器。目前只差硬件来完成条件 1 了，也就是门控信号 GATE 目前还是低电平，即目前 GATE=0，只要硬件负责的条件准备好，计数器就 开始启动。GATE 引脚是由外部信号来控制的，只有当 GATE 由 0 变 1 的上升沿出现时，计数器才开始启 动计数。工作方式 1、5 都是用硬件启动计数过程

8253的终止

- 强制终止：有些工作方式中，计数器是重复计数的，当计时到期（计数值为 0）后，减法计数器又会重新把计数初值寄 存器中的值重新载入，继续下一轮计数，比如工作方式 2 和工作方式 3 都是采用此方式计数，此方式常见于需要 周期性发信号的场合。对于采用此类循环计数工作方式的计数器，只能通过外加控制信号来将其计数过程终止， 办法是破坏启动计数的条件：将 GATE 置为 0 即可。

- 自动终止：有些工作方式中，计数器是单次计数，只要定时（计数）一到期就停止，不再进行下一轮计数，所以 计数过程自然就自动终止了。比如工作方式 0、1、4、5 都是单次计数，完成后自动终止。如果要在计数过程中将其终止只需要将 GATE 置 0。

  ![8253工作模式总结示意表](/home/zhj/.config/Typora/typora-user-images/image-20240813120600558.png)

8253的初始化步骤：

- 往控制字寄存器端口0x43中写入控制字

- 在所指定使用的而计数器端口中写入计数初值

### 提高时钟中断的频率

IRQ0 引脚上的时钟中断信号频率是由 8253 的计数器 0 设置。

时钟发出的中断信号不能只发一次，必须是周期性发出的，采取循环计数的工作方式， 选择方式2。

计数器发出输出信号的频率是由计数初值决定的，所以要为计数器0赋予合适的计数初值。

编写提高时钟中断的频率(yourPath/chapter7/c/device/time.c)

```C
#include "timer.h"
#include "io.h"
#include "print.h"

#define IRQ0_FREQUENCY 100      // 定义我们想要的中断发生频率，100HZ
#define INPUT_FREQUENCY 1193180 // 计数器0的工作脉冲信号评率
#define COUNTER0_VALUE INPUT_FREQUENCY / IRQ0_FREQUENCY
#define CONTRER0_PORT 0x40    // 要写入初值的计数器端口号
#define COUNTER0_NO 0         // 要操作的计数器的号码
#define COUNTER_MODE 2        // 用在控制字中设定工作模式的号码，这里表示比率发生器
#define READ_WRITE_LATCH 3    // 用在控制字中设定读/写/锁存操作位，这里表示先写入低字节，然后写入高字节
#define PIT_CONTROL_PORT 0x43 // 控制字寄存器的端口

/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port,
                          uint8_t counter_no,
                          uint8_t rwl,
                          uint8_t counter_mode,
                          uint16_t counter_value)
{
    /* 往控制字寄存器端口0x43中写入控制字 */
    outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
    /* 先写入counter_value的低8位 */
    outb(counter_port, (uint8_t)counter_value);
    /* 再写入counter_value的高8位 */
    // outb(counter_port, (uint8_t)counter_value >> 8); 作者这句代码会先将16位的counter_value强制类型转换为8位值，也就是原来16位值只留下了低8位，然后
    // 又右移8未，所以最后送入counter_port的counter_value的高8位是8个0，这会导致时钟频率过高，出现GP异常
    outb(counter_port, (uint8_t)(counter_value >> 8));
}

/* 初始化PIT8253 */
void timer_init()
{
    put_str("timer_init start\n");
    /* 设置8253的定时周期,也就是发中断的周期 */
    frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
    put_str("timer_init done\n");
}
```

在初始化时，调用 timer_init() ，实现8253的计时，提高时钟中断的频率。

## 内存管理

### 实现内核中 ASSERT 断言

在系统中，将实现两种断言，一种是为内核系统使用的 ASSERT，另一种是为用户进程使用的 assert，用户进程离现在还早，先实现专供内核使用的 ASSERT。 

内核运行时，通过时钟中断来定时调度其他任务，大部分时间下中断是打开的，而如果内核出错，那么基本上可以不用运行了，专注于提示报错信息即可，所以此时需要关闭中断。

实现开关中断(yourPath/chapter8/a/kernel/interrupt.c)：

```c
#define EFLAGS_IF   0x00000200       // eflags寄存器中的if位为1
#define GET_EFLAGS(EFLAG_VAR) asm volatile("pushfl; popl %0" : "=g" (EFLAG_VAR))
//pop到了EFLAG_VAR所在内存中，该约束自然用表示内存的字母，但是内联汇编中没有专门表示约束内存的字母，所以只能用g
//g 代表可以是任意寄存器，内存或立即数

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
   uint32_t eflags = 0; 
   GET_EFLAGS(eflags);
   return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
}


/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
   enum intr_status old_status;
   if (INTR_ON == intr_get_status()) {
      old_status = INTR_ON;
      return old_status;
   } else {
      old_status = INTR_OFF;
      asm volatile("sti");	 // 开中断,sti指令将IF位置1
      return old_status;
   }
}

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
   enum intr_status old_status;
   if (INTR_ON == intr_get_status()) {
      old_status = INTR_ON;
      asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
                                          //cli指令不会直接影响内存。然而，从一个更大的上下文来看，禁用中断可能会影响系统状态，
                                          //这个状态可能会被存储在内存中。所以改变位填 "memory" 是为了安全起见，确保编译器在生成代码时考虑到这一点。
      return old_status;
   } else {
      old_status = INTR_OFF;
      return old_status;
   }
}

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
   return status & INTR_ON ? intr_enable() : intr_disable();   //enable与disable函数会返回旧中断状态
}
```

定义所需的变量以及声明函数(yourPath/chapter8/a/kernel/interrupt.c)：

```c
#ifndef __KERNEL_INTERRUPT_H
#define __KERNEL_INTERRUPT_H
#include "stdint.h"
typedef void* intr_handler;		//将intr_handler定义为void*同类型
void idt_init(void);

/* 定义中断的两种状态:
 * INTR_OFF值为0,表示关中断,
 * INTR_ON值为1,表示开中断 */
enum intr_status {		 // 中断状态
    INTR_OFF,			 // 中断关闭
    INTR_ON		         // 中断打开
};

enum intr_status intr_get_status(void);
enum intr_status intr_set_status (enum intr_status);
enum intr_status intr_enable (void);
enum intr_status intr_disable (void);
#endif
```

定义内核 ASSERT 断言宏(yourPath/chapter8/a/kernel/debug.h)：

```C
#ifndef __KERNEL_DEBUG_H
#define __KERNEL_DEBUG_H
void panic_spin(char* filename, int line, const char* func, const char* condition);

//...是可变参数，也就是随便你传多少个参数，然后原封不动地传到__VA_ARGS_那里去
//__FILE__,__LINE__,__func__是预定义宏，代表这个宏所在的文件名，行数，与函数名字，编译器处理
#define PANIC(...) panic_spin (__FILE__, __LINE__, __func__, __VA_ARGS__)

//如果定义了NDEBUG,那么下面定义的ASSERT就是个空。这样我们可以便捷的让所有ASSERT宏失效。因为有时候断言太多，程序会运行
//很慢。我们如果不想要ASSERT起作用，编译时用gcc-DNDEBUG就行了
#ifdef NDEBUG
   #define ASSERT(CONDITION) ((void)0)
#else
#define ASSERT(CONDITION)   \
    if(CONDITION){}         \
    else{PANIC(#CONDITION);}    //加#后，传入的参数变成字符串

#endif  //结束#ifdef NDEBUG
#endif  //结束#define __KERNEL_DEBUG_H
```

实现内核 ASSERT 断言宏(yourPath/chapter8/a/kernel/debug.c)：

```C
#include "debug.h"
#include "print.h"
#include "interrupt.h"  //关闭中断函数在里面

/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename, int line, const char* func, const char* condition) 
{
    intr_disable();	//发生错误时打印错误信息，不应该被打扰
    put_str("\n\n\n!!!!! error !!!!!\n");
    put_str("filename:");put_str(filename);put_str("\n");
    put_str("line:0x");put_int(line);put_str("\n");
    put_str("function:");put_str((char*)func);put_str("\n");
    put_str("condition:");put_str((char*)condition);put_str("\n");
    while(1);
}
```

### 实现字符串操作函数

为方便之后使用，对照C字符串操作实现自己的字符串操作函数。

声明函数(yourPath/chapter8/b/lib/string.h)：

```C
#ifndef __LIB_STRING_H
#define __LIB_STRING_H
#include "stdint.h"

// 将 `dst_` 指向的内存区域的前 `size` 个字节设置为常数值 `value`。
void memset(void *dst_, uint8_t value, uint32_t size);

// 从 `src_` 复制 `size` 个字节到 `dst_`。源和目标区域不应重叠。
void memcpy(void *dst_, const void *src_, uint32_t size);

// 比较 `a_` 和 `b_` 指向的前 `size` 个字节。
int memcmp(const void *a_, const void *b_, uint32_t size);

// 将 `src_` 指向的字符串复制到 `dst_` 指向的缓冲区，并返回指向 `dst_` 的指针。
char *strcpy(char *dst_, const char *src_);

// 返回 `str` 指向的字符串的长度（不包括终止符 '\0'）。
uint32_t strlen(const char *str);

// 比较两个字符串 `a` 和 `b`，如果相等返回 0，否则返回非零值指示顺序。
int8_t strcmp(const char *a, const char *b);

// 在 `string` 中查找第一个 `ch` 字符的位置，并返回指向该字符的指针，如果没有找到则返回 NULL。
char *strchr(const char *string, const uint8_t ch);

// 在 `string` 中查找最后一个 `ch` 字符的位置，并返回指向该字符的指针，如果没有找到则返回 NULL。
char *strrchr(const char *string, const uint8_t ch);

// 将 `src_` 指向的字符串连接到 `dst_` 指向的字符串的末尾，并返回指向 `dst_` 的指针。
char *strcat(char *dst_, const char *src_);

// 统计 `filename` 中字符 `ch` 出现的次数。
uint32_t strchrs(const char *filename, uint8_t ch);

#endif // __LIB_STRING_H
```

实现函数(yourPath/chapter8/b/lib/string.c)：

```c
#include "string.h"
#include "global.h"
#include "../kernel/debug.h" //定义了ASSERT

// 将dst起始的size个字节置为value，这个函数最常用的用法就是来初始化一块内存区域，也就是置为ASCII码为0
void memset(void *dst_, uint8_t value, uint32_t size)
{
    ASSERT(dst_ != NULL);           // 一般开发都有这个习惯，传入进来个地址，判断不是空
    uint8_t *dst = (uint8_t *)dst_; // 强制类型转换，将对地址的操作单位变成一字节
    while (size-- > 0)              // 先判断size是否>0，然后再减，然后执行循环体，size是多少，就会循环多少次
        *dst++ = value;             //*的优先级高于++，所以是先对dst指向的地址进行操作(*dst=value)，然后地址+1
}

// 将src地址起始处size字节的数据移入dst，用于拷贝内存数据
// src起始是有数据的，所以用const void*，const修饰void*，意味着地址内的数据是只读
void memcpy(void *dst_, const void *src_, uint32_t size)
{
    ASSERT(dst_ != NULL && src_ != NULL);
    uint8_t *dst = dst_;
    const uint8_t *src = src_;
    while (size-- > 0)
        *dst++ = *src++;
}

// 比较两个地址起始的size字节的数据是否相等，如果相等，则返回0；如果不相等，比较第一个不相等的数据，>返回1，<返回-1
int memcmp(const void *a_, const void *b_, uint32_t size)
{
    const char *a = a_;
    const char *b = b_;
    ASSERT(a != NULL || b != NULL);
    while (size-- > 0)
    {
        if (*a != *b)
        {
            return *a > *b ? 1 : -1;
        }
        a++;
        b++;
    }
    return 0;
}

// 将字符串从src拷贝到dst,并返回目的字符串的起始地址
char *strcpy(char *dst_, const char *src_)
{
    ASSERT(dst_ != NULL && src_ != NULL);
    char *r = dst_; // 用来返回目的字符串起始地址
    while ((*dst_++ = *src_++))
        ;     // 1、*dst=*src  2、判断*dst是否为'\0'，然后决定是否执行循环体，本步骤真假值不影响3   3、dst++与scr++，谁先谁后不知道
    return r; // 上面多出来的一对括号，是为了告诉编译器，我这里的=就是自己写的，而不是将==错误写成了=
}

/* 返回字符串长度 */
uint32_t strlen(const char *str)
{
    ASSERT(str != NULL);
    const char *p = str;
    while (*p++)
        ;                 // 1、先取*p的值来进行2的判断     2、判断*p,决定是否执行循环体     3、p++(这一步的执行并不依赖2的判断为真)
    return (p - str - 1); // p最后指向'\0'后面第一个元素
}

// 比较两个字符串，若a_中的字符与b_中的字符全部相同，则返回0，如果不同，那么比较第一个不同的字符，如果a_>b_返回1，反之返回-1
int8_t strcmp(const char *a, const char *b)
{
    ASSERT(a != NULL && b != NULL);
    while (*a != 0 && *a == *b)
    {
        a++;
        b++;
    }
    /* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
     * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
    return *a < *b ? -1 : *a > *b;
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char *strchr(const char *str, const uint8_t ch)
{
    ASSERT(str != NULL);
    while (*str != 0)
    {
        if (*str == ch)
        {
            return (char *)str; // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
        }
        str++;
    }
    return NULL;
}

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char *strrchr(const char *str, const uint8_t ch)
{
    ASSERT(str != NULL);
    const char *last_char = NULL;
    /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
    while (*str != 0)
    {
        if (*str == ch)
        {
            last_char = str;
        }
        str++;
    }
    return (char *)last_char;
}

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char *strcat(char *dst_, const char *src_)
{
    ASSERT(dst_ != NULL && src_ != NULL);
    char *str = dst_;
    while (*str++)
        ;
    --str; // 别看错了，--str是独立的一句，并不是while的循环体。这一句是为了让str指向dst_的最后一个非0字符
    while ((*str++ = *src_++))
        ; // 1、*str=*src  2、判断*str     3、str++与src++，这一步不依赖2
    return dst_;
}

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char *str, uint8_t ch)
{
    ASSERT(str != NULL);
    uint32_t ch_cnt = 0;
    const char *p = str;
    while (*p != 0)
    {
        if (*p == ch)
        {
            ch_cnt++;
        }
        p++;
    }
    return ch_cnt;
}
```

### 位图 bitmap 以及其函数实现

位图，也就是 bitmap，广泛用于资源管理，是一种管理资源的方式、手段。“资源”包括很多，比如内存或硬盘，对于此类大容量资源的管理一般都会采用位图的方式。

位图就是用字节中的 1 位来映射其他单位大小 的资源，按位与资源之间是一对一的对应关系。

管理结构中的数据也有自己的单位大小，被管理的资源也有自己的单位大小，故有效减少管理成本的方法是使管理结构中的单位达到最小，其所管理资源的单位调整到最大。

位图，实际上就是用某一位的状态（0，还是1）来表示一段连续的内存（一般为4K）区域是否已经被分配出去。而且这样的位，在内存中是连续分布的。

位图的定义

声明位图结构和声明位图函数(yourPath/chapter8/c/lib/kernel/bitmap.h)：

```c
#ifndef __LIB_KERNEL_BITMAP_H
#define __LIB_KERNEL_BITMAP_H
#define BITMAP_MASK 1
struct bitmap 
{                 				//这个数据结构就是用来管理整个位图
   uint32_t btmp_bytes_len;     //记录整个位图的大小，字节为单位
   uint8_t* bits;               //用来记录位图的起始地址，我们未来用这个地址遍历位图时，操作单位指定为最小的字节
};

void bitmap_init(struct bitmap *btmp);
bool bitmap_scan_test(struct bitmap *btmp, uint32_t bit_idx);
int bitmap_scan(struct bitmap *btmp, uint32_t cnt);
void bitmap_set(struct bitmap *btmp, uint32_t bit_idx, int8_t value);
#endif
```

实现位图(yourPath/chapter8/c/lib/kernel/bitmap.h)：

```c
#include "bitmap.h"
#include "stdint.h"
#include "string.h"
#include "print.h"
#include "interrupt.h"
#include "debug.h"

/* 将位图 btmp 初始化 */
void bitmap_init(struct bitmap *btmp)
{
    memset(btmp->bits, 0, btmp->btmp_bytes_len);
}

/* 判断 bit_idx 位是否为 1，若为 1，则返回 true，否则返回 false */
bool bitmap_scan_test(struct bitmap *btmp, uint32_t bit_idx)
{
    uint32_t byte_idx = bit_idx / 8; // 向下取整用于索引数组下标
    uint32_t bit_odd = bit_idx % 8;  // 取余用于索引数组内的位
    return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
}

/* 在位图中申请连续 cnt 个位，成功，则返回其起始位下标，失败，返回−1 */
int bitmap_scan(struct bitmap *btmp, uint32_t cnt)
{
    uint32_t idx_byte = 0; // 用于记录空闲位所在的字节
    /* 先逐字节比较，蛮力法 */
    while ((0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len))
    {
        /* 1 表示该位已分配，若为 0xff，则表示该字节内已无空闲位，向下一字节继续找 */
        idx_byte++;
    }

    ASSERT(idx_byte < btmp->btmp_bytes_len);
    if (idx_byte == btmp->btmp_bytes_len)
    { // 若该内存池找不到可用空间
        return -1;
    }

    /* 若在位图数组范围内的某字节内找到了空闲位
     *在该字节内逐位比对，返回空闲位的索引。*/
    int idx_bit = 0;
    /* 和 btmp->bits[idx_byte]这个字节逐位对比 */
    while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte])
    {
        idx_bit++;
    }

    int bit_idx_start = idx_byte * 8 + idx_bit; // 空闲位在位图内的下标
    if (cnt == 1)
    {
        return bit_idx_start;
    }

    uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);
    // 记录还有多少位可以判断
    uint32_t next_bit = bit_idx_start + 1;
    uint32_t count = 1; // 用于记录找到的空闲位的个数

    bit_idx_start = -1; // 先将其置为−1，若找不到连续的位就直接返回
    while (bit_left-- > 0)
    {
        if (!(bitmap_scan_test(btmp, next_bit)))
        { // 若 next_bit 为 0
            count++;
        }
        else
        {
            count = 0;
        }
        if (count == cnt)
        { // 若找到连续的 cnt 个空位
            bit_idx_start = next_bit - cnt + 1;
            break;
        }
        next_bit++;
    }
    return bit_idx_start;
}

/* 将位图 btmp 的 bit_idx 位设置为 value */
void bitmap_set(struct bitmap *btmp, uint32_t bit_idx, int8_t value)
{
    ASSERT((value == 0) || (value == 1));
    uint32_t byte_idx = bit_idx / 8; // 向下取整用于索引数组下标
    uint32_t bit_odd = bit_idx % 8;  // 取余用于索引数组内的位

    /* 一般都会用个 0x1 这样的数对字节中的位操作
     * 将 1 任意移动后再取反，或者先取反再移位，可用来对位置 0 操作。*/
    if (value)
    { // 如果 value 为 1
        btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
    }
    else
    { // 若为 0
        btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
    }
}
```

### 内存池

内存管理，其实就是管理内存空间的分配。由于现在开启了段页机制，所以内存的分配就涉及到两个部分，虚拟地址分配与物理地址分配，然后将虚拟地址与物理地址通过页表建立映射。内存的分配一定是从管理可用内存的内存池中分配，内核要申请内存，那么就从内核的可用虚拟内存池与内核的可用物理内存池中进行分配，然后将分配的虚拟地址与物理地址通过内核页表建立映射。用户程序要申请内存，那么就从用户的可用虚拟内存池与用户的可用物理内存池中进行分配，然后将分配的虚拟地址与物理地址通过进程自己的页表建立映射。

虚拟内存池是按照进程为单位进行建立，每个进程都有自己的虚拟内存池，内核也有自己的虚拟内存池。但是，所有的用户进程都使用一个共用的用户物理内存池，内核使用自己的内核物理内存池，为的是避免用户进程将物理内存申请干净之后，内核就不能申请内存了，所以让内核单独用一个物理内存池。

进行内存管理的核心准备工作，初始化三个内存池：管理内核可用虚拟地址空间内存池、管理内核可用物理地址空间内存池、管理用户可用物理地址空间内存池，用户可用虚拟地址空间内存池是要等到创建用户进程时才创立，现在不用初始化。

定义数据结构以及声明函数(yourPath/chapter8/d/kernel/memory.h)：

```C
#ifndef __KERNEL_MEMORY_H
#define __KERNEL_MEMORY_H
#include "stdint.h"
#include "../lib/kernel/bitmap.h"

extern struct pool kernel_pool, user_pool;
void mem_init(void);

//核心数据结构，虚拟内存池，有一个位图与其管理的起始虚拟地址
struct virtual_addr {
   struct bitmap vaddr_bitmap;      // 虚拟地址用到的位图结构 
   uint32_t vaddr_start;            // 虚拟地址起始地址
};

#endif
```

实现内存池函数(yourPath/chapter8/d/kernel/memory.h)：

```C
#include "memory.h"
#include "stdint.h"
#include "print.h"

#define PG_SIZE 4096               // 一页的大小
#define MEM_BITMAP_BASE 0xc009a000 // 这个地址是位图的起始地址，1MB内存布局中，9FBFF是最大一段可用区域的边界，而我们计划这个可用空间最后的位置将来用来
// 放PCB，而PCB占用内存是一个自然页，所以起始地址必须是0xxxx000这种形式，离0x9fbff最近的符合这个形式的地址是0x9f000。我们又为了将来可能的拓展，
// 所以让位图可以支持管理512MB的内存空间，所以预留位图大小为16KB，也就是4页，所以选择0x9a000作为位图的起始地址

// 定义内核堆区起始地址，堆区就是用来进行动态内存分配的地方，咱们的系统内核运行在c00000000开始的1MB虚拟地址空间，所以自然要跨过这个空间，
// 堆区的起始地址并没有跨过256个页表，没关系，反正使用虚拟地址最终都会被我们的页表转换为物理地址，我们建立物理映射的时候，跳过256个页表就行了
#define K_HEAP_START 0xc0100000

/* 核心数据结构，物理内存池， 生成两个实例用于管理内核物理内存池和用户物理内存池 */
struct pool
{
    struct bitmap pool_bitmap; // 本内存池用到的位图结构,用于管理物理内存
    uint32_t phy_addr_start;   // 本内存池所管理物理内存的起始地址
    uint32_t pool_size;        // 本内存池字节容量
};

struct pool kernel_pool, user_pool; // 为kernel与user分别建立物理内存池，让用户进程只能从user内存池获得新的内存空间，
                                    // 以免申请完所有可用空间,内核就不能申请空间了
struct virtual_addr kernel_vaddr; // 用于管理内核虚拟地址空间

// 初始化内核物理内存池与用户物理内存池
static void mem_pool_init(uint32_t all_mem)         // all_mem 为32 MB
{
    put_str("   mem_pool_init start\n");
    uint32_t page_table_size = PG_SIZE * 256;       // 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
                                                    // 第769~1022个页目录项共指向254个页表,共256个页表
    												// 4KB * 256 = 1MB
    uint32_t used_mem = page_table_size + 0x100000; // 已使用内存 = 1MB + 256个页表 = 2MB
    uint32_t free_mem = all_mem - used_mem;			// 32MB - 2MB = 30MB
    uint16_t all_free_pages = free_mem / PG_SIZE;                  // 将所有可用内存转换为页的数量，内存分配以页为单位，丢掉的内存不考虑
    															   // 所有的空页有 30 * 256 页
    uint16_t kernel_free_pages = all_free_pages / 2;               // 可用内存是用户与内核各一半，所以分到的页自然也是一半，即15 *256 页
    uint16_t user_free_pages = all_free_pages - kernel_free_pages; // 用于存储用户空间分到的页

    /* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
    好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
    uint32_t kbm_length = kernel_free_pages / 8; // 内核物理内存池的位图长度,位图中的一位表示一页,以字节为单位 480B
    uint32_t ubm_length = user_free_pages / 8;   // 用户物理内存池的位图长度.

    uint32_t kp_start = used_mem;                               // Kernel Pool start,内核使用的物理内存池的起始地址 2MB
    uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE; // User Pool start,用户使用的物理内存池的起始地址 2MB+15MB

    kernel_pool.phy_addr_start = kp_start; // 赋值给内核使用的物理内存池的起始地址
    user_pool.phy_addr_start = up_start;   // 赋值给用户使用的物理内存池的起始地址

    kernel_pool.pool_size = kernel_free_pages * PG_SIZE; // 赋值给内核使用的物理内存池的总大小
    user_pool.pool_size = user_free_pages * PG_SIZE;     // 赋值给用户使用的物理内存池的总大小

    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length; // 赋值给管理内核使用的物理内存池的位图长度
    user_pool.pool_bitmap.btmp_bytes_len = ubm_length;   // 赋值给管理用户使用的物理内存池的位图长度

    /*********    内核内存池和用户内存池位图   ***********
     *   位图是全局的数据，长度不固定。
     *   全局或静态的数组需要在编译时知道其长度，
     *   而我们需要根据总内存大小算出需要多少字节。
     *   所以改为指定一块内存来生成位图.
     *   ************************************************/
    // 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
    // 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
    kernel_pool.pool_bitmap.bits = (void *)MEM_BITMAP_BASE; // 管理内核使用的物理内存池的位图起始地址

    /* 用户内存池的位图紧跟在内核内存池位图之后 */
    user_pool.pool_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length); // 管理用户使用的物理内存池的位图起始地址
    /******************** 输出物理内存池信息 **********************/
    put_str("      phy_pool:")
    put_Str("\n");
    put_str("      kernel_pool_bitmap_start:");
    put_int((int)kernel_pool.pool_bitmap.bits);  
    put_str(" kernel_pool_phy_addr_start:");
    put_int(kernel_pool.phy_addr_start);
    put_str("\n");
    put_str("      user_pool_bitmap_start:");
    put_int((int)user_pool.pool_bitmap.bits);
    put_str(" user_pool_phy_addr_start:");
    put_int(user_pool.phy_addr_start);
    put_str("\n");

    /* 将位图置0*/
    bitmap_init(&kernel_pool.pool_bitmap);
    bitmap_init(&user_pool.pool_bitmap);

    /* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/
    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length; // 赋值给管理内核可以动态使用的虚拟地址池（堆区）的位图长度，
                                                           // 其大小与管理内核可使用的物理内存池位图长度相同，因为虚拟内存最终都要转换为真实的物理内存，可用虚拟内存大小超过可用物理内存大小在
                                                           // 我们这个简单操作系统无意义（现代操作系统中有意义，因为我们可以把真实物理内存不断换出，回收，来让可用物理内存变相变大)

    /* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
    kernel_vaddr.vaddr_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length + ubm_length); // 赋值给管理内核可以动态使用的虚拟内存池（堆区）的位图起始地址

    kernel_vaddr.vaddr_start = K_HEAP_START; // 赋值给内核可以动态使用的虚拟地址空间的起始地址
    bitmap_init(&kernel_vaddr.vaddr_bitmap); // 初始化管理内核可以动态使用的虚拟地址池的位图
     /******************** 输出内核虚拟内存池信息 **********************/
    put_str("   virtual_pool:")
    put_str("\n");
    put_str("      kernel_pool_virtual_bitmap_start:");
    put_int((int)kernel_vaddr.vaddr_bitmap.bits);  
    put_str(" kernel_pool_virtual_addr_start:");
    put_int(kernel_vaddr.vaddr_bitmap.bits);
    put_str("\n");
    put_str("   mem_pool_init done\n");
}

/* 内存管理部分初始化入口 */
void mem_init()
{
    put_str("mem_init start\n");
    uint32_t mem_bytes_total = (*(uint32_t *)(0xb00)); // 32MB
    mem_pool_init(mem_bytes_total); // 初始化内存池
    put_str("mem_init done\n");
}
```


### 分配页内存

内核和用户物理内存池与内核虚拟内存池已经初始化完毕，从内存池中分配地址，然后将分配到的物理地址与虚拟地址建立映射关系。

声明权限位(yourPath/chapter8/e/kernel/memory.h)：

```C
/* 内存池标记，用于判断用哪个内存池 */
enum pool_flags
{
   PF_KERNEL = 1, // 内核内存池
   PF_USER = 2    // 用户内存池
};
#define PG_P_1 1  // 页表项或页目录项存在属性位
#define PG_P_0 0  // 页表项或页目录项存在属性位
#define PG_RW_R 0 // R/W 属性位值，读/执行
#define PG_RW_W 2 // R/W 属性位值，读/写/执行
#define PG_US_S 0 // U/S 属性位值，系统级
#define PG_US_U 4 // U/S 属性位值，用户级
```

实现分配物理页，并与虚拟地址建立映射关系(yourPath/chapter8/e/kernel/memory.h)：

```c
#define PDE_IDX(addr) ((addr & 0xffc00000) >> 22) // 获取 PDE
#define PTE_IDX(addr) ((addr & 0x003ff000) >> 12) // 获取 PTE

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void *vaddr_get(enum pool_flags pf, uint32_t pg_cnt)
{
    int vaddr_start = 0, bit_idx_start = -1;
    uint32_t cnt = 0;
    if (pf == PF_KERNEL)
    {
        bit_idx_start = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
        if (bit_idx_start == -1)
        {
            return NULL;
        }
        while (cnt < pg_cnt)
        {
            bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
        }
        vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
    }
    else
    {
        // 用户内存池,将来实现用户进程再补充
    }
    return (void *)vaddr_start;
}

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void *palloc(struct pool *m_pool)
{
    /* 扫描或设置位图要保证原子操作 */
    int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1); // 找一个物理页面
    if (bit_idx == -1)
    {
        return NULL;
    }
    bitmap_set(&m_pool->pool_bitmap, bit_idx, 1); // 将此位bit_idx置1
    uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
    return (void *)page_phyaddr;
}


/* 得到虚拟地址vaddr对应的pde的指针 */
uint32_t *pde_ptr(uint32_t vaddr)
{
    /* 0xfffff是用来访问到页表本身所在的地址 */
    uint32_t *pde = (uint32_t *)((0xfffff000) + PDE_IDX(vaddr) * 4);
    return pde;
}

/* 得到虚拟地址vaddr对应的pte指针*/
uint32_t *pte_ptr(uint32_t vaddr)
{
    /* 先访问到页表自己 + 再用页目录项pde(页目录内页表的索引)做为pte的索引访问到页表 + 再用pte的索引做为页内偏移*/
    uint32_t *pte = (uint32_t *)(0xffc00000 + ((vaddr & 0xffc00000) >> 10) + PTE_IDX(vaddr) * 4);
    return pte;
}

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void *_vaddr, void *_page_phyaddr)
{
    uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
    uint32_t *pde = pde_ptr(vaddr);
    uint32_t *pte = pte_ptr(vaddr);

    /************************   注意   *************************
     * 执行*pte,会访问到空的pde。所以确保pde创建完成后才能执行*pte,
     * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。
     * *********************************************************/
    /* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
    if (*pde & 0x00000001)
    { // 页目录项和页表项的第0位为P,此处判断目录项是否存在
        ASSERT(!(*pte & 0x00000001));

        if (!(*pte & 0x00000001))
        {                                                       // 只要是创建页表,pte就应该不存在,多判断一下放心
            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); // US=1,RW=1,P=1
        }
        else
        { // 应该不会执行到这，因为上面的ASSERT会先执行。
            PANIC("pte repeat");
            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); // US=1,RW=1,P=1
        }
    }
    else
    {   // 页目录项不存在,所以要先创建页目录再创建页表项.
        /* 页表中用到的页框一律从内核空间分配 */
        uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);

        *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);

        /* 分配到的物理页地址pde_phyaddr对应的物理内存清0,
         * 避免里面的陈旧数据变成了页表项,从而让页表混乱.
         * 访问到pde对应的物理地址,用pte取高20位便可.
         * 因为pte是基于该pde对应的物理地址内再寻址,
         * 把低12位置0便是该pde对应的物理页的起始*/
        memset((void *)((int)pte & 0xfffff000), 0, PG_SIZE);

        ASSERT(!(*pte & 0x00000001));
        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); // US=1,RW=1,P=1
    }
}

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void *malloc_page(enum pool_flags pf, uint32_t pg_cnt)
{
    ASSERT(pg_cnt > 0 && pg_cnt < 3840);
    /***********   malloc_page的原理是三个动作的合成:   ***********
          1通过vaddr_get在虚拟内存池中申请虚拟地址
          2通过palloc在物理内存池中申请物理页
          3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
    ***************************************************************/
    void *vaddr_start = vaddr_get(pf, pg_cnt);
    if (vaddr_start == NULL)
    {
        return NULL;
    }

    uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
    struct pool *mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

    /* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
    while (cnt-- > 0)
    {
        void *page_phyaddr = palloc(mem_pool);
        if (page_phyaddr == NULL)
        { // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
            return NULL;
        }
        page_table_add((void *)vaddr, page_phyaddr); // 在页表中做映射
        vaddr += PG_SIZE;                            // 下一个虚拟页
    }
    return vaddr_start;
}

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void *get_kernel_pages(uint32_t pg_cnt)
{
    void *vaddr = malloc_page(PF_KERNEL, pg_cnt);
    if (vaddr != NULL)
    { // 若分配的地址不为空,将页框清0后返回
        memset(vaddr, 0, pg_cnt * PG_SIZE);
    }
    return vaddr;
}
```

malloc_page通过pf判断是用户还是内核进行页分配，malloc_page的本质是以下三步骤的合成：

1. 通过vaddr_get在虚拟内存池中申请虚拟页，获得虚拟地址
2.  通过palloc在物理内存池中申请物理页，获得物理地址
3.  通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射，使用pde_str 和 pte_str实现映射关系的形成

## 线程

程序是指静态的、存储在文件系统上、尚未运行的指令代码，比如说一个编译好的存储在磁盘中的程序。进程是指正在运行中的程序，程序必须在获得运行时所需要的各类资源后才能成为进程，资源包括进程所使用的栈、寄存器、内存、页表等。线程，就是最基本的调度单元，能够以身份独立上处理器运行，也就是一个程序中可以独立的，且正在运行的代码块。线程作为调度单元，一个进程线程越多，那么它上处理器的频率就越高，执行就越快。进程=线程+资源，因为线程运行脱离不了进程，进程里面有线程的运行的资源。线程是调度的单元，进程是分配资源的单元，同一个进程的多个线程享受这个进程的共同资源，如内存，页表等。

把需要等待外界条件的才能运行的进程状态叫做阻塞态，进程可以随时准备运行的状态成为就绪态，把正在处理器上运行的进程的状态成为运行态。

操作系统为每个进程提供了一个PCB，进程控制块，它就是进程的身份证。每个PCB放到一张表格中维护，这就是进程表。调度器可以根据这张表选择上处理器运行的进程。

线程有两种实现方式：用户线程和内核线程

在操作系统中，线程可以在用户空间或内核空间实现。每种实现方式有其优点和缺点，影响到线程的调度、性能和系统的复杂性。下面对用户线程和内核线程进行总结和比较：

1. 用户线程（User-Level Threads）

**定义**：用户线程是完全在用户空间实现的线程，由用户级线程库进行调度。操作系统的内核并不直接知道这些线程的存在。

优点：

1. **移植性强**：由于线程的实现完全在用户空间，操作系统不需要对线程机制进行支持，这使得线程库可以在各种操作系统上移植和运行。
2. **上下文切换开销低**：线程切换不需要陷入内核，减少了上下文切换的开销。用户线程的调度完全由用户级线程库控制，无需进行系统调用。
3. **调度灵活性**：线程调度策略完全由用户程序控制，可以实现特定的调度算法，根据应用的需要调整线程的优先级和调度策略。

缺点：

1. **系统调用阻塞问题**：如果一个用户线程在执行系统调用（如文件读写、网络操作）时发生阻塞，整个进程（包括所有线程）都将被阻塞。操作系统无法识别进程中的多个线程，通常将进程视为一个整体。
2. **缺乏内核支持的并发**：操作系统调度器无法识别用户线程，它只能调度进程。即使进程内部有多个线程，操作系统也只能将处理器时间片分配给整个进程，无法细粒度地调度进程中的线程。
3. **需要线程库支持**：用户线程的实现需要依赖用户级线程库（如 POSIX 线程库），这些库通常需要自行实现线程调度器和线程管理机制。

2. 内核线程（Kernel-Level Threads）

**定义**：内核线程由操作系统的内核直接管理和调度。每个线程被视为一个独立的调度单元，操作系统能够直接识别和调度这些线程。

优点：

1. **系统级调度支持**：操作系统的调度器能够识别并调度内核线程，使得线程能够被有效地分配处理器时间。操作系统可以对多个线程进行时间片轮转，实现真正的并发。
2. **线程阻塞处理**：当一个线程阻塞时，操作系统可以将其他线程调度到处理器上，从而避免整个进程的阻塞。只有发生阻塞的线程会被挂起，其他线程仍然可以继续执行。
3. **更好的并发性**：由于内核线程可以被调度器独立管理，它们可以充分利用多处理器系统中的多个 CPU 核心，实现更高效的并发处理。

缺点：

1. **上下文切换开销较高**：线程切换需要陷入内核，进行上下文保存和恢复操作，相比用户线程的切换，这会带来一定的性能开销。
2. **复杂的内核设计**：实现和维护内核线程需要对操作系统内核进行更复杂的设计和实现。内核线程的管理和调度对操作系统的设计要求较高。
3. **系统调用开销**：由于需要陷入内核执行系统调用，内核线程在执行系统调用时会产生一定的开销。

总结对比

| 特性           | 用户线程 (User-Level Threads)        | 内核线程 (Kernel-Level Threads)      |
| -------------- | ------------------------------------ | ------------------------------------ |
| 调度管理       | 用户空间线程库管理                   | 内核直接管理                         |
| 上下文切换开销 | 较低，不需要陷入内核                 | 较高，需要陷入内核进行上下文切换     |
| 系统调用阻塞   | 整个进程可能被阻塞                   | 只有阻塞线程被挂起，其他线程继续执行 |
| 并发支持       | 操作系统不可识别，无法进行真正的并发 | 内核支持真正的并发，可利用多核系统   |
| 移植性         | 高，用户空间实现                     | 低，依赖于操作系统内核               |

**结论**：在选择使用用户线程还是内核线程时，需要权衡性能、可移植性和系统复杂性。用户线程适合于对性能有严格要求且对系统调用阻塞有较好控制的场景，而内核线程则适合需要充分利用多核处理器并对线程调度和阻塞有更高要求的应用。本章采用内核线程来加速进程运行。

### 内核线程的实现

构建PCB，中断栈以及线程栈(yourPath/chapter9/a/thread/thread.h)：

```c
#ifndef __THREAD_THREAD_H
#define __THREAD_THREAD_H
#include "stdint.h"

// 定义一种叫thread_fun的函数类型，该类型返回值是空，参数是一个地址(这个地址用来指向自己的参数)。
// 这样定义，这个类型就能够具有很大的通用性，很多函数都是这个类型
// 自定义通用函数类型，它将在很多线程函数中作为形参类型
typedef void thread_func(void *);

/* 进程或线程的状态 */
enum task_status
{
    TASK_RUNNING, // 运行
    TASK_READY,   // 就绪
    TASK_BLOCKED, // 阻塞
    TASK_WAITING, // 等待
    TASK_HANGING, // 挂起
    TASK_DIED     // 死亡
};

/***********   中断栈intr_stack   ***********
 * 此结构用于中断发生时保护程序(线程或进程)的上下文环境:
 * 进程或线程被外部中断或软中断打断时,会按照此结构压入上下文
 * 寄存器,  intr_exit中的出栈操作是此结构的逆操作
 * 此栈在线程自己的内核栈中位置固定,所在页的最顶端
 ********************************************/
struct intr_stack
{
    uint32_t vec_no; // kernel.S 宏VECTOR中push %1压入的中断号
    uint32_t edi;
    uint32_t esi;
    uint32_t ebp;
    uint32_t esp_dummy; // 虽然pushad把esp也压入,但esp是不断变化的,所以会被popad忽略
    uint32_t ebx;
    uint32_t edx;
    uint32_t ecx;
    uint32_t eax;
    uint32_t gs;
    uint32_t fs;
    uint32_t es;
    uint32_t ds;

    /* 以下由cpu从低特权级进入高特权级时压入 */
    uint32_t err_code; // err_code会被压入在eip之后 6
    void (*eip)(void); // 旧EIP 5
    uint32_t cs;       // 旧代码段 4
    uint32_t eflags;   // EFLAGS寄存器 3
    void *esp;         // 旧栈指针 2
    uint32_t ss;       // 旧栈 1
};

/***********  线程栈thread_stack  ***********
 * 线程自己的栈,用于存储线程中待执行的函数
 * 此结构在线程自己的内核栈中位置不固定,
 * 用在switch_to时保存线程环境。
 * 实际位置取决于实际运行情况。
 ******************************************/
struct thread_stack
{
    uint32_t ebp;
    uint32_t ebx;
    uint32_t edi;
    uint32_t esi;

    // 这个位置会放一个名叫eip，返回void的函数指针(*epi的*决定了这是个指针)，
    // 该函数传入的参数是一个thread_func类型的函数指针与函数的参数地址
    /* 线程第一次执行时，eip 指向待调用的函数 kernel_thread
    其他时候，eip 是指向 switch_to 的返回地址*/
    void (*eip)(thread_func *func, void *func_arg);

    /***** 以下仅供第一次被调度上 cpu 时使用 ****/

    // 以下三条是模仿call进入thread_start执行的栈内布局构建的，call进入就会压入参数与返回地址，因为我们是ret进入kernel_thread执行的
    // 要想让kernel_thread正常执行，就必须人为给它造返回地址，参数
    void(*unused_retaddr); // 参数 unused_ret 只为占位置充数为返回地址
    thread_func *function; // Kernel_thread运行所需要的函数地址
    void *func_arg;        // Kernel_thread运行所需要的参数地址
};

/* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/
struct task_struct
{
    uint32_t *self_kstack; // 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息
    enum task_status status;
    uint8_t priority;     // 线程优先级
    char name[16];        // 用于存储自己的线程的名字
    uint32_t stack_magic; // 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界
};

void thread_create(struct task_struct *pthread, thread_func function, void *func_arg);
void init_thread(struct task_struct *pthread, char *name, int prio);
struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_arg);

#endif
```

线程的实现(yourPath/chapter9/a/thread/thread.c)：

```C
#include "thread.h"
#include "stdint.h"
#include "string.h"
#include "global.h"
#include "memory.h"

#define PG_SIZE 4096

/* 由kernel_thread去执行function(func_arg) , 这个函数就是线程中去开启我们要运行的函数*/
static void kernel_thread(thread_func *function, void *func_arg)
{
    function(func_arg);
}

/*用于根据传入的线程的pcb地址、要运行的函数地址、函数的参数地址来初始化线程栈中的运行信息，核心就是填入要运行的函数地址与参数 */
void thread_create(struct task_struct *pthread, thread_func function, void *func_arg)
{
    /* 先预留中断使用栈的空间,可见thread.h中定义的结构 */
    // pthread->self_kstack -= sizeof(struct intr_stack);  //-=结果是sizeof(struct intr_stack)的4倍
    // self_kstack类型为uint32_t*，也就是一个明确指向uint32_t类型值的地址，那么加减操作，都是会是sizeof(uint32_t) = 4 的倍数
    pthread->self_kstack = (uint32_t *)((int)(pthread->self_kstack) - sizeof(struct intr_stack));

    /* 再留出线程栈空间,可见thread.h中定义 */
    // pthread->self_kstack -= sizeof(struct thread_stack);
    pthread->self_kstack = (uint32_t *)((int)(pthread->self_kstack) - sizeof(struct thread_stack));
    struct thread_stack *kthread_stack = (struct thread_stack *)pthread->self_kstack; // 我们已经留出了线程栈的空间，现在将栈顶变成一个线程栈结构体
                                                                                      // 指针，方便我们提前布置数据达到我们想要的目的
    kthread_stack->eip = kernel_thread; // 我们将线程的栈顶指向这里，并ret，就能直接跳入线程启动器开始执行。
                                        // 为什么这里我不能直接填传入进来的func，这也是函数地址啊，为什么还非要经过一个启动器呢？其实是可以不经过线程启动器的

    // 因为用不着，所以不用初始化这个返回地址kthread_stack->unused_retaddr
    kthread_stack->function = function; // 将线程启动器（thread_start）需要运行的函数地址放入线程栈中
    kthread_stack->func_arg = func_arg; // 将线程启动器（thread_start）需要运行的函数所需要的参数地址放入线程栈中
    kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
}

/* 初始化线程基本信息 , pcb中存储的是线程的管理信息，此函数用于根据传入的pcb的地址，线程的名字等来初始化线程的管理信息*/
void init_thread(struct task_struct *pthread, char *name, int prio)
{
    memset(pthread, 0, sizeof(*pthread)); // 把pcb初始化为0
    strcpy(pthread->name, name);          // 将传入的线程的名字填入线程的pcb中
    pthread->status = TASK_RUNNING;       // 这个函数是创建线程的一部分，自然线程的状态就是运行态
    pthread->priority = prio;
    /* self_kstack是线程自己在内核态下使用的栈顶地址 */
    pthread->self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE); // 本操作系统比较简单，线程不会太大，就将线程栈顶定义为pcb地址
                                                                      //+4096的地方，这样就留了一页给线程的信息（包含管理信息与运行信息）空间
    pthread->stack_magic = 0x19870916; // /定义的边界数字，随便选的数字来判断线程的栈是否已经生长到覆盖pcb信息了
}

/* 创建一优先级为prio的线程,线程名为name,线程所执行的函数是function(func_arg) */
struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_arg)
{
    /* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
    struct task_struct *thread = get_kernel_pages(1); // 为线程的pcb申请4K空间的起始地址

    init_thread(thread, name, prio);           // 初始化线程的pcb
    thread_create(thread, function, func_arg); // 初始化线程的线程栈

    // 我们task_struct->self_kstack指向thread_stack的起始位置，然后pop升栈，
    // 到了通过线程启动器来的地址，ret进入去运行真正的实际函数
    // 通过ret指令进入，原因：1、函数地址与参数可以放入栈中统一管理；2、ret指令可以直接从栈顶取地址跳入执行
    asm volatile("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g"(thread->self_kstack) : "memory");
    return thread;
}
```

### 核心数据结构 双向链表

依靠线程的pcb之间形成的队列来实现线程的管理与调度，pcb之间形成的队列是为了通过一个pcb顺利找到下一个pcb。为了维护系统中的队列，通过实现双向链表实现队列。

定时双向链表结构和声明操作函数(yourPath/chapter9/b/lib/kernel/list.h)：

```C
#ifndef __LIB_KERNEL_LIST_H
#define __LIB_KERNEL_LIST_H
#include "global.h"

/**********   定义链表结点成员结构   ***********
 *结点中不需要数据成元,只要求前驱和后继结点指针*/
struct list_elem
{
    struct list_elem *prev; // 前躯结点
    struct list_elem *next; // 后继结点
};

/* 链表结构,用来管理整个队列 */
struct list
{
    /* head是队首,是固定不变的，不是第1个元素,第1个元素为head.next */
    struct list_elem head;
    /* tail是队尾,同样是固定不变的 */
    struct list_elem tail;
};

// 用于计算一个结构体成员在结构体中的偏移量
#define offset(struct_type, member_name) (int)(&(((struct_type *)0)->member_name))
// 用于通过一个结构体成员地址计算出整个结构体的起始地址
#define member_to_entry(struct_type, member_name, member_ptr) (struct_type *)((int)member_ptr - offset(struct_type, member_name))

void list_init (struct list*);
void list_insert_before(struct list_elem* before, struct list_elem* elem);
void list_push(struct list* plist, struct list_elem* elem);
void list_iterate(struct list* plist);
void list_append(struct list* plist, struct list_elem* elem);  
void list_remove(struct list_elem* pelem);
struct list_elem* list_pop(struct list* plist);
bool list_empty(struct list* plist);
uint32_t list_len(struct list* plist);
struct list_elem* list_traversal(struct list* plist, function func, int arg);
bool elem_find(struct list* plist, struct list_elem* obj_elem);

#endif
```

实现双向链表操作(yourPath/chapter9/b/lib/kernel/list.c)：

```c
#include "list.h"
#include "interrupt.h"

/* 初始化双向链表list */
void list_init(struct list *list)
{
    list->head.prev = NULL;
    list->head.next = &list->tail;
    list->tail.prev = &list->head;
    list->tail.next = NULL;
}

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem *before, struct list_elem *elem)
{
    enum intr_status old_status = intr_disable(); // 未来这个链表结点插入是用于修改task_struck队列的，这是个公共资源，所以需要不被切换走

    /* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/
    before->prev->next = elem;

    /* 更新elem自己的前驱结点为before的前驱,
     * 更新elem自己的后继结点为before, 于是before又回到链表 */
    elem->prev = before->prev;
    elem->next = before;

    /* 更新before的前驱结点为elem */
    before->prev = elem;

    intr_set_status(old_status); // 关中断之前是开着，那么现在就重新打开中断，如果关着，那么就继续关着
}

/* 添加元素到列表队首,类似栈push操作，添加结点到链表队首，类似于push操作, 参数1是链表的管理结点，参数2是一个新结点 */
void list_push(struct list *plist, struct list_elem *elem)
{
    list_insert_before(plist->head.next, elem); // 在队头插入elem
}

/* 追加元素到链表队尾,类似队列的先进先出操作，添加结点到队尾，实际上就是添加结点到管理结点之前。参数是管理结点与要添加的结点 */
void list_append(struct list *plist, struct list_elem *elem)
{
    list_insert_before(&plist->tail, elem); // 在队尾的前面插入
}

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem *pelem)
{
    enum intr_status old_status = intr_disable();

    pelem->prev->next = pelem->next;
    pelem->next->prev = pelem->prev;

    intr_set_status(old_status);
}

/* 将链表第一个元素弹出并返回,类似栈的pop操作，参数是链表的管理结点（入口结点） */
struct list_elem *list_pop(struct list *plist)
{
    struct list_elem *elem = plist->head.next;
    list_remove(elem);
    return elem;
}

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list *plist, struct list_elem *obj_elem)
{
    struct list_elem *elem = plist->head.next;
    while (elem != &plist->tail)
    {
        if (elem == obj_elem)
        {
            return true;
        }
        elem = elem->next;
    }
    return false;
}

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem *list_traversal(struct list *plist, function func, int arg)
{
    struct list_elem *elem = plist->head.next;
    /* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
    if (list_empty(plist))
    {
        return NULL;
    }

    while (elem != &plist->tail)
    {
        if (func(elem, arg))
        { // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
            return elem;
        } // 若回调函数func返回true,则继续遍历
        elem = elem->next;
    }
    return NULL;
}

/* 返回链表长度，不包含管理结点，参数就是链表的管理结点 */
uint32_t list_len(struct list *plist)
{
    struct list_elem *elem = plist->head.next;
    uint32_t length = 0;
    while (elem != &plist->tail)
    {
        length++;
        elem = elem->next;
    }
    return length;
}

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list *plist)
{ // 判断队列是否为空
    return (plist->head.next == &plist->tail ? true : false);
}
```

### 简单优先级调度的基础

添加配合多线程调度的相关数据结构(yourPath/chapter9/c/thread/thread.h)：在pcb结构添加相关内容

```C
/* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/
struct task_struct
{
    uint32_t *self_kstack; // 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息
    enum task_status status;
    uint8_t priority; // 线程优先级
    char name[16];    // 用于存储自己的线程的名字

    uint8_t ticks;                 // 线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时
    uint32_t elapsed_ticks;        // 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/
    struct list_elem general_tag;  // general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点
    struct list_elem all_list_tag; // all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点
    uint32_t *pgdir;               // 进程自己页表的虚拟地址

    uint32_t stack_magic; // 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界
};
```

完成多线程调度(yourPath/chapter9/c/thread/thread.c)

```c
struct task_struct *main_thread;     // 主线程PCB
struct list thread_ready_list;       // 就绪队列
struct list thread_all_list;         // 所有任务队列
static struct list_elem *thread_tag; // 用于保存队列中的线程结点

extern void switch_to(struct task_struct *cur, struct task_struct *next);

/* 获取当前线程pcb指针 */
struct task_struct *running_thread()
{
    uint32_t esp;
    asm("mov %%esp, %0" : "=g"(esp));
    /* 取esp整数部分即pcb起始地址 */
    return (struct task_struct *)(esp & 0xfffff000); // 栈指针的高20位
}

/* 由kernel_thread去执行function(func_arg) , 这个函数就是线程中去开启我们要运行的函数 */
/* 这里的任务调度机制是基于时钟中断的 */
static void kernel_thread(thread_func *function, void *func_arg)
{
    /* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */
    intr_enable();
    function(func_arg);
}
/* 初始化线程基本信息 , pcb中存储的是线程的管理信息，此函数用于根据传入的pcb的地址，线程的名字等来初始化线程的管理信息*/
void init_thread(struct task_struct *pthread, char *name, int prio)
{
    memset(pthread, 0, sizeof(*pthread)); // 把pcb初始化为0
    strcpy(pthread->name, name);          // 将传入的线程的名字填入线程的pcb中

    if (pthread == main_thread)
    {
        pthread->status = TASK_RUNNING; // 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
    }
    else
    {
        pthread->status = TASK_READY;
    }
    pthread->priority = prio;
    /* self_kstack是线程自己在内核态下使用的栈顶地址 */
    pthread->ticks = prio;
    pthread->elapsed_ticks = 0;
    pthread->pgdir = NULL;                                            // 线程没有自己的地址空间，进程的pcb这一项才有用，指向自己的页表虚拟地址
    pthread->self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE); // 本操作系统比较简单，线程不会太大，就将线程栈顶定义为pcb地址
                                                                      //+4096的地方，这样就留了一页给线程的信息（包含管理信息与运行信息）空间
    pthread->stack_magic = 0x19870916; // /定义的边界数字，随便选的数字来判断线程的栈是否已经生长到覆盖pcb信息了
}

/* 创建一优先级为prio的线程,线程名为name,线程所执行的函数是function(func_arg) */
struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_arg)
{
    /* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
    struct task_struct *thread = get_kernel_pages(1); // 为线程的pcb申请4K空间的起始地址

    init_thread(thread, name, prio);           // 初始化线程的pcb
    thread_create(thread, function, func_arg); // 初始化线程的线程栈

    /* 确保之前不在队列中 */
    ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
    /* 加入就绪线程队列 */
    list_append(&thread_ready_list, &thread->general_tag);

    /* 确保之前不在队列中 */
    ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
    /* 加入全部线程队列 */
    list_append(&thread_all_list, &thread->all_list_tag);
    /* 在队列中的节点是PCB的成员general_tag或者all_list_tag */
    /* 通过tag将在内存散落的PCB块，串联为双向链表，即模拟队列 */

    return thread;
}

/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void)
{
    /* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp,0xc009f000,
    就是为其预留了tcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页*/
    main_thread = running_thread();
    init_thread(main_thread, "main", 31);

    /* main函数是当前线程,当前线程不在thread_ready_list中,
     * 所以只将其加在thread_all_list中. */
    ASSERT(!elem_find(&thread_all_list, &main_thread->all_list_tag));
    list_append(&thread_all_list, &main_thread->all_list_tag);
}
```

### 任务调度器和任务切换

线程的pcb中存储着线程栈的位置，而线程栈中又存储着线程的运行所需要运行的一系列信息，通过这些信息，可以进入线程执行。在线程执行过程中，每一次时钟中断都会修改线程pcb中的允许运行的时间值，当一个线程的所允许被执行的时间归零。那么就执行调度，就是从就绪队列中找到下一个线程的general_tag，取出时将general_tag还原为PCB，进而找到线程栈中的运行信息，并进入执行。

完整的调度过程由以下三部分的配合：

1. 时钟中断处理函数
2. 调度器 schedule：调度机制采用轮询调度
3. 任务切换函数 switch_to

注册时钟中断处理函数(yourPath/chapter9/c/device/timer.c)：增加时钟中断处理函数intr_timer_handler，其主要功能就是每发生一次时钟中断，就增加一次ticks与当前正在运行的线程的pcb中的时间，如果时间到期，那么就运行切换程序schedule进行切换

```C
uint32_t ticks; // ticks是内核自中断开启以来总共的嘀嗒数

/* 时钟的中断处理函数 */
static void intr_timer_handler(void)
{
    struct task_struct *cur_thread = running_thread();

    ASSERT(cur_thread->stack_magic == 0x19870916); // 检查栈是否溢出

    cur_thread->elapsed_ticks++; // 记录此线程占用的cpu时间嘀
    ticks++;                     // 从内核第一次处理时间中断后开始至今的滴哒数,内核态和用户态总共的嘀哒数

    if (cur_thread->ticks == 0)
    { // 若进程时间片用完就开始调度新的进程上cpu
        schedule();
    }
    else
    { // 将当前进程的时间片-1
        cur_thread->ticks--;
    }
}

/* 初始化PIT8253 */
void timer_init()
{
    put_str("timer_init start\n");
    /* 设置8253的定时周期,也就是发中断的周期 */
    frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
    register_handler(0x20, intr_timer_handler);
    put_str("timer_init done\n");
}
```

修改通用中断处理函数general_intr_handler，增加修改光标位置打印错误新的的代码，原因是多线程切换引发的同步问题，有时候会引发光标值超过允许范围，这个范围是显存段段描述符的界限决定的，如果这时候由光标值超限引发的中断，然后调用general_intr_handler去打印信息，将再次导致异常，那么就不会输出错误信息，set_cursor是光标的置0，通过汇编实现。

```c
/* 通用的中断处理函数,用于初始化,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr)
{
   if (vec_nr == 0x27 || vec_nr == 0x2f)
   { // 伪中断向量，无需处理。详见书p337
      return;
   }
   /* 将光标置为0,从屏幕左上角清出一片打印异常信息的区域,方便阅读 */
   set_cursor(0);
   int cursor_pos = 0;
   while (cursor_pos < 320)
   {
      put_char(' ');
      cursor_pos++;
   }
   set_cursor(0); // 重置光标为屏幕左上角
   put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
   set_cursor(88); // 从第2行第8个字符开始打印
   put_str(intr_name[vec_nr]);
   if (vec_nr == 14)
   { // 若为Pagefault,将缺失的地址打印出来并悬停
      int page_fault_vaddr = 0;
      asm("movl %%cr2, %0" : "=r"(page_fault_vaddr)); // cr2是存放造成page_fault的地址
      put_str("\npage fault addr is ");
      put_int(page_fault_vaddr);
   }
   put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
   // 能进入中断处理程序就表示已经处在关中断情况下,
   // 不会出现调度进程的情况。故下面的死循环不会再被中断。
   while (1)
      ;
}

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function)
{
   /* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
    * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function;
}
```

实现set_cursor(yourPath/chapter9/c/lib/kernel/print.S)：

```ASM
global set_cursor
set_cursor:
    pushad
    mov bx, [esp+36]
															; ;;;;;; 1 先设置高8位 ;;;;;;;;
    mov dx, 0x03d4			  								; 索引寄存器
    mov al, 0x0e				  						    ; 用于提供光标位置的高8位
    out dx, al
    mov dx, 0x03d5			  								; 通过读写数据端口0x3d5来获得或设置光标位置 
    mov al, bh
    out dx, al

															; ;;;;;; 2 再设置低8位 ;;;;;;;;;
    mov dx, 0x03d4
    mov al, 0x0f
    out dx, al
    mov dx, 0x03d5 
    mov al, bl
    out dx, al
    popad
    ret
```

实现调度器 schedule(yourPath/chapter9/c/thread/thread.c)：

```C
/* 实现任务调度 */
void schedule()
{
    ASSERT(intr_get_status() == INTR_OFF);
    struct task_struct *cur = running_thread();
    if (cur->status == TASK_RUNNING)
    { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
        ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
        list_append(&thread_ready_list, &cur->general_tag);
        cur->ticks = cur->priority; // 重新将当前线程的ticks再重置为其priority;
        cur->status = TASK_READY;
    }
    else
    {
        /* 若此线程需要某事件发生后才能继续上cpu运行,
        不需要将其加入队列,因为当前线程不在就绪队列中。*/
    }

    ASSERT(!list_empty(&thread_ready_list));
    thread_tag = NULL; // thread_tag清空
                       /* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
    thread_tag = list_pop(&thread_ready_list);
    struct task_struct *next = elem2entry(struct task_struct, general_tag, thread_tag);
    next->status = TASK_RUNNING;
    switch_to(cur, next);
}
```

实现tag到pcb的转换 elem2entry (yourPath/chapter9/c/lib/kernel/lish.h)：包括了地址转换和类型转换

```C
// 用于计算一个结构体成员在结构体中的偏移量
#define offset(struct_type, member) (int)(&((struct_type *)0)->member)

// 用于通过一个结构体成员地址计算出整个结构体的起始地址
#define elem2entry(struct_type, struct_member_name, elem_ptr) \
    (struct_type *)((int)elem_ptr - offset(struct_type, struct_member_name))
```

实现任务切换函数 switch_to (yourPath/chapter/c/thread/switch_to.S)：

上下文保护的第一部分负责保存任务进入中断前的全部寄存器，目的是能让任务恢复到中断前。已经由kernel.S中的intr%1entry实现。

上下文保护的第二部分负责保存这 4 个寄存器：esi、edi、ebx 和 ebp，目的是让任务恢复执行在任务切换发生时剩下尚未执行的内核代码，保证顺利走到退出中断的出口，利用第一部分保护的寄存器环境彻底恢复任务。以下是第二部分的实现。

```ASM
[bits 32]
section .text
global switch_to
switch_to:
    ;栈中此处是返回地址	       
    push esi                      	;这4条就是对应压入线程栈中预留的ABI标准要求保存的，esp会保存在其他地方
    push edi
    push ebx
    push ebp

    mov eax, [esp + 20]		      	; 得到栈中的参数cur, cur = [esp+20]
    mov [eax], esp                	; 保存栈顶指针esp. task_struct的self_kstack字段,
									; self_kstack在task_struct中的偏移为0,
									; 所以直接往thread开头处存4字节便可。
									;------------------  以上是备份当前线程的环境，下面是恢复下一个线程的环境  ----------------
    mov eax, [esp + 24]		 		; 得到栈中的参数next, next = [esp+24]
    mov esp, [eax]		 			; pcb的第一个成员是self_kstack成员,用来记录0级栈顶指针,
									; 用来上cpu时恢复0级栈,0级栈中保存了进程或线程所有信息,包括3级栈指针
    pop ebp
    pop ebx
    pop edi
    pop esi
    ret				 				; 返回到上面switch_to下面的那句注释的返回地址,
									; 未由中断进入,第一次执行时会返回到kernel_thread
```

启用线程调度(yourPath/chapter9/c/kernel/main.c)：

由于多线程引起的同步问题，会让光标值位置超过显存段段描述符规定的界限而引发错误，所以我们可以在执行线程时候关闭中断，然后运行完毕之后打开中断，以确保线程的原子执行，来杜绝此类问题。

```C
#include "print.h"
#include "init.h"
#include "thread.h"
#include "interrupt.h"

void k_thread_a(void *);
void k_thread_b(void *);
int main(void)
{
   put_str("I am kernel\n");
   init_all();
   int i = 999999;
   thread_start("k_thread_a", 31, k_thread_a, "argA ");
   thread_start("k_thread_b", 31, k_thread_b, "argB ");

   intr_enable(); // 打开中断,使时钟中断起作用
   while (1)
   {
      while (i--)
         ;
      i = 999999;
      intr_disable();
      put_str("main ");
      intr_enable();
   }
   return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   int i = 9999999;
   char *tmp = arg;
   while (1)
   {
      while (i--)
         ;
      i = 999999;
      intr_disable();
      put_str(tmp);
      intr_enable();
   }
}

/* 在线程中运行的函数 */
void k_thread_b(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   int i = 9999999;
   char *tmp = arg;
   while (1)
   {
      while (i--)
         ;
      i = 999999;
      intr_disable();
      put_str(tmp);
      intr_enable();
   }
}
```

## 输入输出系统

### GP异常

还记得上一节提到的GP异常(一般保护性异常)吗?我们是通过在打印字符串前关闭中断和在打印字符串后打开中断，确保线程的原子性，来避免这个问题的。那为什么会出现这个问题呢？其实是因为多线程的同步问题，导致光标值光标值位置超过显存段段描述符规定的界限，从而导致GP异常的发生。

排查程序执行过程发现，GP异常出现在最基础的打印过程中，即put_str，而put_str又是put_char的集合。

分析put_char函数的工作原理发现，put_char分为3步微操作：

- 获取光标值
- 将光标值转换为字节地址，在该处写入字符
- 更新光标的值

以上就是打印一个字符的三个步骤。按理来说，这三个步骤必须一气呵成，要么全都完成，要么一个步骤都不做，总之打印字符这件事不可拆分，更确切地说，不能被调度机制拆分，说白了，就是要求字符打印执行过程中不能被切换成其他任务。字符打印过程中的三个步骤像原子一样不可拆分，因此字符打印必须具有原子性。但是由于每个任务都有时间片限制，迟早会执行人物调度，有可能在某次put_char的过程中发生任务调度，即将以上三步拆开，导致GP异常的发生。

既然是任务调度破坏了字符打印的原子性，而任务调度是由时钟中断引起的，所以可以通过在put_str前后关闭打开中断，保证打印过程的原子性，从而避免GP异常。

在main函数中修改(yourPath/chapter10/a/kernel/main.c)：

```C
#include "print.h"
#include "init.h"
#include "thread.h"
#include "interrupt.h"

void k_thread_a(void *);
void k_thread_b(void *);
int main(void)
{
   put_str("I am kernel\n");
   init_all();
   thread_start("k_thread_a", 31, k_thread_a, "argA ");
   thread_start("k_thread_b", 31, k_thread_b, "argB ");

   intr_enable(); // 打开中断,使时钟中断起作用
   while (1)
   {
      intr_disable();
      put_str("main ");
      intr_enable();
   }
   return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   char *tmp = arg;
   while (1)
   {
      intr_disable();
      put_str(tmp);
      intr_enable();
   }
}

/* 在线程中运行的函数 */
void k_thread_b(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   char *tmp = arg;
   while (1)
   {
      intr_disable();
      put_str(tmp);
      intr_enable();
   }
}
```

### 基础概念

| 基础概念 |                                                              |
| -------- | ------------------------------------------------------------ |
| 公共资源 | 可以是公共内存、公共文件、公共硬件等，总之是被所有任务共享的一套资源 |
| 互斥     | 互斥也可称为排他，是指某一时刻公共资源只能被1个任务独享，其他任务想访问公共资源时，必须等待当前公共资源的访问者使用完资源后再开始访问。 |
| 临界区   | 程序要想使用某些资源，必然通过一些指令去访问这些资源，若多个任务都访问同一公共资源，那么各任务中访问公共资源的指令代码组成的区域就称为临界区。 |
| 竞争条件 | 竞争条件是指多个任务以非互斥的方式同时进入临界区，大家对公共资源的访问是以竞争的方式并行进行的，因此公共资源的最终状态依赖于这些任务的临界区中的微操作执行次序。 |

所以同步机制的核心，就是让公共资源在某一时刻只能被一个线程的临界区所访问，并且要让它执行完。

### 信号量

围绕上面的目的，提出了信号量的概念，它实质就是个计数器，有真实含义（如某个资源的数量），常见取值是0与1。当某个进程的临界区需要访问公共资源，就要去查询这个公共资源的信号量，只有信号量>0时（一般就是1），也就是资源可用，才能访问公共资源，此时该公共资源的信号量被减为0。另个进程此时要来访问这个公共资源，发现信号量为0，也就意味着自己需要的资源不可用，但是进程没有所需要的资源，就无法继续推进，所以最好的方法不是让进程在此处死等，而是将自己换下处理器让出处理器，这就是把自己阻塞起来，等待信号量为1后才能被唤醒运行。我们把只有0和1两种情况的信号量叫做二元信号量。

信号量的P V操作：

- P操作：信号量的减少操作，即down操作，其包含以下过程：
  - 判断信号量是否大于0。
  - 若信号量大于0，则将信号量减1。
  - 若信号量等于0，当前线程将自己阻塞，以在此信号量上等待。
- V操作：信号量的增加操作，即up操作，其包含以下过程：
  -  将信号量的值加1。
  - 唤醒此信号量上等待的线程。

所以，同步机制的核心，现在就变成了，获得信号量的进程才可以运行，没有获得信号量的进程把自己阻塞起来，获得信号量的进程运行完毕释放信号量的时候，要把阻塞起来的进程唤醒，唤醒就是把阻塞进程的pcb从信号量的阻塞队列移入就绪队列。

为实现同步机制，首先要实现线程的阻塞和线程的唤醒(yourPath/chapter10/b/thread/thread.c)：

```C
// 将当前正在运行的线程pcb中的状态字段设定为传入的status,一般用于线程主动设定阻塞
void thread_block(enum task_status stat)
{
    /* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
    ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
    enum intr_status old_status = intr_disable();      // 先关闭中断,因为涉及要修改阻塞队列，调度
    struct task_struct *cur_thread = running_thread(); // 得到当前正在运行的进程的pcb地址
    cur_thread->status = stat;                         // 置其状态为stat
    schedule();                                        // 将当前线程换下处理器
                                                       /* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
    intr_set_status(old_status);
}
/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct *pthread)
{
    enum intr_status old_status = intr_disable(); // 涉及队就绪队列的修改，此时绝对不能被切换走
    ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
    if (pthread->status != TASK_READY)
    {
        ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
        if (elem_find(&thread_ready_list, &pthread->general_tag))
        {
            PANIC("thread_unblock: blocked thread in ready_list\n");
        }
        list_push(&thread_ready_list, &pthread->general_tag); // 放到队列的最前面,使其尽快得到调度
        pthread->status = TASK_READY;
    }
    intr_set_status(old_status);
}
```

### 使用锁机制实现终端输出

实现对二元信号量的有序分配。首先为信号量与锁建立数据结构。信号量与锁的关系：信号量是对某项资源的管理，实际就是表示资源有多少，与哪些线程在等待这个资源。锁是在信号量机制上实现的，相比信号量多了记录谁造成了锁（也就是二元信号量，或者叫资源分配给了谁）。然后实现有关于信号量与锁的函数，包含初始化信号量，初始化锁，对信号量的pv操作（代码中是down与up），获取锁与释放锁。最后利用锁机制，建立锁console_lock（意为终端锁）用于协调打印，将原有的put_int，put_char，put_str进行封装。

建立信号量与锁的数据结构(yourPath/chapter10/b/thread/sync.h)：

```C
#ifndef __THREAD_SYNC_H
#define __THREAD_SYNC_H
#include "list.h"
#include "stdint.h"
#include "thread.h"

/* 信号量结构 */
struct semaphore
{
    uint8_t value;       // 一个信号量肯定有值来表示这个量
    struct list waiters; // 用一个双链表结点来管理所有阻塞在该信号量上的线程
};

/* 锁结构 */
struct lock
{
    struct task_struct *holder; // 用于记录谁把二元信号量申请走了，而导致了该信号量的锁
    struct semaphore semaphore; // 一个锁肯定是来管理信号量的
    uint32_t holder_repeat_nr;  // 有时候线程拿到了信号量，但是线程内部不止一次使用该信号量对应公共资源，就会不止一次申请锁
                                // 内外层函数在释放锁时就会对一个锁释放多次，所以必须要记录重复申请的次数
};

void sema_init(struct semaphore *psema, uint8_t value); // 初始化信号量
void sema_down(struct semaphore *psema);                // 信号量down操作 P操作
void sema_up(struct semaphore *psema);                  // 信号量up操作 V操作
void lock_init(struct lock *plock);                     // 初始化锁
void lock_acquire(struct lock *plock);                  // 申请锁
void lock_release(struct lock *plock);                  // 释放锁

#endif
```

实现有关于信号量和锁的操作函数(yourPath/chapter10/b/thread/sync.c)：

```C
#include "sync.h"
#include "list.h"
#include "global.h"
#include "debug.h"
#include "interrupt.h"

// 用于初始化信号量，传入参数就是指向信号量的指针与初值
void sema_init(struct semaphore *psema, uint8_t value)
{
    psema->value = value;       // 为信号量赋初值
    list_init(&psema->waiters); // 初始化信号量的等待队列
}

// 用于初始化锁，传入参数是指向该锁的指针
void lock_init(struct lock *plock)
{
    plock->holder = NULL;
    plock->holder_repeat_nr = 0;
    sema_init(&plock->semaphore, 1); // 将信号量初始化为1，因为此函数一般处理二元信号量
}

// 信号量的down操作，也就是减1操作，传入参数是指向要操作的信号量指针。线程想要申请信号量的时候用此函数
void sema_down(struct semaphore *psema)
{
    enum intr_status old_status = intr_disable(); // 对于信号量的操作是必须关中断的

    // 一个自旋锁，来不断判断是否信号量已经被分配出去了。为什么不用if，见书p450。
    while (psema->value == 0)
    { // 若value为0,表示已经被别人持有
        ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
        /* 当前线程不应该已在信号量的waiters队列中 */
        if (elem_find(&psema->waiters, &running_thread()->general_tag))
        {
            PANIC("sema_down: thread blocked has been in waiters_list\n");
        }
        // 如果此时信号量为0，那么就将该线程加入阻塞队列,为什么不用判断是否在阻塞队列中呢？因为线程被阻塞后，会加入阻塞队列，除非被唤醒，否则不会
        // 分配到处理器资源，自然也不会重复判断是否有信号量，也不会重复加入阻塞队列
        list_append(&psema->waiters, &running_thread()->general_tag);
        thread_block(TASK_BLOCKED); // 阻塞线程,直到被唤醒
    }
    /* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
    psema->value--;
    ASSERT(psema->value == 0);
    /* 恢复之前的中断状态 */
    intr_set_status(old_status);
}

// 信号量的up操作，也就是+1操作，传入参数是指向要操作的信号量的指针。且释放信号量时，应唤醒阻塞在该信号量阻塞队列上的一个进程
void sema_up(struct semaphore *psema)
{
    /* 关中断,保证原子操作 */
    enum intr_status old_status = intr_disable();
    ASSERT(psema->value == 0);
    if (!list_empty(&psema->waiters))
    { // 判断信号量阻塞队列应为非空，这样才能执行唤醒操作
        struct task_struct *thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
        thread_unblock(thread_blocked);
    }
    psema->value++;
    ASSERT(psema->value == 1);
    /* 恢复之前的中断状态 */
    intr_set_status(old_status);
}

// 获取锁的函数,传入参数是指向锁的指针
void lock_acquire(struct lock *plock)
{
    // 这是为了排除掉线程自己已经拿到了锁，但是还没有释放就重新申请的情况
    if (plock->holder != running_thread())
    {
        sema_down(&plock->semaphore); // 对信号量进行down操作
        plock->holder = running_thread();
        ASSERT(plock->holder_repeat_nr == 0);
        plock->holder_repeat_nr = 1; // 申请了一次锁
    }
    else
    {
        plock->holder_repeat_nr++;
    }
}

// 释放锁的函数，参数是指向锁的指针
void lock_release(struct lock *plock)
{
    ASSERT(plock->holder == running_thread());
    // 如果>1，说明自己多次申请了该锁，现在还不能立即释放锁
    if (plock->holder_repeat_nr > 1)
    {
        plock->holder_repeat_nr--;
        return;
    }
    ASSERT(plock->holder_repeat_nr == 1); // 判断现在lock的重复持有数是不是1只有为1，才能释放

    plock->holder = NULL; // 这句必须放在up操作前，因为现在并不在关中断下运行，有可能会被切换出去，如果在up后面，就可能出现还没有置空，
                          // 就切换出去，此时有了信号量，下个进程申请到了，将holder改成下个进程，这个进程切换回来就把holder改成空，就错了
    plock->holder_repeat_nr = 0;
    sema_up(&plock->semaphore); // 信号量的V操作,也是原子操作
}
```

建立终端锁，封装打印函数(yourPath/chapter10/b/device/console.c)：

```C
#include "console.h"
#include "print.h"
#include "stdint.h"
#include "sync.h"
#include "thread.h"
static struct lock console_lock; // 控制台锁(终端锁)

/* 初始化终端 */
void console_init()
{
    lock_init(&console_lock);
}

/* 获取终端 */
void console_acquire()
{
    lock_acquire(&console_lock);
}

/* 释放终端 */
void console_release()
{
    lock_release(&console_lock);
}

/* 终端中输出字符串 */
void console_put_str(char *str)
{
    console_acquire();
    put_str(str);
    console_release();
}

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci)
{
    console_acquire();
    put_char(char_asci);
    console_release();
}

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num)
{
    console_acquire();
    put_int(num);
    console_release();
}
```

为其建立头文件(yourPath/chapter10/b/device/console.h)：

```C
#ifndef __DEVICE_CONSOLE_H
#define __DEVICE_CONSOLE_H
#include "stdint.h"
void console_init(void);
void console_acquire(void);
void console_release(void);
void console_put_str(char* str);
void console_put_char(uint8_t char_asci);
void console_put_int(uint32_t num);
#endif
```

在init_all中加入console_init(yourPath/chapter10/b/kernel/init.c)：

```C
#include "init.h"
#include "print.h"
#include "interrupt.h"
#include "timer.h"
#include "memory.h"
#include "thread.h"
#include "console.h"

/*负责初始化所有模块 */
void init_all()
{
    put_str("init_all\n");
    idt_init();    // 初始化中断
    mem_init();    // 初始化内存管理系统
    thread_init(); // 初始化线程相关结构
    timer_init();
    console_init();
}
```

测试(yourPath/chapter10/b/kernel/main.c)：

```C
#include "print.h"
#include "init.h"
#include "thread.h"
#include "interrupt.h"
#include "console.h"

void k_thread_a(void *);
void k_thread_b(void *);

int main(void)
{
   put_str("I am kernel\n");
   init_all();

   thread_start("k_thread_a", 31, k_thread_a, "argA ");
   thread_start("k_thread_b", 8, k_thread_b, "argB ");

   intr_enable();
   while (1)
   {
      console_put_str("Main ");
   };
   return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   char *para = arg;
   while (1)
   {
      console_put_str(para);
   }
}

/* 在线程中运行的函数 */
void k_thread_b(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   char *para = arg;
   while (1)
   {
      console_put_str(para);
   }
}
```

### 实现键盘输入

编写键盘输入程序，当随意按下键盘按键时，bochs中打印k，按住不送的话，连续打印k。

键盘是独立的外设，其内部有个叫做键盘编码器的芯片，它的作用是：每当键盘上发生按键操作，它就向键盘控制器报告哪个键被按下，按键是否弹起。

键盘编码器：8048或者其他兼容芯片，在键盘内部。

键盘控制器：8042，在主机内部的主板上。

![8048-8042-80259A的关系示意图](/home/zhj/.config/Typora/typora-user-images/image-20240820162416494.png)

8048和8042之间必须要达成某种协议，即对键盘上所有的按键进行编码，为每一个按键分配唯一的数字。因此所有按键对应的数值便组成了一张表，即键盘扫描码。扫描码（通码与断码合称扫描码）由键盘编码器决定，不同的键盘编码器会产生不同的编码方案，如今有三套：

- scan code set 1, 应用：XT 键盘

- scan code set 2, 应用：AT 键盘
- scan code set 3, 应用：IBM PS/2 系列高端计算机所用键盘

现在大多数用的都是第二套，因此大多数键盘向 8042 发生的都是第二套的扫描码，为了兼容，不管我们用的是第几套编码方案，当键盘发送扫描码到 8042 后，由 8042 进行处理，转为第一套扫描码，这也是 8042 存在的理由之一。因此我们只需要在键盘的中断处理程序中只处理第一套扫描码就可以了。

键盘按键被按下后的流程：

1. 当键位被按下时，不放手即不弹起。
2. 8048监控哪个键盘被按下，8048把对应的通码(用于描述一个键按下的码，断码是描述一个键松开的码)发送给8042，如果不松开，那么将持续发送。
3. 8042接受到通码后，便知道具体的哪个键位被按下了，对其进行处理，接着保存通码到自己的寄存器。
4. 8042接着向中断代理8259A发送中断，如果不松开，那么将持续发送中断。
5. 发生中断后，处理器执行对应的中断处理程序。

键盘按键弹起的过程和按键被按下的过程是一致的，只是在第2步中，8048将对应的断码发送给8042。

### 8042 简介

8042是键盘控制器，也就是键盘的 IO 接口， 因此它是 8048 的代理。8048 通过 PS/2、USB 等接口与 8042 通信，处理器通过端口与 8042 通信。8042 是 8048 的 IO 接口，所以对 8048 的编程也是通过 8042 完成的。

8042拥有4个8位寄存器：

![8042寄存器示意表](/home/zhj/.config/Typora/typora-user-images/image-20240903212609415.png)

8042 是连接 8048 和处理器的桥梁，8042 存在的目的是：为了处理器可以通过它控制 8048 的工作方 式，然后让 8048 的工作成果通过 8042 回传给处理器。此时 8042 就相当于数据的缓冲区、中转站，根据数 据被发送的方向，8042 的作用分别是输入和输出。如图所示：

![8042作用示意图](/home/zhj/.config/Typora/typora-user-images/image-20240903212711228.png)

- 输出缓冲区寄存器：
  -  8 位宽度的寄存器，只读，键盘驱动程序从此寄存器中通过 in 指令读 取来自 8048 的扫描码、来自 8048 的命令应答以及对 8042 本身设置时，8042 自身的应答也从该寄存器中获取。 注意，输出缓冲区寄存器中的扫描码是给处理器准备的，在处理器未读取之前，8042 不会再往此寄 存器中存入新的扫描码。

- 输入缓冲区寄存器 8 位宽度的寄存器，只写，键盘驱动程序通过 out 指令向此寄存器写入对 8048 的控制命令、参数等， 对于 8042 本身的控制命令也是写入此寄存器。 
- 状态寄存器 8 位宽度的寄存器，只读，反映 8048 和 8042 的内部工作状态。
  - 位 0：置 1 时表示输出缓冲区寄存器已满，处理器通过 in 指令读取后该位自动置 0。 
  - 位 1：置 1 时表示输入缓冲区寄存器已满，8042 将值读取后该位自动置 0。
  - 位 2：系统标志位，最初加电时为 0，自检通过后置为 1。 
  - 位 3：置 1 时，表示输入缓冲区中的内容是命令，置 0 时，输入缓冲区中的内容是普通数据。 
  - 位 4：置 1 时表示键盘启用，置 0 时表示键盘禁用。 
  - 位 5：置 1 时表示发送超时。 
  - 位 6：置 1 时表示接收超时。 
  - 位 7：来自 8048 的数据在奇偶校验时出错。 
-  控制寄存器 8 位宽度的寄存器，只写，用于写入命令控制字。
  - 位 0：置 1 时启用键盘中断。 
  - 位 1：置 1 时启用鼠标中断。 
  - 位 2：设置状态寄存器的位 2。 
  - 位 3：置 1 时，状态寄存器的位 4 无效。 
  - 位 4：置 1 时禁止键盘。 
  - 位 5：置 1 时禁止鼠标。 
  - 位 6：将第二套键盘扫描码转换为第一套键盘扫描码。 
  - 位 7：保留位，默认为 0。

### 编写键盘中断处理程序

和时钟中断一样，先在kernel.S定义中断入口，将中断向量号作为idt_table的索引，最终调用C语言版本的中断处理程序。

定义中断入口(yourPath/chapter10/c/kernel/kernel.S)：

```ASM
VECTOR 0x20,ZERO	;时钟中断对应的入口
VECTOR 0x21,ZERO	;键盘中断对应的入口
VECTOR 0x22,ZERO	;级联用的
VECTOR 0x23,ZERO	;串口2对应的入口
VECTOR 0x24,ZERO	;串口1对应的入口
VECTOR 0x25,ZERO	;并口2对应的入口
VECTOR 0x26,ZERO	;软盘对应的入口
VECTOR 0x27,ZERO	;并口1对应的入口
VECTOR 0x28,ZERO	;实时时钟对应的入口
VECTOR 0x29,ZERO	;重定向
VECTOR 0x2a,ZERO	;保留
VECTOR 0x2b,ZERO	;保留
VECTOR 0x2c,ZERO	;ps/2鼠标
VECTOR 0x2d,ZERO	;fpu浮点单元异常
VECTOR 0x2e,ZERO	;硬盘
VECTOR 0x2f,ZERO	;保留
```

为测试简单，屏蔽时钟中断(yourPath/chapter10/c/kernel/interrupt.c)：

```C
static void pic_init(void)
{

   /* 初始化主片 */
   outb(PIC_M_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb(PIC_M_DATA, 0x20); // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
   outb(PIC_M_DATA, 0x04); // ICW3: IR2接从片.
   outb(PIC_M_DATA, 0x01); // ICW4: 8086模式, 正常EOI

   /* 初始化从片 */
   outb(PIC_S_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb(PIC_S_DATA, 0x28); // ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
   outb(PIC_S_DATA, 0x02); // ICW3: 设置从片连接到主片的IR2引脚
   outb(PIC_S_DATA, 0x01); // ICW4: 8086模式, 正常EOI

   /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */
   // outb(PIC_M_DATA, 0xfe);
   // outb(PIC_S_DATA, 0xff);

   /* 测试键盘,只打开键盘中断，其它全部关闭 */
   outb (PIC_M_DATA, 0xfd);   //键盘中断在主片ir1引脚上，所以将这个引脚置0，就打开了
   outb (PIC_S_DATA, 0xff);

   put_str("   pic_init done\n");
}
```

编写键盘中断处理程序(yourPath/chapter10/c/device/keyboard.c)：

```C
#include "keyboard.h"
#include "print.h"
#include "interrupt.h"
#include "io.h"
#include "global.h"

#define KBD_BUF_PORT 0x60 // 键盘buffer寄存器端口号为0x60

// /* 键盘中断处理程序 */
// static void intr_keyboard_handler(void)
// {
//     put_char('k');
//     // 每次必须要从8042读走键盘8048传递过来的数据，否则8042不会接收后续8048传递过来的数据
//     inb(KBD_BUF_PORT);
//     return;
// }

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void)
{
    /* 必须要读取输出缓冲区寄存器，否则 8042 不再继续响应键盘中断 */
    uint8_t scancode = inb(KBD_BUF_PORT);
    put_int(scancode);
    return;
}

/* 键盘初始化 */
void keyboard_init()
{
    put_str("keyboard init start\n");
    register_handler(0x21, intr_keyboard_handler); // 注册键盘中断处理函数
    put_str("keyboard init done\n");
}
```

编写测试程序(yourPath/chapter10/c/kernel/main.c)：

```c
#include "print.h"
#include "init.h"
#include "thread.h"
#include "interrupt.h"
#include "console.h"

void k_thread_a(void *);
void k_thread_b(void *);

int main(void)
{
   put_str("I am kernel\n");
   init_all();

   //   thread_start("k_thread_a", 31, k_thread_a, "argA ");
   //   thread_start("k_thread_b", 8, k_thread_b, "argB ");

   intr_enable();
   while (1)
      ; //{
   // console_put_str("Main ");
   // };
   return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   char *para = arg;
   while (1)
   {
      console_put_str(para);
   }
}

/* 在线程中运行的函数 */
void k_thread_b(void *arg)
{
   /* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */
   char *para = arg;
   while (1)
   {
      console_put_str(para);
   }
}
```

### 编写键盘驱动

![键盘驱动是实现过程示意图](/home/zhj/.config/Typora/typora-user-images/image-20240903220107873.png)

三种控制是指：

- 是否按下CAPSLOCK
- 是否按下CTRL
- 是否按下ALT

完善键盘驱动程序(yourPath/chapter10/d/device/keyboard.c)：

```C
#include "keyboard.h"
#include "print.h"
#include "interrupt.h"
#include "io.h"
#include "global.h"

#define KBD_BUF_PORT 0x60 // 键盘buffer寄存器端口号为0x60

#define esc '\033' // esc 和 delete都没有\转义字符这种形式，用8进制代替
#define delete '\0177'
#define enter '\r'
#define tab '\t'
#define backspace '\b'

#define char_invisible 0 // 功能性 不可见字符均设置为0
#define ctrl_l_char char_invisible
#define ctrl_r_char char_invisible
#define shift_l_char char_invisible
#define shift_r_char char_invisible
#define alt_l_char char_invisible
#define alt_r_char char_invisible
#define caps_lock_char char_invisible

/// 定义控制字符的通码和断码
#define shift_l_make 0x2a
#define shift_r_make 0x36
#define alt_l_make 0x38
#define alt_r_make 0xe038
#define alt_r_break 0xe0b8
#define ctrl_l_make 0x1d
#define ctrl_r_make 0xe01d
#define ctrl_r_break 0xe09d
#define caps_lock_make 0x3a

// 二维数组，用于记录从0x00到0x3a通码对应的按键的两种情况（如0x02，不加shift表示1，加了shift表示！）的ascii码值
// 如果没有，则用ascii0替代
char keymap[][2] = {
    /* 0x00 */ {0, 0},
    /* 0x01 */ {esc, esc},
    /* 0x02 */ {'1', '!'},
    /* 0x03 */ {'2', '@'},
    /* 0x04 */ {'3', '#'},
    /* 0x05 */ {'4', '$'},
    /* 0x06 */ {'5', '%'},
    /* 0x07 */ {'6', '^'},
    /* 0x08 */ {'7', '&'},
    /* 0x09 */ {'8', '*'},
    /* 0x0A */ {'9', '('},
    /* 0x0B */ {'0', ')'},
    /* 0x0C */ {'-', '_'},
    /* 0x0D */ {'=', '+'},
    /* 0x0E */ {backspace, backspace},
    /* 0x0F */ {tab, tab},
    /* 0x10 */ {'q', 'Q'},
    /* 0x11 */ {'w', 'W'},
    /* 0x12 */ {'e', 'E'},
    /* 0x13 */ {'r', 'R'},
    /* 0x14 */ {'t', 'T'},
    /* 0x15 */ {'y', 'Y'},
    /* 0x16 */ {'u', 'U'},
    /* 0x17 */ {'i', 'I'},
    /* 0x18 */ {'o', 'O'},
    /* 0x19 */ {'p', 'P'},
    /* 0x1A */ {'[', '{'},
    /* 0x1B */ {']', '}'},
    /* 0x1C */ {enter, enter},
    /* 0x1D */ {ctrl_l_char, ctrl_l_char},
    /* 0x1E */ {'a', 'A'},
    /* 0x1F */ {'s', 'S'},
    /* 0x20 */ {'d', 'D'},
    /* 0x21 */ {'f', 'F'},
    /* 0x22 */ {'g', 'G'},
    /* 0x23 */ {'h', 'H'},
    /* 0x24 */ {'j', 'J'},
    /* 0x25 */ {'k', 'K'},
    /* 0x26 */ {'l', 'L'},
    /* 0x27 */ {';', ':'},
    /* 0x28 */ {'\'', '"'},
    /* 0x29 */ {'`', '~'},
    /* 0x2A */ {shift_l_char, shift_l_char},
    /* 0x2B */ {'\\', '|'},
    /* 0x2C */ {'z', 'Z'},
    /* 0x2D */ {'x', 'X'},
    /* 0x2E */ {'c', 'C'},
    /* 0x2F */ {'v', 'V'},
    /* 0x30 */ {'b', 'B'},
    /* 0x31 */ {'n', 'N'},
    /* 0x32 */ {'m', 'M'},
    /* 0x33 */ {',', '<'},
    /* 0x34 */ {'.', '>'},
    /* 0x35 */ {'/', '?'},
    /* 0x36	*/ {shift_r_char, shift_r_char},
    /* 0x37 */ {'*', '*'},
    /* 0x38 */ {alt_l_char, alt_l_char},
    /* 0x39 */ {' ', ' '},
    /* 0x3A */ {caps_lock_char, caps_lock_char}};

int ctrl_status = 0;      // 用于记录是否按下ctrl键
int shift_status = 0;     // 用于记录是否按下shift
int alt_status = 0;       // 用于记录是否按下alt键
int caps_lock_status = 0; // 用于记录是否按下大写锁定
int ext_scancode = 0;     // 用于记录是否是扩展码

static void intr_keyboard_handler(void)
{
    int break_code;                        // 用于判断传入值是否是断码
    uint16_t scancode = inb(KBD_BUF_PORT); // 从8042的0x60取出码值
    if (scancode == 0xe0)                  // 如果传入是0xe0，说明是处理两字节按键的扫描码，那么就应该立即退出去取出下一个字节
    {
        ext_scancode = 1; // 打开标记，记录传入的是两字节扫描码
        return;           // 退出
    }
    if (ext_scancode) // 如果能进入这个if，那么ext_scancode==1，说明上次传入的是两字节按键扫描码的第一个字节
    {
        scancode = ((0xe000) | (scancode)); // 合并扫描码，这样两字节的按键的扫描码就得到了完整取出
        ext_scancode = 0;                   // 关闭记录两字节扫描码的标志
    }

    break_code = ((scancode & 0x0080) != 0); // 断码=通码+0x80，如果是断码，那么&出来结果！=0，那么break_code值为1
    if (break_code)                          // 如果是断码，就要判断是否是控制按键的断码，如果是，就要将表示他们按下的标志清零，如果不是，就不处理。最后都要退出程序
    {
        uint16_t make_code = (scancode &= 0xff7f); // 将扫描码(现在是断码)还原成通码
        if (make_code == ctrl_l_make || make_code == ctrl_r_make)
            ctrl_status = 0; // 判断是否松开了ctrl
        else if (make_code == shift_l_make || make_code == shift_r_make)
            shift_status = 0; // 判断是否松开了shift
        else if (make_code == alt_l_make || make_code == alt_r_make)
            alt_status = 0; // 判断是否松开了alt
        return;
    }
    // 来到这里，说明不是断码，而是通码，这里的判断是保证我们只处理这些数组中定义了的键，以及右alt和ctrl。
    else if ((scancode > 0x00 && scancode < 0x3b) || (scancode == alt_r_make) || (scancode == ctrl_r_make))
    {
        int shift = 0;                       // 确定是否开启shift的标志，先默认设置成0
        uint8_t index = (scancode & 0x00ff); // 将扫描码留下低字节，这就是在数组中对应的索引

        if (scancode == ctrl_l_make || scancode == ctrl_r_make) // 如果扫描码是ctrl_l_make，或者ctrl_r_make，说明按下了ctrl
        {
            ctrl_status = 1;
            return;
        }
        else if (scancode == shift_l_make || scancode == shift_r_make)
        {
            shift_status = 1;
            return;
        }
        else if (scancode == alt_l_make || scancode == alt_r_make)
        {
            alt_status = 1;
            return;
        }
        else if (scancode == caps_lock_make) // 大写锁定键是按一次，然后取反
        {
            caps_lock_status = !caps_lock_status;
            return;
        }

        if ((scancode < 0x0e) || (scancode == 0x29) || (scancode == 0x1a) ||
            (scancode == 0x1b) || (scancode == 0x2b) || (scancode == 0x27) ||
            (scancode == 0x28) || (scancode == 0x33) || (scancode == 0x34) || (scancode == 0x35))
        {
            /*代表两个字母的键 0x0e 数字'0'~'9',字符'-',字符'='
                            0x29 字符'`'
                            0x1a 字符'['
                            0x1b 字符']'
                            0x2b 字符'\\'
                            0x27 字符';'
                            0x28 字符'\''
                            0x33 字符','
                            0x34 字符'.'
                            0x35 字符'/'
            */
            if (shift_status) // 如果同时按下了shift键
                shift = true;
        }
        else
        { // 默认为字母键
            if (shift_status + caps_lock_status == 1)
                shift = 1; // shift和大写锁定，那么判断是否按下了一个，而且不能是同时按下，那么就能确定是要开启shift
        }

        put_char(keymap[index][shift]); // 打印字符
        return;
    }
    else
        put_str("unknown key\n");
    return;
}

/* 键盘初始化 */
void keyboard_init()
{
    put_str("keyboard init start\n");
    register_handler(0x21, intr_keyboard_handler);
    put_str("keyboard init done\n");
}
```

### 实现环形缓冲区

由于shell命令一般是由多个字符组成，以回车作为结束的标志，所以我们需要创建并管理一个缓冲区，去存储以键入的信息，当组成完整的命令时交由其他模块运行。

内存中的缓冲区就是用来暂存数据的一片内存区域，内存是按地址来访问的，因此内存缓冲区实际上是线性存储。但是我们可以设计出逻辑上非线性的内存缓冲区，通过合理的操作方式可以构造出任何我们想要的数据结构，在这里我要介绍下环形缓冲区。即逻辑上环形，实际上线性。

![环形缓冲区示意图](/home/zhj/.config/Typora/typora-user-images/image-20240905203238071.png)

本质上是一个队列，头指针用于写数据，尾指针用于读数据。整个过程就是一个生产者消费者问题。

实现环形缓冲区(yourPath/chapter10/e/device/ioqueue.c)：

```C
#include "ioqueue.h"
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue *ioq)
{
    lock_init(&ioq->lock);                // 初始化io队列的锁
    ioq->producer = ioq->consumer = NULL; // 生产者和消费者置空
    ioq->head = ioq->tail = 0;            // 队列的首尾指针指向缓冲区数组第0个位置
}

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos)
{
    return (pos + 1) % bufsize; // 这样取得的下一个位置将会形成绕着环形缓冲区这个圈走的效果
}

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue *ioq)
{
    ASSERT(intr_get_status() == INTR_OFF);
    return next_pos(ioq->head) == ioq->tail;
}

/* 判断队列是否已空 */
bool ioq_empty(struct ioqueue *ioq)
{
    ASSERT(intr_get_status() == INTR_OFF);
    return ioq->head == ioq->tail;
}

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct **waiter)
{
    ASSERT(*waiter == NULL && waiter != NULL);
    *waiter = running_thread();
    thread_block(TASK_BLOCKED);
}

/* 唤醒waiter */
static void wakeup(struct task_struct **waiter)
{
    ASSERT(*waiter != NULL);
    thread_unblock(*waiter);
    *waiter = NULL;
}

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue *ioq)
{
    ASSERT(intr_get_status() == INTR_OFF);

    /* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
     * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
     * 也就是唤醒当前线程自己*/
    while (ioq_empty(ioq))
    { // 判断缓冲区是不是空的，如果是空的，就把自己阻塞起来
        lock_acquire(&ioq->lock);
        ioq_wait(&ioq->consumer);
        lock_release(&ioq->lock);
    }

    char byte = ioq->buf[ioq->tail]; // 从缓冲区中取出
    ioq->tail = next_pos(ioq->tail); // 把读游标移到下一位置

    if (ioq->producer != NULL)
    {
        wakeup(&ioq->producer); // 唤醒生产者
    }

    return byte;
}

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue *ioq, char byte)
{
    ASSERT(intr_get_status() == INTR_OFF);

    /* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
     * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
     * 也就是唤醒当前线程自己*/
    while (ioq_full(ioq))
    {
        lock_acquire(&ioq->lock);
        ioq_wait(&ioq->producer);
        lock_release(&ioq->lock);
    }
    ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
    ioq->head = next_pos(ioq->head); // 把写游标移到下一位置

    if (ioq->consumer != NULL)
    {
        wakeup(&ioq->consumer); // 唤醒消费者
    }
}
```

定义相关内容(yourPath/chapter10/e/device/ioqueue.h)：

```C
#ifndef __DEVICE_IOQUEUE_H
#define __DEVICE_IOQUEUE_H
#include "stdint.h"
#include "thread.h"
#include "sync.h"

#define bufsize 64 // 定义缓冲区大小.

/* 环形队列 */
struct ioqueue
{
    // 生产者消费者问题
    struct lock lock;
    /* 生产者,缓冲区不满时就继续往里面放数据,
     * 否则就睡眠,此项记录哪个生产者在此缓冲区上睡眠。*/
    struct task_struct *producer;

    /* 消费者,缓冲区不空时就继续从往里面拿数据,
     * 否则就睡眠,此项记录哪个消费者在此缓冲区上睡眠。*/
    struct task_struct *consumer;
    char buf[bufsize]; // 缓冲区大小
    int32_t head;      // 队首,数据往队首处写入
    int32_t tail;      // 队尾,数据从队尾处读出
};

void ioqueue_init(struct ioqueue *ioq);
bool ioq_full(struct ioqueue *ioq);
bool ioq_empty(struct ioqueue *ioq);
char ioq_getchar(struct ioqueue *ioq);
void ioq_putchar(struct ioqueue *ioq, char byte);

#endif
```

## 用户进程

### 局部描述符表 (LDT)

LDT:局部描述符表，，每个任务私有一份LDT，所以其位置不确定，所以需要在GDT中注册描述符，用于表示某个任务的局部描述符表的起始位置以及偏移大小。

![LDT描述符格式示意图](/home/zhj/.config/Typora/typora-user-images/image-20240905210424924.png)

GDT 被 lgdt 指令加载到 GDTR 寄存器中，所以 CPU 可以通过 GDTR寄存器找到 GDT 的位置，同理，CPU将在 LDTR 寄存器中找到 LDT 的起始位置以及偏移大小，但是加载命令有所不同。

GDTR 16位内存单元(界限值) & 32位内存单元(起始位置)。

LDTR 16位寄存器或者16位内存单元，必须是 LDT 选择字。

![LDTR寄存器示意图](/home/zhj/.config/Typora/typora-user-images/image-20240905211553360.png)

通过选择字中的TI位去判断是从GDT中取描述符还是从LDT中取描述符。

### TSS

intel 架构提供 TSS 这种原生机制用于进程切换。

TSS ：任务状态段，是用于存储任务状态的一个数据结构，每个任务都有自己的TSS。这个数据结构包含了在任务切换时需要保存和恢复的信息，例如处理器寄存器的值、堆栈指针、页目录基地址寄存器的值等，它放在内存的一块连续区域中。TSS是硬件级别任务切换机制的一部分。

以下是TSS的使用方式：

- 初始化TSS：在操作系统启动时，它会初始化一个或多个TSS。每个TSS都被初始化为包含一个任务的初始状态。比如，TSS可能被初始化为指向新任务的代码段的入口点，堆栈指针可能被初始化为指向新任务的栈顶，等等。


- 将TSS的描述符添加到GDT中：操作系统会为每个TSS在全局描述符表（GDT）中创建一个描述符。TSS描述符包含了TSS的基地址和大小，以及其他一些标志。一旦TSS描述符被添加到GDT中，处理器就可以使用这个描述符来访问这个TSS了。


- 使用LTR指令加载TSS：当操作系统想要切换到一个新任务时，它会使用LTR（Load Task Register）指令将新任务的TSS描述符加载到任务寄存器（TR）中，TR寄存器中是这个任务的TSS的GDT选择子。这个操作告诉处理器新任务的TSS在哪里。


- 任务切换：当处理器执行任务切换时，它会自动保存当前任务的状态到当前任务的TSS中，并从新任务的TSS中恢复新任务的状态。这包括保存和恢复处理器寄存器的值、堆栈指针的值，等等。


![32位TSS结构示意图](/home/zhj/.config/Typora/typora-user-images/image-20240905212736025.png)

现代x86体系上的操作系统并没有采用intel设计CPU时想的那种任务切换方式，因为其开销过大而导致效率过低，而是采用的一种基于TSS机制（因为这是硬件提供的，绕不开）的缩减版任务切换方式，在这种情况下，TSS主要被用于存储每个处理器的内核栈地址，以支持从用户模式到内核模式的切换，以下是关于利用TSS实现任务切换的一些要点。
1、当一个中断发生在用户态（特权级 3），处理器将从当前任务的 TSS 中获取 SS0 和 ESP0 字段的值。
2、每个 CPU 中只创建一个 TSS，在各个 CPU 上执行的所有任务都共享一个 TSS。
3、在 TR 加载 TSS 后，该 TR 寄存器将永远指向那一个 TSS，之后再也不会重新加载 TSS。
4、在进程切换时，只需要把 TSS 中的 SS0 和 ESP0 更新为新任务的内核栈的段地址以及栈指针。
5、Linux 对 TSS 的操作是一次性加载 TSS 到 TR，之后不断修改同一个 TSS 的内容，不再重复加载。
6、Linux 中任务切换不使用 call 和 jmp 指令，避免了任务切换的低效。
任务的状态信息存储位置： 当用户态触发中断后，由特权级 3 陷入特权级 0 后，CPU 自动从当前任务的 TSS 中获取 SS0 和 ESP0 字段的值，作为特权级 0 的栈，然后手动执行一系列 push 指令将任务的状态保存在特权级0的栈中

TSS作为绕不开的硬件机制，所以我们必须要先进入这种机制。也就是必须要GDT表中为其创建一个TSS段描述符，然后用加载选择子进入TR寄存器。

![内存中一些表的全景示意图](/home/zhj/.config/Typora/typora-user-images/image-20240905215139642.png)

定义tss相关内容，修改(yourPath/chapter11/a/kernel/global.h)：

```C
#ifndef __KERNEL_GLOBAL_H
#define __KERNEL_GLOBAL_H
#include "stdint.h"

// ----------------  GDT描述符属性  ----------------

#define DESC_G_4K 1
#define DESC_D_32 1
#define DESC_L 0   // 64位代码标记，此处标记为0便可。
#define DESC_AVL 0 // cpu不用此位，暂置为0
#define DESC_P 1
#define DESC_DPL_0 0
#define DESC_DPL_1 1
#define DESC_DPL_2 2
#define DESC_DPL_3 3
#define DESC_S_CODE 1
#define DESC_S_DATA DESC_S_CODE
#define DESC_S_SYS 0
#define DESC_TYPE_CODE 8 // x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.
#define DESC_TYPE_DATA 2 // x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.
#define DESC_TYPE_TSS 9  // B位为0,不忙

// 选择子的RPL字段
#define RPL0 0
#define RPL1 1
#define RPL2 2
#define RPL3 3

// 选择子的TI字段
#define TI_GDT 0
#define TI_LDT 1

// 定义不同的内核用的段描述符选择子
#define SELECTOR_K_CODE ((1 << 3) + (TI_GDT << 2) + RPL0)
#define SELECTOR_K_DATA ((2 << 3) + (TI_GDT << 2) + RPL0)
#define SELECTOR_K_STACK SELECTOR_K_DATA
#define SELECTOR_K_GS ((3 << 3) + (TI_GDT << 2) + RPL0)
// 定义不同的用户程序用的段描述符选择子
#define SELECTOR_U_CODE ((5 << 3) + (TI_GDT << 2) + RPL3)
#define SELECTOR_U_DATA ((6 << 3) + (TI_GDT << 2) + RPL3)
#define SELECTOR_U_STACK SELECTOR_U_DATA

#define GDT_ATTR_HIGH ((DESC_G_4K << 7) + (DESC_D_32 << 6) + (DESC_L << 5) + (DESC_AVL << 4))            // 定义段描述符的高32位的高字
#define GDT_CODE_ATTR_LOW_DPL3 ((DESC_P << 7) + (DESC_DPL_3 << 5) + (DESC_S_CODE << 4) + DESC_TYPE_CODE) // 定义用户程序用的代码段描述符高32位的低字
#define GDT_DATA_ATTR_LOW_DPL3 ((DESC_P << 7) + (DESC_DPL_3 << 5) + (DESC_S_DATA << 4) + DESC_TYPE_DATA) // 定义用户程序用的数据段描述符高32位的低字

//---------------  TSS描述符属性  ------------
#define TSS_DESC_D 0 // 这个D/B位在其他段描述中用于表示操作数的大小，但这里不是，实际上它根本就没有被使用（总是设置为0）。
                     // 这是因为TSS的大小和结构并不依赖于处理器运行在16位模式还是32位模式。
                     // 无论何时，TSS都包含了32位的寄存器值、32位的线性地址等等，因此没有必要用D/B位来表示操作的大小

#define TSS_ATTR_HIGH ((DESC_G_4K << 7) + (TSS_DESC_D << 6) + (DESC_L << 5) + (DESC_AVL << 4) + 0x0) // TSS段描述符高32位高字
#define TSS_ATTR_LOW ((DESC_P << 7) + (DESC_DPL_0 << 5) + (DESC_S_SYS << 4) + DESC_TYPE_TSS)         // TSS段描述符高32位低字
#define SELECTOR_TSS ((4 << 3) + (TI_GDT << 2) + RPL0)

struct gdt_desc
{
    uint16_t limit_low_word;
    uint16_t base_low_word;
    uint8_t base_mid_byte;
    uint8_t attr_low_byte;
    uint8_t limit_high_attr_high;
    uint8_t base_high_byte;
};

#define PG_SIZE 4096

////定义模块化的中断门描述符attr字段，attr字段指的是中断门描述符高字第8到16bit
#define IDT_DESC_P 1
#define IDT_DESC_DPL0 0
#define IDT_DESC_DPL3 3
#define IDT_DESC_32_TYPE 0xE // 32位的门
#define IDT_DESC_16_TYPE 0x6 // 16位的门，不用，定义它只为和32位门区分

#define IDT_DESC_ATTR_DPL0 ((IDT_DESC_P << 7) + (IDT_DESC_DPL0 << 5) + IDT_DESC_32_TYPE) // DPL为0的中断门描述符attr字段
#define IDT_DESC_ATTR_DPL3 ((IDT_DESC_P << 7) + (IDT_DESC_DPL3 << 5) + IDT_DESC_32_TYPE) // DPL为3的中断门描述符attr字段

#define NULL ((void *)0)
#define bool int
#define true 1
#define false 0

#endif
```

完成tss的创建与初始化，修改(yourPath/chapter11/a/userprog/tss.c)：

```C
#include "tss.h"
#include "stdint.h"
#include "global.h"
#include "string.h"
#include "print.h"

//定义tss的数据结构，在内存中tss的分布就是这个结构体
struct tss {
    uint32_t backlink;
    uint32_t* esp0;
    uint32_t ss0;
    uint32_t* esp1;
    uint32_t ss1;
    uint32_t* esp2;
    uint32_t ss2;
    uint32_t cr3;
    uint32_t (*eip) (void);
    uint32_t eflags;
    uint32_t eax;
    uint32_t ecx;
    uint32_t edx;
    uint32_t ebx;
    uint32_t esp;
    uint32_t ebp;
    uint32_t esi;
    uint32_t edi;
    uint32_t es;
    uint32_t cs;
    uint32_t ss;
    uint32_t ds;
    uint32_t fs;
    uint32_t gs;
    uint32_t ldt;
    uint16_t trace;
    uint16_t io_base;
};
static struct tss tss;

//用于更新TSS中的esp0的值，让它指向线程/进程的0级栈
void update_tss_esp(struct task_struct* pthread) {
   tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
}

//用于创建gdt描述符，传入参数1，段基址，传入参数2，段界限；参数3，属性低字节，参数4，属性高字节(要把低四位置0，高4位才是属性)
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
   uint32_t desc_base = (uint32_t)desc_addr;
   struct gdt_desc desc;
   desc.limit_low_word = limit & 0x0000ffff;
   desc.base_low_word = desc_base & 0x0000ffff;
   desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
   desc.attr_low_byte = (uint8_t)(attr_low);
   desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
   desc.base_high_byte = desc_base >> 24;
   return desc;
}

/* 在gdt中创建tss并重新加载gdt */
void tss_init() {
   put_str("tss_init start\n");
   uint32_t tss_size = sizeof(tss);
   memset(&tss, 0, tss_size);
   tss.ss0 = SELECTOR_K_STACK;
   tss.io_base = tss_size;

/* gdt段基址为0x900,把tss放到第4个位置,也就是0x900+0x20的位置 */

  //在gdt表中添加tss段描述符，在本系统的，GDT表的起始位置为0x00000900，那么tss的段描述就应该在0x920(0x900+十进制4*8)
  *((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);

  /* 在gdt中添加dpl为3的数据段和代码段描述符 */
  *((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
  *((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
   
  /* gdt 16位的limit 32位的段基址 */
   uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
   asm volatile ("lgdt %0" : : "m" (gdt_operand));
   asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
   put_str("tss_init and ltr done\n");
}
```

实现tss的定义(yourPath/chapter11/a/userprog/tss.h)：

```C
#ifndef __USERPROG_TSS_H
#define __USERPROG_TSS_H
#include "thread.h"
void update_tss_esp(struct task_struct* pthread);
void tss_init(void);
#endif
```

记得在init_all()中，初始化tss。

### 用户进程

用户进程和内核线程的区别：

- 进程有单独的4GB空间（虚拟）：
  - 创建并管理一个管理自己虚拟地址空间的地址池用作3级栈空间
  - 创建一个自己独立的页表作为进程的4GB虚拟地址空间

- 进程运行在特权级3，而内核线程运行在特权级0
  -  特权级从0到3的途径之一是中断返回：执行iret时，此时cs中加载的是用户程序代码段的选择子（RPL = 3）。
    - 1：从中断返回，必须要经过 intr_exit，即使是“假装”。
    - 2：必须提前准备好用户进程所用的栈结构，在里面填装好用户进程的上下文信息， 借一系列 pop 出栈的机会，将用户进程的上下文信息载入 CPU 的寄存器，为用户进程的运行准备好环境。
    - 3：要在栈中存储的 CS 选择子，其 RPL 必须为 3，确保CPL(CS.RPL)为3。
    - 4：栈中段 寄存器的选择子必须指向 DPL 为 3 的内存段。
    - 5：必须使栈中 eflags 的 IF 位为 1，确保可以响应其他可屏蔽中断。
    - 6：必须使栈中 eflags 的 IOPL 位为 0，确保不可访问硬件设备。

![用户进程的创建过程示意图](/home/zhj/.config/Typora/typora-user-images/image-20240909204725229.png)

![用户进程的执行过程示意图](/home/zhj/.config/Typora/typora-user-images/image-20240909204803546.png)

用户进程的创建是在特权级0下，执行过程是在特权级3下。实现过程如下：

增加头文件并在task_struct结构体中增加用户进程的虚拟地址，修改(yourPath/chapter11/b/thread/thread.c)：

```C
#include "memory.h"

/* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/
struct task_struct
{
    uint32_t *self_kstack; // 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息
    enum task_status status;
    uint8_t priority; // 线程优先级
    char name[16];    // 用于存储自己的线程的名字

    uint8_t ticks;                      // 线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时
    uint32_t elapsed_ticks;             // 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/
    struct list_elem general_tag;       // general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点
    struct list_elem all_list_tag;      // all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点
    uint32_t *pgdir;                    // 进程自己页表的虚拟地址
    struct virtual_addr userprog_vaddr; // 用户进程的虚拟地址
    uint32_t stack_magic;               // 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界
};
```

实现内存相关操作，修改(yourPath/chapter11/b/kernel/memory.c)：

```C
#include "memory.h"
#include "stdint.h"
#include "print.h"
#include "debug.h"
#include "string.h"
#include "sync.h"
#include "thread.h"

#define PG_SIZE 4096               // 一页的大小
#define MEM_BITMAP_BASE 0xc009a000 // 这个地址是位图的起始地址，1MB内存布局中，9FBFF是最大一段可用区域的边界，而我们计划这个可用空间最后的位置将来用来
// 放PCB，而PCB占用内存是一个自然页，所以起始地址必须是0xxxx000这种形式，离0x9fbff最近的符合这个形式的地址是0x9f000。我们又为了将来可能的拓展，
//  所以让位图可以支持管理512MB的内存空间，所以预留位图大小为16KB，也就是4页，所以选择0x9a000作为位图的起始地址

// 定义内核堆区起始地址，堆区就是用来进行动态内存分配的地方，咱们的系统内核运行在c00000000开始的1MB虚拟地址空间，所以自然要跨过这个空间，
// 堆区的起始地址并没有跨过256个页表，没关系，反正使用虚拟地址最终都会被我们的页表转换为物理地址，我们建立物理映射的时候，跳过256个页表就行了
#define K_HEAP_START 0xc0100000

/* 核心数据结构，物理内存池， 生成两个实例用于管理内核物理内存池和用户物理内存池 */
struct pool
{
    struct bitmap pool_bitmap; // 本内存池用到的位图结构,用于管理物理内存
    uint32_t phy_addr_start;   // 本内存池所管理物理内存的起始地址
    uint32_t pool_size;        // 本内存池字节容量
    struct lock lock;          // 申请内存时互斥
};

struct pool kernel_pool, user_pool; // 为kernel与user分别建立物理内存池，让用户进程只能从user内存池获得新的内存空间，
                                    // 以免申请完所有可用空间,内核就不能申请空间了
struct virtual_addr kernel_vaddr; // 用于管理内核虚拟地址空间

// 初始化内核物理内存池与用户物理内存池
static void mem_pool_init(uint32_t all_mem)
{
    put_str("   mem_pool_init start\n");
    uint32_t page_table_size = PG_SIZE * 256;       // 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
                                                    // 第769~1022个页目录项共指向254个页表,共256个页表
    uint32_t used_mem = page_table_size + 0x100000; // 已使用内存 = 1MB + 256个页表
    uint32_t free_mem = all_mem - used_mem;
    uint16_t all_free_pages = free_mem / PG_SIZE;                  // 将所有可用内存转换为页的数量，内存分配以页为单位，丢掉的内存不考虑
    uint16_t kernel_free_pages = all_free_pages / 2;               // 可用内存是用户与内核各一半，所以分到的页自然也是一半
    uint16_t user_free_pages = all_free_pages - kernel_free_pages; // 用于存储用户空间分到的页

    /* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
    好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
    uint32_t kbm_length = kernel_free_pages / 8; // 内核物理内存池的位图长度,位图中的一位表示一页,以字节为单位
    uint32_t ubm_length = user_free_pages / 8;   // 用户物理内存池的位图长度.

    uint32_t kp_start = used_mem;                               // Kernel Pool start,内核使用的物理内存池的起始地址
    uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE; // User Pool start,用户使用的物理内存池的起始地址

    kernel_pool.phy_addr_start = kp_start; // 赋值给内核使用的物理内存池的起始地址
    user_pool.phy_addr_start = up_start;   // 赋值给用户使用的物理内存池的起始地址

    kernel_pool.pool_size = kernel_free_pages * PG_SIZE; // 赋值给内核使用的物理内存池的总大小
    user_pool.pool_size = user_free_pages * PG_SIZE;     // 赋值给用户使用的物理内存池的总大小

    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length; // 赋值给管理内核使用的物理内存池的位图长度
    user_pool.pool_bitmap.btmp_bytes_len = ubm_length;   // 赋值给管理用户使用的物理内存池的位图长度

    /*********    内核内存池和用户内存池位图   ***********
     *   位图是全局的数据，长度不固定。
     *   全局或静态的数组需要在编译时知道其长度，
     *   而我们需要根据总内存大小算出需要多少字节。
     *   所以改为指定一块内存来生成位图.
     *   ************************************************/
    // 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
    // 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
    kernel_pool.pool_bitmap.bits = (void *)MEM_BITMAP_BASE; // 管理内核使用的物理内存池的位图起始地址

    /* 用户内存池的位图紧跟在内核内存池位图之后 */
    user_pool.pool_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length); // 管理用户使用的物理内存池的位图起始地址
    /******************** 输出内存池信息 **********************/
    put_str("      kernel_pool_bitmap_start:");
    put_int((int)kernel_pool.pool_bitmap.bits);
    put_str(" kernel_pool_phy_addr_start:");
    put_int(kernel_pool.phy_addr_start);
    put_str("\n");
    put_str("      user_pool_bitmap_start:");
    put_int((int)user_pool.pool_bitmap.bits);
    put_str(" user_pool_phy_addr_start:");
    put_int(user_pool.phy_addr_start);
    put_str("\n");

    /* 将位图置0*/
    bitmap_init(&kernel_pool.pool_bitmap);
    bitmap_init(&user_pool.pool_bitmap);

    lock_init(&kernel_pool.lock);
    lock_init(&user_pool.lock);

    /* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/
    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length; // 赋值给管理内核可以动态使用的虚拟地址池（堆区）的位图长度，
                                                           // 其大小与管理内核可使用的物理内存池位图长度相同，因为虚拟内存最终都要转换为真实的物理内存，可用虚拟内存大小超过可用物理内存大小在
                                                           // 我们这个简单操作系统无意义（现代操作系统中有意义，因为我们可以把真实物理内存不断换出，回收，来让可用物理内存变相变大)

    /* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
    kernel_vaddr.vaddr_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length + ubm_length); // 赋值给管理内核可以动态使用的虚拟内存池（堆区）的位图起始地址

    kernel_vaddr.vaddr_start = K_HEAP_START; // 赋值给内核可以动态使用的虚拟地址空间的起始地址
    bitmap_init(&kernel_vaddr.vaddr_bitmap); // 初始化管理内核可以动态使用的虚拟地址池的位图
    put_str("   mem_pool_init done\n");
}

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void *vaddr_get(enum pool_flags pf, uint32_t pg_cnt)
{
    int vaddr_start = 0, bit_idx_start = -1;
    uint32_t cnt = 0;
    if (pf == PF_KERNEL)
    {
        bit_idx_start = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
        if (bit_idx_start == -1)
        {
            return NULL;
        }
        while (cnt < pg_cnt)
        {
            bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
        }
        vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
    }
    else
    {
        // 用户内存池,将来实现用户进程再补充
    }
    return (void *)vaddr_start;
}

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void *palloc(struct pool *m_pool)
{
    /* 扫描或设置位图要保证原子操作 */
    int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1); // 找一个物理页面
    if (bit_idx == -1)
    {
        return NULL;
    }
    bitmap_set(&m_pool->pool_bitmap, bit_idx, 1); // 将此位bit_idx置1
    uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
    return (void *)page_phyaddr;
}

#define PDE_IDX(addr) ((addr & 0xffc00000) >> 22)
#define PTE_IDX(addr) ((addr & 0x003ff000) >> 12)

/* 得到虚拟地址vaddr对应的pde的指针 */
uint32_t *pde_ptr(uint32_t vaddr)
{
    /* 0xfffff是用来访问到页表本身所在的地址 */
    uint32_t *pde = (uint32_t *)((0xfffff000) + PDE_IDX(vaddr) * 4);
    return pde;
}

/* 得到虚拟地址vaddr对应的pte指针*/
uint32_t *pte_ptr(uint32_t vaddr)
{
    /* 先访问到页表自己 + 再用页目录项pde(页目录内页表的索引)做为pte的索引访问到页表 + 再用pte的索引做为页内偏移*/
    uint32_t *pte = (uint32_t *)(0xffc00000 + ((vaddr & 0xffc00000) >> 10) + PTE_IDX(vaddr) * 4);
    return pte;
}

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void *_vaddr, void *_page_phyaddr)
{
    uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
    uint32_t *pde = pde_ptr(vaddr);
    uint32_t *pte = pte_ptr(vaddr);

    /************************   注意   *************************
     * 执行*pte,会访问到空的pde。所以确保pde创建完成后才能执行*pte,
     * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。
     * *********************************************************/
    /* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
    if (*pde & 0x00000001)
    { // 页目录项和页表项的第0位为P,此处判断目录项是否存在
        ASSERT(!(*pte & 0x00000001));

        if (!(*pte & 0x00000001))
        {                                                       // 只要是创建页表,pte就应该不存在,多判断一下放心
            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); // US=1,RW=1,P=1
        }
        else
        { // 应该不会执行到这，因为上面的ASSERT会先执行。
            PANIC("pte repeat");
            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); // US=1,RW=1,P=1
        }
    }
    else
    {   // 页目录项不存在,所以要先创建页目录再创建页表项.
        /* 页表中用到的页框一律从内核空间分配 */
        uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);

        *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);

        /* 分配到的物理页地址pde_phyaddr对应的物理内存清0,
         * 避免里面的陈旧数据变成了页表项,从而让页表混乱.
         * 访问到pde对应的物理地址,用pte取高20位便可.
         * 因为pte是基于该pde对应的物理地址内再寻址,
         * 把低12位置0便是该pde对应的物理页的起始*/
        memset((void *)((int)pte & 0xfffff000), 0, PG_SIZE);

        ASSERT(!(*pte & 0x00000001));
        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); // US=1,RW=1,P=1
    }
}

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void *malloc_page(enum pool_flags pf, uint32_t pg_cnt)
{
    ASSERT(pg_cnt > 0 && pg_cnt < 3840);
    /***********   malloc_page的原理是三个动作的合成:   ***********
          1通过vaddr_get在虚拟内存池中申请虚拟地址
          2通过palloc在物理内存池中申请物理页
          3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
    ***************************************************************/
    void *vaddr_start = vaddr_get(pf, pg_cnt);
    if (vaddr_start == NULL)
    {
        return NULL;
    }

    uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
    struct pool *mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

    /* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
    while (cnt-- > 0)
    {
        void *page_phyaddr = palloc(mem_pool);
        if (page_phyaddr == NULL)
        { // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
            return NULL;
        }
        page_table_add((void *)vaddr, page_phyaddr); // 在页表中做映射
        vaddr += PG_SIZE;                            // 下一个虚拟页
    }
    return vaddr_start;
}

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void *get_kernel_pages(uint32_t pg_cnt)
{
    lock_acquire(&kernel_pool.lock);
    void *vaddr = malloc_page(PF_KERNEL, pg_cnt);
    if (vaddr != NULL)
    { // 若分配的地址不为空,将页框清0后返回
        memset(vaddr, 0, pg_cnt * PG_SIZE);
    }
    lock_release(&kernel_pool.lock);
    return vaddr;
}

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void *get_user_pages(uint32_t pg_cnt)
{
    lock_acquire(&user_pool.lock);
    void *vaddr = malloc_page(PF_USER, pg_cnt);
    memset(vaddr, 0, pg_cnt * PG_SIZE);
    lock_release(&user_pool.lock);
    return vaddr;
}

// 用于为指定的虚拟地址申请一个物理页，传入参数是这个虚拟地址，要申请的物理页所在的地址池的标志。申请失败，返回null
void *get_a_page(enum pool_flags pf, uint32_t vaddr)
{
    struct pool *mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
    lock_acquire(&mem_pool->lock);
    struct task_struct *cur = running_thread();
    int32_t bit_idx = -1;
    /* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */
    if (cur->pgdir != NULL && pf == PF_USER)
    {
        bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
        ASSERT(bit_idx > 0);
        bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
    }
    else if (cur->pgdir == NULL && pf == PF_KERNEL)
    {
        /* 如果是内核线程申请内核内存,就修改kernel_vaddr. */
        bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
        ASSERT(bit_idx > 0);
        bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
    }
    else
    {
        PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
    }
    void *page_phyaddr = palloc(mem_pool);
    if (page_phyaddr == NULL)
        return NULL;
    page_table_add((void *)vaddr, page_phyaddr);
    lock_release(&mem_pool->lock);
    return (void *)vaddr;
}

/* 内存管理部分初始化入口 */
void mem_init()
{
    put_str("mem_init start\n");
    uint32_t mem_bytes_total = (*(uint32_t *)(0xb00));
    mem_pool_init(mem_bytes_total); // 初始化内存池
    put_str("mem_init done\n");
}

// 将虚拟地址转换成真实的物理地址
uint32_t addr_v2p(uint32_t vaddr)
{
    uint32_t *pte = pte_ptr(vaddr);                      // 将虚拟地址转换成页表对应的页表项的地址
    return ((*pte & 0xfffff000) + (vaddr & 0x00000fff)); //(*pte)的值是页表所在的物理页框地址,去掉其低12位的页表项属性+虚拟地址vaddr的低12位
}
```

记得修改其头文件(yourPath/chapter11/b/kernel/memory.h)。

增加进程操作，编写(yourPath/chapter11/b/userprog/process.c)：

```C
#include "process.h"
#include "thread.h"
#include "global.h" //定义了PG_SIZE
#include "memory.h"
#include "bitmap.h"
#include "string.h"
#include "tss.h"
#include "console.h"
#include "debug.h"
#include "interrupt.h"

// 用于初始化进程pcb中的用于管理自己虚拟地址空间的虚拟内存池结构体
void create_user_vaddr_bitmap(struct task_struct *user_prog)
{
    user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;
    uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8, PG_SIZE);         // 计算出管理用于进程那么大的虚拟地址的
                                                                                                           // 位图需要多少页的空间来存储（向上取整结果）
    user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);                         // 申请位图空间
    user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8; // 计算出位图长度（字节单位）
    bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);                                                  // 初始化位图
}

// 用于为进程创建页目录表，并初始化（系统映射+页目录表最后一项是自己的物理地址，以此来动态操作页目录表），成功后，返回页目录表虚拟地址，失败返回空地址
uint32_t *create_page_dir(void)
{
    uint32_t *page_dir_vaddr = get_kernel_pages(1); // 用户进程的页表不能让用户直接访问到,所以在内核空间来申请
    if (page_dir_vaddr == NULL)
    {
        console_put_str("create_page_dir: get_kernel_page failed!");
        return NULL;
    }
    // 将内核页目录表的768号项到1022号项复制过来
    memcpy((uint32_t *)((uint32_t)page_dir_vaddr + 768 * 4), (uint32_t *)(0xfffff000 + 768 * 4), 255 * 4);
    uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);       // 将进程的页目录表的虚拟地址，转换成物理地址
    page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1; // 页目录表最后一项填自己的地址，为的是动态操作页表
    return page_dir_vaddr;
}

extern void intr_exit(void);

// 用于初始化进入进程所需要的中断栈中的信息，传入参数是实际要运行的函数地址(进程)，这个函数是用线程启动器进入的（kernel_thread）
void start_process(void *filename_)
{
    void *function = filename_;
    struct task_struct *cur = running_thread();
    cur->self_kstack += sizeof(struct thread_stack); // 当我们进入到这里的时候，cur->self_kstack指向thread_stack的起始地址，跳过这里，才能设置intr_stack
    struct intr_stack *proc_stack = (struct intr_stack *)cur->self_kstack;
    proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
    proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
    proc_stack->gs = 0; // 用户态根本用不上这个，所以置为0（gs我们一般用于访问显存段，这个让内核态来访问）
    proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;
    proc_stack->eip = function; // 设定要执行的函数（进程）的地址
    proc_stack->cs = SELECTOR_U_CODE;
    proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1); // 设置用户态下的eflages的相关字段
                                                                     // 下面这一句是在初始化中断栈中的栈顶位置，我们先为虚拟地址0xc0000000 - 0x1000申请了个物理页，然后将虚拟地址+4096置为栈顶
    proc_stack->esp = (void *)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE);
    proc_stack->ss = SELECTOR_U_DATA;
    asm volatile("movl %0, %%esp; jmp intr_exit" : : "g"(proc_stack) : "memory");
}

/* 激活页表 */
void page_dir_activate(struct task_struct *p_thread)
{
    /********************************************************
     * 执行此函数时,当前任务可能是线程。
     * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程,
     * 否则不恢复页表的话,线程就会使用进程的页表了。
     ********************************************************/

    /* 若为内核线程,需要重新填充页表为0x100000 */
    uint32_t pagedir_phy_addr = 0x100000; // 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
    if (p_thread->pgdir != NULL)
    { // 如果不为空，说明要调度的是个进程，那么就要执行加载页表，所以先得到进程页目录表的物理地址
        pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
    }
    asm volatile("movl %0, %%cr3" : : "r"(pagedir_phy_addr) : "memory"); // 更新页目录寄存器cr3,使新页表生效
}

// 用于加载进程自己的页目录表，同时更新进程自己的0特权级esp0到TSS中
void process_activate(struct task_struct *p_thread)
{
    ASSERT(p_thread != NULL);
    /* 激活该进程或线程的页表 */
    page_dir_activate(p_thread);
    /* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
    if (p_thread->pgdir)
        update_tss_esp(p_thread); /* 更新该进程的esp0,用于此进程被中断时保留上下文 */
}

// 用于创建进程，参数是进程要执行的函数与他的名字
void process_execute(void *filename, char *name)
{
    /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
    struct task_struct *thread = get_kernel_pages(1);
    init_thread(thread, name, default_prio);
    create_user_vaddr_bitmap(thread);
    thread_create(thread, start_process, filename);
    thread->pgdir = create_page_dir();

    enum intr_status old_status = intr_disable();
    ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
    list_append(&thread_ready_list, &thread->general_tag);

    ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
    list_append(&thread_all_list, &thread->all_list_tag);
    intr_set_status(old_status);
}
```

增加其头文件，编写(yourPath/chapter11/b/userprog/process.h)：

```C
#ifndef __USERPROG_PROCESS_H
#define __USERPROG_PROCESS_H
#include "thread.h"
#define default_prio 31                         // 定义默认的优先级
#define USER_STACK3_VADDR (0xc0000000 - 0x1000) // 定义了一页C语言程序的栈顶起始地址（虚拟）,书p511
#define USER_VADDR_START 0x8048000              // linux下大部分可执行程序的入口地址（虚拟）都是这个附近，我们也仿照这个设定
void create_user_vaddr_bitmap(struct task_struct *user_prog);
uint32_t *create_page_dir(void);
void start_process(void *filename_);
void intr_init(void *func);
void page_dir_activate(struct task_struct *p_thread);
void process_execute(void *filename, char *name);
void process_activate(struct task_struct *p_thread);
#endif
```

在thread.c中的schedule()中加入process_activate()，将进程执行调度上CPU，实现进程的执行。

```C
/* 实现任务调度 */
void schedule()
{
    ASSERT(intr_get_status() == INTR_OFF);
    struct task_struct *cur = running_thread();
    if (cur->status == TASK_RUNNING)
    { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
        ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
        list_append(&thread_ready_list, &cur->general_tag);
        cur->ticks = cur->priority; // 重新将当前线程的ticks再重置为其priority;
        cur->status = TASK_READY;
    }
    else
    {
        /* 若此线程需要某事件发生后才能继续上cpu运行,
        不需要将其加入队列,因为当前线程不在就绪队列中。*/
    }

    ASSERT(!list_empty(&thread_ready_list));
    thread_tag = NULL; // thread_tag清空
                       /* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
    thread_tag = list_pop(&thread_ready_list);
    struct task_struct *next = elem2entry(struct task_struct, general_tag, thread_tag);
    next->status = TASK_RUNNING;
    process_activate(next); // 激活任务页表
    switch_to(cur, next);
}
```

## 完善内核

### 实现系统调用

### 完善内存管理

## 编写内核驱动程序

### 实现硬盘和分区表

### 编写内核驱动程序
